#!/bin/bash -

#
# This script is a part of "set_environment" installer and should not be called directry.
# It got sourced from src/architecture/linux/continue_install.sh
#

# Table of contents generated by function file_toc():
#
#    - add_to_install_if_missing
#    - apt_install_basic_packages
#    - ff_agent_install
#    - ff_agent_install_bashrc
#    - ff_agent_register_pm2_systemd
#    - ff_agent_run_pm2
#    - ff_agent_update_install
#    - install_authbind
#    - install_build_tools
#    - install_n
#    - install_nodejs
#    - install_nodejs_suite
#    - pm2_configure_container
#    - pm2_configure_host
#    - pm2_install
#    - pm2_is_installed_and_working
#    - pm2_is_running_as_me
#    - pm2_start
#    - pm2_stop
#    - pm2_update
#    - pm2_uninstall
#    - set_environment_ensure_install_exists
#    - set_environment_preserve_source_code
#    - logging_script_set_deprecated

################################################################################
#
# Return information if package is installed in system, dpkg depend
# @param ${1} string package name
# @param ${2} array package list to append
#
# Return code value:
#  0 - Success
#      Note: disregard of package is already installed or not, the success
#            for function "add_to_install_if_missing" means we checked and added
#            (if it was missing) and didn't face any errors.
#
#  1 - on error (e.g.: bad arguments)
#
# Usage: add_to_install_if_missing "vim" PACKAGES
#
function add_to_install_if_missing {

  # Check dependencies
  local DEPENDENCIES=(
    "error"
    "dpkg"
    "grep"
    "in_array"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || return 1  # Note: check_dependencies will report missing dependencies

  # Take argument ${1} - package name
  local PACKAGE="${1}"

  # Check inputs: ${PACKAGE} - must be not empty string (package name to check)
  if [ "${PACKAGE}" == "" ]; then
    error "${FUNCNAME[0]} bad arguments: package name is not specified (no arguments)"
    return 1
  fi

  # Take argument ${2} - reference to array
  declare -n PACKAGES_TO_INSTALL=${2}

  # Check inputs: ${PACKAGES_TO_INSTALL} - must be a reference to an array
  if [ "${PACKAGES_TO_INSTALL@a}" != "a" ]; then
    # Error: passed reference does not point to array
    error "${FUNCNAME[0]} bad arguments: 2nd argument must be reference to array"
    return 1
  fi

  # Check if given PACKAGE is already present in PACKAGES_TO_INSTALL array
  if in_array "${PACKAGE}" "${PACKAGES_TO_INSTALL[@]}"; then
    # Yes, already present, nothing to do
    return 0
  fi

	# Check if given package is already installed.
  # Note: grep exit code 0=installed, 1=not installed.
	# Note we use grep to cover case "Status: deinstall ok config-files" when package was uninstalled.
	dpkg --status "${PACKAGE}" 2>/dev/null | grep --silent "installed"
	INSTALLED=${?}

  # Check exit code
	if [ ${INSTALLED} != 0 ]; then
    # Not installed. Add package name into the list.
		PACKAGES_TO_INSTALL+=("${PACKAGE}")
	fi

}
export -f add_to_install_if_missing

################################################################################
#
# Install basic packages
#
function apt_install_basic_packages {

  state_set "${FUNCNAME[0]}" 'started'

  # Check dependencies
  local DEPENDENCIES=(
    "add_to_install_if_missing"
    "apt_install"
    "apt_update"
    "apt_upgrade"
    "assert_clean_exit"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  # Update apt index and installed components, before installing additional packages.
  assert_clean_exit apt_update
  assert_clean_exit apt_upgrade

  # Define list of all required packages (by category, comment why we need the package for non-obvious ones)
  local REQUIRED_PACKAGES=(
      apt-utils # apt-utils required to avoid error: debconf: delaying package configuration, since apt-utils is not installed
      apt-transport-https # APT transport for downloading via the HTTP Secure protocol (HTTPS)
      software-properties-common # Part of "apt": manage the repositories that you install software from 3rd party repos (i.e. add their repo + gpg key)

      # The GNU Core Utilities are the basic file, shell and text manipulation utilities of the GNU operating system.
      # These are the core utilities which are expected to exist on every operating system.
      coreutils

      # Curl must exist for this script and many others
      curl

      # The ff_bash_functions require jq
      jq

      # This script requires grep
      grep

      # gnupg2
      lsb-release

      # ssh client (for the set environment ssh-keyscan command when the preserve set environment code is run)
      openssh-client

      # System: CA certificates
      ca-certificates # Common CA certificates - Docker requires

  )
  local MISSING_PACKAGES=()

  # Iterate required packages and collect only missing ones
  for REQUIRED_PACKAGE in "${REQUIRED_PACKAGES[@]}"; do
    add_to_install_if_missing "${REQUIRED_PACKAGE}" MISSING_PACKAGES
  done

  # Install only missing packages
  apt_install "${MISSING_PACKAGES[@]}" || { state_set "${FUNCNAME[0]}" 'error_failed_apt_install'; return 1; }

  state_set "${FUNCNAME[0]}" 'success'
}
export -f apt_install_basic_packages


################################################################################
#
# Install npm package "@ff/ff_agent" to FF_AGENT_HOME globally.
#
# TODO: Some of this needs to go to basic node setup?
function ff_agent_install {
  state_set "${FUNCNAME[0]}" 'started'

  # Check dependencies
  local DEPENDENCIES=(
    "abort"
    "apt_install"
    "command_exists"
    "hardware_architecture_get"
    "node"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  # Define the version of ff_agent npm package to install from CDN
  VERSION='latest'

  local ARCHITECTURE
  ARCHITECTURE=$( hardware_architecture_get ) || { state_set "${FUNCNAME[0]}" "error_getting_hardware_architecture"; return 1; }

  # If we are on arm64, we likely need to install some extra packages
  # This is done as a case, just in case we have other such architectural changes for other architectures.
  case "${ARCHITECTURE}" in
    arm64 | amd64)
      PACKAGES_TO_INSTALL=(
        libcurl4-openssl-dev  # This provides the necessary headers and libraries for libcurl (core dependency).
        libssl-dev            # Needed for OpenSSL support, often linked via libcurl.
        build-essential       # Includes gcc, g++, make, etc., required to compile native Node.js modules.
        node-gyp              # Used by npm to compile native modules (may already be installed globally or as part of npm).
        python3               # Used by node-gyp as part of the native build process.
        pkg-config            # This helps in locating the proper versions of libraries during the build process.
      )
      apt_install "${PACKAGES_TO_INSTALL[@]}" || {
          state_set "${FUNCNAME[0]}" 'terminal_error_unable_to_ff_agent_install_dependencies'
          abort "${FUNCNAME[0]}" 'terminal_error_unable_to_ff_agent_install_dependencies'
        }
    ;;
    *)
    ;;
  esac

  # Install ff_agent
  # Previously we tried to install from CDN: npm install --global "${FF_CONTENT_URL}/ff/npm/ff-ff_agent-${VERSION}
  npm install --global "@ff/ff_agent@${VERSION}" || {
    log "${FUNCNAME[0]}" "[ERROR] npm install @ff/ff_agent@${VERSION} failed Debug info of .npmrc :"
    cat "${HOME}/.npmrc" || true
    state_set "${FUNCNAME[0]}" 'failed_to_ff_agent_install'
    abort "${FUNCNAME[0]}" 'failed_to_ff_agent_install'
  }

  # Ensure ff_agent is installed in the PATH
  command_exists ff_agent || {
    state_set "${FUNCNAME[0]}" 'terminal_error_unable_to_find_ff_agent'
    abort "${FUNCNAME[0]}" 'terminal_error_unable_to_find_ff_agent'
  }

  state_set "${FUNCNAME[0]}" 'success'
}
export -f ff_agent_install

################################################################################
# CATEGORY
#   AGENT INSTALLATION FUNCTIONS
#
# NAME
#   ff_agent_install_bashrc - Ensure ff_agent environment is sourced from bash init files.
#
# SYNOPSIS
#   ff_agent_install_bashrc
#
# DESCRIPTION
#   Ensures proper shell environment initialization for ff_agent by injecting
#   sourcing logic into both the user's `.bashrc` and `.profile`, as well as
#   a dedicated ff_agent `.profile` located in ${FF_AGENT_HOME}.
#
#   The function performs the following steps:
#     - Verifies required environment variables (FF_AGENT_USERNAME, FF_AGENT_HOME) are set.
#     - Validates that ${FF_AGENT_HOME} exists.
#     - Creates missing `.bashrc` or `.profile` files if necessary.
#     - Injects a line to source ${FF_AGENT_HOME}/.profile into `.bashrc` and `.profile`.
#     - Injects a line into the ff_agent `.profile` to source the shared `ff_bash_functions` library.
#     - Injects a call to `discover_environment` into the ff_agent `.profile`.
#     - Injects the ff_agent `bin` directory into the `PATH` in the custom profile.
#     - Updates the current shellâ€™s `PATH` variable if the bin path was not already present.
#
#   Each modification uses `inject_into_file` to ensure idempotent updates, preventing duplicate entries.
#
# DEPENDENCIES
#   - ensure_variable_not_empty
#   - state_set
#   - error
#   - abort
#   - inject_into_file
#   - discover_environment (called in profile)
#
# REQUIRED ENVIRONMENT VARIABLES
#   - FF_AGENT_USERNAME : Username under which ff_agent is installed
#   - FF_AGENT_HOME     : Root directory of the ff_agent installation
#
# USAGE EXAMPLE
#   ff_agent_install_bashrc
#
# EXIT STATUS
#   Aborts or returns non-zero on:
#     - Missing or empty required environment variables
#     - Missing ${FF_AGENT_HOME} directory
#     - Failure to create or modify any targeted profile/init file
#     - Failure to update the PATH variable
#   Returns 0 on successful injection of all profile customizations.
#
################################################################################
function ff_agent_install_bashrc {
  state_set "${FUNCNAME[0]}" 'started'

  # Check dependencies
  local DEPENDENCIES=(
    "abort"
    "discover_environment"
    "ensure_variable_not_empty"
    "error"
    "inject_into_file"
    "state_set"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  # Define required non-empty variables
  local REQUIRED_NON_EMPTY_VARIABLES=(
    "FF_AGENT_USERNAME"
    "FF_AGENT_HOME"
    "HOME"
  )
  ensure_variables_not_empty "${FUNCNAME[0]}" "${REQUIRED_NON_EMPTY_VARIABLES[@]}" || { # Note: ensure_variables_not_empty will report missing variables
    state_set "${FUNCNAME[0]}" 'ensure_variables_not_empty_failed'
    return 1
  }

  # Make sure ${FF_AGENT_HOME} folder exists
  if [ ! -d "${FF_AGENT_HOME}" ]; then
    # ${FF_AGENT_HOME} folder is missing. Don't try to create it (it is not our responsibility)
    # Report an error and abort.
    state_set "${FUNCNAME[0]}" 'terminal_error_ff_agent_home_folder_does_not_exist'
    abort "${FUNCNAME[0]}" "FF_AGENT_HOME='${FF_AGENT_HOME}' directory Does not exist. Aborting."
  fi

  # Define location of two profile files
  local HOME_PROFILE_FILE="${HOME}/.profile"
  local FF_AGENT_PROFILE_FILE="${FF_AGENT_HOME}/.profile"    # example: /home/ubuntu/ff_agent/.profile  (Note: FF_AGENT_PROFILE_FILE is not local, but shell environment used in other install functions)

  # Define location of .bashrc file
  local HOME_BASHRC_FILE="${HOME}/.bashrc"

  # --------------------------------------------------------------------
  # Inject sourcing ff_agent/.profile into files:
  TARGET_FILES=( "${HOME_BASHRC_FILE}" "${HOME_PROFILE_FILE}" )

  # Iterate target files
  for TARGET_FILE in "${TARGET_FILES[@]}"; do
    # Create TARGET_FILE if missing
    if [ ! -f "${TARGET_FILE}" ]; then
      (
        cat <<EOT
# File ${TARGET_FILE} created by set_environment ${FUNCNAME[0]}() on $(date --utc).
EOT
      ) > "${TARGET_FILE}" || { state_set "${FUNCNAME[0]}" "failed_to_create_file"; return 1; }
    fi

    PATTERN="^source \"${FF_AGENT_PROFILE_FILE}\""
    INJECT_CONTENT=$(
      cat <<EOT
# Sourcing ${FF_AGENT_PROFILE_FILE} injected by set_environment ${FUNCNAME[0]}() on $(date --utc).
source "${FF_AGENT_PROFILE_FILE}"
EOT
    )
    ERROR_CODE='error_injecting_source_custom_profile'

    # Do injection and check result
    inject_into_file "${TARGET_FILE}" "${PATTERN}" "${INJECT_CONTENT}" || { state_set "${FUNCNAME[0]}" "${ERROR_CODE}"; return 1; }
  done
  #
  # --------------------------------------------------------------------

  # --------------------------------------------------------------------
  # Inject sourcing ff_bash_functions

  # Define path to the installed ff_bash_functions
  local FF_BASH_FUNCTIONS_PATH="${FF_AGENT_HOME}/git/redwolfsecurity/set_environment/src/ff_bash_functions"

  # Inject into the custom .profile to source ff_bash_functions (if missing)
  # Search expected line
  TARGET_FILE="${FF_AGENT_PROFILE_FILE}"
  PATTERN="^source \"${FF_BASH_FUNCTIONS_PATH}"
  INJECT_CONTENT=$(
    cat <<EOT
# Sourcing bash functions library from ${FF_BASH_FUNCTIONS_PATH} injected by set_environment ${FUNCNAME[0]}() on $(date --utc).
source "${FF_BASH_FUNCTIONS_PATH}"
EOT
  )
  ERROR_CODE='error_injecting_source_ff_bash_functions'

  # Create TARGET_FILE if missing
  if [ ! -f "${TARGET_FILE}" ]; then
    (
      cat <<EOT
# File ${TARGET_FILE} created by set_environment ${FUNCNAME[0]}() on $(date --utc).
EOT
    ) > "${TARGET_FILE}" || { state_set "${FUNCNAME[0]}" "failed_to_create_file"; return 1; }
  fi

  # Do injection and check result
  inject_into_file "${TARGET_FILE}" "${PATTERN}" "${INJECT_CONTENT}" || { state_set "${FUNCNAME[0]}" "${ERROR_CODE}"; return 1; }
  #
  # --------------------------------------------------------------------

  # --------------------------------------------------------------------
  # Inject call to "discover_environment" into the custom .profile
  TARGET_FILE="${FF_AGENT_PROFILE_FILE}"
  PATTERN="^discover_environment"
  INJECT_CONTENT=$(
      cat <<EOT
discover_environment
EOT
  )
  ERROR_CODE='error_injecting_discover_environment_call_to_custom_profile'

  # Do injection and check result
  inject_into_file "${TARGET_FILE}" "${PATTERN}" "${INJECT_CONTENT}" || { state_set "${FUNCNAME[0]}" "${ERROR_CODE}"; return 1; }
  #
  # --------------------------------------------------------------------

  # --------------------------------------------------------------------
  # Inject ${FF_AGENT_BIN} into PATH in .profile and modify current PATH if needed.

  # Define the path to ff_agent/bin folder, which we will inject into PATH
  local FF_AGENT_BIN="${FF_AGENT_HOME}/bin"

  # Update PATH variable (if it not yet contains expected string)
  # printenv PATH | grep --quiet "${FF_AGENT_BIN}"
  # if [ ${?} -ne 0 ]; then
  #  export PATH="${FF_AGENT_BIN}:${PATH}" || { state_set "${FUNCNAME[0]}" 'error_modifying_path'; return 1; }
  # fi
  # Update PATH variable if it does not yet contain the expected bin directory
  if [[ ":$PATH:" != *":${FF_AGENT_BIN}:"* ]]; then
    export PATH="${FF_AGENT_BIN}:${PATH}" || {
      state_set "${FUNCNAME[0]}" 'error_modifying_path'
      return 1
    }
  fi

  TARGET_FILE="${FF_AGENT_PROFILE_FILE}"
  PATTERN="^export PATH=\"${FF_AGENT_BIN}"
  INJECT_CONTENT=$(
      cat <<EOT
export PATH="${FF_AGENT_BIN}:\${PATH}"
EOT
  )
  ERROR_CODE='error_injecting_ff_agent_bin_path_to_custom_profile'

  # Do injection and check result
  inject_into_file "${TARGET_FILE}" "${PATTERN}" "${INJECT_CONTENT}" || { state_set "${FUNCNAME[0]}" "${ERROR_CODE}"; return 1; }
  #
  # --------------------------------------------------------------------

  # Chage state and return success
  state_set "${FUNCNAME[0]}" 'success'
}
export -f ff_agent_install_bashrc

################################################################################
# CATEGORY
#   AGENT CONTROL FUNCTIONS
#
# NAME
#   ff_agent_register_pm2_systemd - Register pm2 to launch on boot using systemd.
#
# SYNOPSIS
#   ff_agent_register_pm2_systemd
#
# DESCRIPTION
#   Ensures that pm2 is configured to start automatically on system boot using
#   systemd for the ff_agent user. The function first verifies that systemd is
#   present and running as PID 1, skipping the setup if systemd is unavailable
#   (e.g., inside containers or minimal environments).
#
#   If systemd is detected, it configures the pm2 startup service for the
#   ff_agent user using the appropriate command and enables the corresponding
#   systemd unit (`pm2-${USER}`).
#
# DEPENDENCIES
#   - state_set
#   - abort
#   - command_exists
#   - systemd (must be PID 1)
#   - pm2
#
# USAGE EXAMPLE
#   ff_agent_register_pm2_systemd
#
# EXIT STATUS
#   If systemd is not detected, sets state to 'systemd_not_detected' and exits with 0.
#   On failure to configure or enable pm2 systemd startup, sets state and aborts.
#   Returns 0 on successful registration and enablement of pm2 startup under systemd.
#
################################################################################
function ff_agent_register_pm2_systemd {
  state_set "${FUNCNAME[0]}" 'started'

  # Check if we are running inside docker (have systemd)
  command_exists systemctl &>/dev/null || {
    state_set "${FUNCNAME[0]}" 'systemd_not_detected'
    return 0                     # systemctl not installed
  }

  [[ "$(ps -p 1 -o comm= 2>/dev/null)" == "systemd" ]] || {
    state_set "${FUNCNAME[0]}" 'systemd_not_detected'
    return 0        # PID 1 must be systemd
  }

  # Ensuring pm2 startup works on boot for ${FF_AGENT_USERNAME}
  sudo env PATH="${PATH}":"${FF_AGENT_HOME}/.n/bin" pm2 startup systemd -u "${FF_AGENT_USERNAME}" --hp "${FF_AGENT_USER_HOME}" || {
    state_set "${FUNCNAME[0]}" 'terminal_error_unable_to_ff_agent_register_pm2_systemd'
    abort "${FUNCNAME[0]}" "Failed to ensure pm2 startup works on boot for ${FF_AGENT_USERNAME}"
  }

  # Enable systemd unit
  sudo systemctl enable "pm2-${FF_AGENT_USERNAME}" || {
    state_set "${FUNCNAME[0]}" 'terminal_error_unable_to_ff_agent_register_pm2_systemd'
    abort "${FUNCNAME[0]}" "Failed to ensure pm2 startup works on boot for ${FF_AGENT_USERNAME}"
  }

  state_set "${FUNCNAME[0]}" 'success'
}
export -f ff_agent_register_pm2_systemd

################################################################################
# CATEGORY
#   AGENT CONTROL FUNCTIONS
#
# NAME
#   ff_agent_run_pm2 - Start the ff_agent process using pm2 if not already running.
#
# SYNOPSIS
#   ff_agent_run_pm2
#
# DESCRIPTION
#   Ensures that the ff_agent binary is available in the PATH, then registers and
#   starts it via pm2 using the correct user context. The function checks whether
#   ff_agent is already managed by pm2 and skips the start step if it is. After
#   starting, it verifies that ff_agent is actually running under pm2.
#
# DEPENDENCIES
#   - command_exists
#   - state_set
#   - command_run_as_user
#   - pm2
#
# USAGE EXAMPLE
#   ff_agent_run_pm2
#
# EXIT STATUS
#   Sets state and exits via `abort` on any critical error.
#   Otherwise returns 0 on success.
#
################################################################################
function ff_agent_run_pm2 {
  state_set "${FUNCNAME[0]}" 'started'

  # Check dependencies
  local DEPENDENCIES=(
    "command_run_as_user"
    "ff_agent"
    "jq"
    "pm2"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  # Define required non-empty variables
  local REQUIRED_NON_EMPTY_VARIABLES=(
    "FF_AGENT_USERNAME"
  )
  ensure_variables_not_empty "${FUNCNAME[0]}" "${REQUIRED_NON_EMPTY_VARIABLES[@]}" || { # Note: ensure_variables_not_empty will report missing variables
    state_set "${FUNCNAME[0]}" 'ensure_variables_not_empty_failed'
    return 1
  }

  # Try to get status of ff_agent from pm2 using JSON
  local PM2_STATUS
  PM2_STATUS=$(pm2 jlist | jq -r '.[] | select(.name=="ff_agent") | .pm2_env.status')

  if [[ -z "${PM2_STATUS}" ]]; then
    log "${FUNCNAME[0]}" "[INFO] ff_agent is not registered in pm2. Starting it..."
    # We need to start it as ff_agent.sh because pm2 does not start things with shebangs and we want this to be run in a login shell.
    command_run_as_user "${FF_AGENT_USERNAME}" 'pm2 start node --name ff_agent -- ff_agent.sh' || {
    state_set "${FUNCNAME[0]}" 'failed_to_start_ff_agent'
    abort "${FUNCNAME[0]}" 'failed_to_start_ff_agent'
    }
  fi

  if [[ "${PM2_STATUS}" != "online" ]]; then
    log "${FUNCNAME[0]}" "[INFO] ff_agent is registered but not running (status=${PM2_STATUS}). Restarting it..."
    command_run_as_user "${FF_AGENT_USERNAME}" 'pm2 restart ff_agent' || {
      state_set "${FUNCNAME[0]}" 'failed_to_restart_ff_agent'
      abort "${FUNCNAME[0]}" 'failed_to_restart_ff_agent'
    }
  else
    log "${FUNCNAME[0]}" "[INFO] ff_agent is already running under pm2."
  fi

  # Save current pm2 process list - this must run as the correct user
  command_run_as_user "${FF_AGENT_USERNAME}" 'pm2 save' || {
    state_set "${FUNCNAME[0]}" 'failed_to_pm2_save'
    abort "${FUNCNAME[0]}" 'failed_to_pm2_save'
  }

  # Double-check that ff_agent status (must be "online" now)
  PM2_STATUS=$(pm2 jlist | jq -r '.[] | select(.name=="ff_agent") | .pm2_env.status')
  if [ "${PM2_STATUS}" != "online" ]; then
    state_set "${FUNCNAME[0]}" 'ff_agent_not_running_after_start'
    abort "${FUNCNAME[0]}" 'ff_agent_not_running_after_start'
  fi

  state_set "${FUNCNAME[0]}" 'success'
}
export -f ff_agent_run_pm2

################################################################################
# CATEGORY
#   AGENT CONTROL FUNCTIONS
#
# NAME
#   ff_agent_update_install - Generate an update script for ff_agent that reinstalls and restarts it via pm2.
#
# SYNOPSIS
#   ff_agent_update_install
#
# DESCRIPTION
#   Ensures that the ff_agent binary is available in the PATH, then generates a
#   reusable update script (`ff_agent_update`) under the ${FF_AGENT_HOME}/bin directory.
#   This script, when executed, performs the following actions:
#
#     - Verifies environment integrity using set_environment_is_working.
#     - Installs a specific version of @ff/ff_agent globally using npm.
#     - Outputs the version of the installed package.
#     - Flushes the pm2 logs.
#     - Restarts all processes managed by pm2 with updated environment variables.
#
#   The generated script includes error handling and state setting for each step.
#   After the script is created, this function ensures it is marked as executable.
#
# DEPENDENCIES
#   - command_exists
#   - state_set
#   - abort
#   - set_environment_is_working (runtime in generated script)
#   - npm
#   - pm2
#   - chmod
#   - bash (must support here-docs)
#
# USAGE EXAMPLE
#   ff_agent_update_install
#
# EXIT STATUS
#   Sets state and aborts if ff_agent is not found in PATH.
#   Sets state and returns non-zero on failure to create or chmod the script.
#   Returns 0 on successful script generation and setup.
#
################################################################################
function ff_agent_update_install {
  state_set "${FUNCNAME[0]}" 'started'

  # Check dependencies
  local DEPENDENCIES=(
    "ff_agent"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  # Define required non-empty variables
  local REQUIRED_NON_EMPTY_VARIABLES=(
    "FF_AGENT_HOME"
  )
  ensure_variables_not_empty "${FUNCNAME[0]}" "${REQUIRED_NON_EMPTY_VARIABLES[@]}" || { # Note: ensure_variables_not_empty will report missing variables
    state_set "${FUNCNAME[0]}" 'ensure_variables_not_empty_failed'
    return 1
  }

  # Create "ff_agent_update" script
  TARGET_FILE="${FF_AGENT_HOME}/bin/ff_agent_update"

  # Create ff_agent_update file
  (
      cat <<EOT
#!/usr/bin/bash --login

# This script will update @ff/ff_agent@latest and restart it (using pm2).
# The script ${TARGET_FILE} was created by set_environment ${FUNCNAME[0]}() on $(date --utc).

state_set "ff_agent_update" 'started'

# Check set_environment is working
set_environment_is_working || {
  # Mpte" we can not use state_set / abort here.
  echo "ff_agent_update" "set_environment_is_working() failed." 1>&2
  exit 1
}

# Install @ff/ff_agent@latest
npm install --global @ff/ff_agent@${VERSION} || {
  state_set "ff_agent_update" "npm_install_ff_agent_failed"
  abort "ff_agent_update" "Failed to npm install @ff/ff_agent@${VERSION}"
}

# Show installed @ff/ff_agent@latest version
local FF_AGENT_VERSION
FF_AGENT_VERSION=\$( cat \${FF_AGENT_HOME}/.n/lib/node_modules/@ff/ff_agent/package.json | grep '"version"' )
log "Checking installed @ff/ff_agent@latest version: '\${FF_AGENT_VERSION}'"

# Flush pm2
pm2 flush ff_agent || {
  state_set "ff_agent_update" "pm2_flush_failed"
  abort "ff_agent_update" "Failed to pm2 flush"
}

# Restart pm2
pm2 restart ff_agent --update-env || {
  state_set "ff_agent_update" "pm2_restart_all_failed"
  abort "ff_agent_update" "Failed to pm2 restart all"
}

state_set "ff_agent_update" 'success'
EOT
  ) > "${TARGET_FILE}" || { state_set "${FUNCNAME[0]}" "failed_to_create_file"; return 1; }

  # Make executable
  chmod a+x "${TARGET_FILE}" || { state_set "${FUNCNAME[0]}" "failed_to_chmod_file"; return 1; }

  state_set "${FUNCNAME[0]}" 'success'
}
export -f ff_agent_update_install

################################################################################
#
# Function installs "authbind" to allow binries to open ports <=1024
function install_authbind {
  state_set "${FUNCNAME[0]}" 'started'

  # Check dependencies
  local DEPENDENCIES=(
    "apt_install"
    "chmod"
    "chown"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  apt_install authbind  || { state_set "${FUNCNAME[0]}" 'failed_to_install_authbind'; return 1; }

  # Create authbind configuration for ports 80 and 443
  sudo touch /etc/authbind/byport/80  || { state_set "${FUNCNAME[0]}" 'failed_to_create_authbind_byport_80'; return 1; }
  sudo touch /etc/authbind/byport/443 || { state_set "${FUNCNAME[0]}" 'failed_to_create_authbind_byport_443'; return 1; }
  sudo chmod 500 /etc/authbind/byport/80 || { state_set "${FUNCNAME[0]}" 'failed_to_set_permission_authbind_byport_80'; return 1; }
  sudo chmod 500 /etc/authbind/byport/443 || { state_set "${FUNCNAME[0]}" 'failed_to_set_permission_authbind_byport_443'; return 1; }
  sudo chown root:root /etc/authbind/byport/80 || { state_set "${FUNCNAME[0]}" 'failed_to_set_ownership_authbind_byport_80'; return 1; }
  sudo chown root:root /etc/authbind/byport/443 || { state_set "${FUNCNAME[0]}" 'failed_to_set_ownership_authbind_byport_443'; return 1; }

  # To run a program or symlink with the permission to authbind --deep $PATH_TO_EXECUTABLE
  # PATH_TO_EXECUTABLE can be a symlink
  state_set "${FUNCNAME[0]}" 'success'
}
export -f install_authbind

################################################################################
#
# Function installs "build_tools" project.
function install_build_tools {
  state_set "${FUNCNAME[0]}" 'started'

  # Check dependencies
  local DEPENDENCIES=(
    "git"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  GIT_URL="git@github.com:redwolfsecurity/build_tools.git"

  cd /tmp                 || { state_set "${FUNCNAME[0]}" 'failed_to_change_directory_to_temporary_folder'; return 1; }
  rm -fr /tmp/build_tools || { state_set "${FUNCNAME[0]}" 'failed_to_cleanup_old_project_temporary_folder'; return 1; }
  git clone "${GIT_URL}"  || { state_set "${FUNCNAME[0]}" 'failed_to_git_clone_project'; return 1; }
  cd build_tools          || { state_set "${FUNCNAME[0]}" 'failed_to_change_directory_to_project_folder'; return 1; }
  ./install               || { state_set "${FUNCNAME[0]}" 'failed_to_install'; return 1; }

  state_set "${FUNCNAME[0]}" 'success'
}
export -f install_build_tools


################################################################################
#
# Installations of "n" based on the tutorial:
#  "Getting started with n (node version management)"
#   https://zacharytodd.com/posts/n-version-manager/
#
#
# Require environment variables set:
#   - FF_AGENT_HOME
#
# Official n github page:
#   https://github.com/tj/n
#   https://github.com/tj/n#installation
#
function install_n {
  state_set "${FUNCNAME[0]}" "start"

  # Check dependencies
  local DEPENDENCIES=(
    "curl"
    "inject_into_file"
    "popd"
    "printenv"
    "pushd"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  # Define required non-empty variables
  local REQUIRED_NON_EMPTY_VARIABLES=(
    "FF_AGENT_HOME"
  )
  ensure_variables_not_empty "${FUNCNAME[0]}" "${REQUIRED_NON_EMPTY_VARIABLES[@]}" || { # Note: ensure_variables_not_empty will report missing variables
    state_set "${FUNCNAME[0]}" 'ensure_variables_not_empty_failed'
    return 1
  }

  # Define path to ff_agent .profile
  local FF_AGENT_PROFILE_FILE="${FF_AGENT_HOME}/.profile"    # example: /home/ubuntu/ff_agent/.profile  (Note: FF_AGENT_PROFILE_FILE is not local, but shell environment used in other install functions)

  # Check custom .profile file exists
  if [ ! -f "${FF_AGENT_PROFILE_FILE}" ]; then
    # Let's not try to re-create it if missing.
    # It should have been created by existing ff_agent_install_bashrc()
  	state_set "${FUNCNAME[0]}" "error_custom_ff_agent_profile_does_not_exist"
    return 1
  fi

    # -----------------------------------------------------------------------------
  # Create and enter a temporary working directory
  # -----------------------------------------------------------------------------
  TMPDIR="$(mktemp -d)" || { state_set "${FUNCNAME[0]}" 'failed_to_create_tmpdir'; return 1; }
  pushd "${TMPDIR}" > /dev/null || { state_set "${FUNCNAME[0]}" 'error_pushd_to_tmp_directory'; return 1; }

  # -----------------------------------------------------------------------------
  # Download 'n' binary using a prioritized fallback strategy
  # -----------------------------------------------------------------------------
  SAVE_AS='n'
  DOWNLOAD_LOCATIONS=(
    "${FF_CONTENT_URL}/ff/ff_agent/hotpatch/hotpatch_files/${SAVE_AS}"
    "https://raw.githubusercontent.com/tj/n/master/bin/n"
  )

    DOWNLOAD_SUCCESS=0
  for URL in "${DOWNLOAD_LOCATIONS[@]}"; do
    if curl \
      --silent \
      --location \
      --retry 5 \
      --retry-delay 1 \
      --retry-max-time 60 \
      --max-time 55 \
      --connect-timeout 12 \
      -o "${SAVE_AS}" \
      "${URL}"; then
      DOWNLOAD_SUCCESS=1
      break
    else
      state_set "${FUNCNAME[0]}" "download_failed_from_$(basename "${URL}")"
    fi
  done


  if [ "${DOWNLOAD_SUCCESS}" -ne 1 ]; then
    popd > /dev/null || { state_set "${FUNCNAME[0]}" 'error_popd'; return 1; }
    rm -rf "${TMPDIR}" || { state_set "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }
    state_set "${FUNCNAME[0]}" 'error_all_download_attempts_failed'
    return 1
  fi

  # Export 2 env variables we need for "n" to operate properly:  and NODE_PATH

  # ------------------ Export N_PREFIX and inject that export into FF_AGENT_PROFILE_FILE (begin) ----------------
  export N_PREFIX="${FF_AGENT_HOME}/.n"  # example: /home/ubuntu/ff_agent/.n

  # Add '# Export N_PREFIX' into the custom .profile file if in was not injected earlier.
  TARGET_FILE="${FF_AGENT_PROFILE_FILE}"
  PATTERN="^export N_PREFIX=\"${FF_AGENT_HOME}/.n\""
  EXPECTED_LINE="export N_PREFIX=\"${FF_AGENT_HOME}/.n\""
  INJECT_CONTENT=$(
  cat <<EOT
# N_PREFIX environment injected by set_environment ${FUNCNAME[0]} on $(date --utc)
${EXPECTED_LINE}
EOT
  )
  ERROR_CODE='error_injecting_export_n_prefix_to_ff_agent_profile'

  # Do injection and check result
  inject_into_file  \
    "${TARGET_FILE}" \
    "${PATTERN}" \
    "${INJECT_CONTENT}" || {
      # Error: clean up tmp folder, report an error and return error code 1
      popd || { state_set "${FUNCNAME[0]}" 'error_popd'; return 1; }
      rm -fr "${TMPDIR}" || { state_set "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }
      state_set "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
  }

  # ------------------ Export N_PREFIX and inject that export into FF_AGENT_PROFILE_FILE (begin) ----------------


  # ------------------ Export NODE_PATH and inject that export into FF_AGENT_PROFILE_FILE (begin) ----------------
  # We set NODE_PATH, so npm can load modules. Details: https://stackoverflow.com/questions/12594541/npm-global-install-cannot-find-module
  export NODE_PATH="${FF_AGENT_HOME}/.n/lib/node_modules"

  # Add '# Export NODE_PATH' into the custom .profile file if in was not injected earlier.
  TARGET_FILE="${FF_AGENT_PROFILE_FILE}"
  PATTERN="^export NODE_PATH=\"${FF_AGENT_HOME}/.n/lib/node_modules\""
  EXPECTED_LINE="export NODE_PATH=\"${FF_AGENT_HOME}/.n/lib/node_modules\""
  INJECT_CONTENT=$(
  cat <<EOT
# Injected by set_environment ${FUNCNAME[0]} on $(date --utc)
${EXPECTED_LINE}
EOT
  )
  ERROR_CODE='error_injecting_export_node_path_to_ff_agent_profile'

  # Do injection and check result
  inject_into_file  \
    "${TARGET_FILE}" \
    "${PATTERN}" \
    "${INJECT_CONTENT}" || {
      # Error: clean up tmp folder, report an error and return error code 1
      popd || { state_set "${FUNCNAME[0]}" 'error_popd'; return 1; }
      rm -fr "${TMPDIR}" || { state_set "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }
      state_set "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
  }
  # ------------------ Export NODE_PATH and inject that export into FF_AGENT_PROFILE_FILE (end) ----------------


  # ------------------ Inject "ff_agent/.n/bin" into PATH and inject that export into FF_AGENT_PROFILE_FILE (begin) ----------------

  # -----------------------------------------------------------------------------
  # Update PATH variable if it does not yet contain the expected N_PREFIX/bin
  # -----------------------------------------------------------------------------
  if ! grep --quiet "${N_PREFIX}/bin" <<< "${PATH}"; then
    export PATH="${N_PREFIX}/bin:${PATH}" || {
      popd > /dev/null || { state_set "${FUNCNAME[0]}" 'error_popd'; return 1; }
      rm -rf "${TMPDIR}" || { state_set "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }
      state_set "${FUNCNAME[0]}" 'error_modifying_path'; return 1
    }
  fi

  # Note: we escape "\$" in front of the PATH, so it does not get expanded
  TARGET_FILE="${FF_AGENT_PROFILE_FILE}"
  PATTERN="^export PATH=\"${N_PREFIX}/bin:\${PATH}\""
  EXPECTED_LINE="export PATH=\"${N_PREFIX}/bin:\${PATH}\""
  if ! file_contains_pattern "${TARGET_FILE}" "${PATTERN}"; then
    # Expected line is missing, Inject text
    (
      cat <<EOT
# Injected by set_environment ${FUNCNAME[0]} on $(date --utc)
${EXPECTED_LINE}
EOT
    ) >> "${TARGET_FILE}" || {
        # Error: clean up tmp folder, report an error and return error code 1
        popd || { state_set "${FUNCNAME[0]}" 'error_popd'; return 1; }; rm -fr "${TMPDIR}"  || { state_set "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }
        state_set "${FUNCNAME[0]}" 'error_injecting_n_prefix_bin_to_ff_agent_profile'; return 1;
    }
  fi
  # ------------------ Inject "ff_agent/.n/bin" into PATH and inject that export into FF_AGENT_PROFILE_FILE (end) ----------------

  #
  VERSION=$( nodejs_desired_version_get )
  [ -z "${VERSION}" ] && { state_set "${FUNCNAME[0]}" 'failed_to_nodejs_desired_version_get'; abort 'failed_to_nodejs_desired_version_get'; }

  # Install 'n_lts' using dowloaded into TMPDIR 'n' ('n_lts' will be installed into ff_agent/.n)
  retry_command 5 15 bash n "${VERSION}" || {
    # Error: clean up tmp folder, report an error and return error code 1
    popd || { state_set "${FUNCNAME[0]}" 'error_popd'; return 1; }; rm -fr "${TMPDIR}"  || { state_set "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }
    state_set "${FUNCNAME[0]}" 'error_installing_n'; return 1;
  }

  # Install 'n' into ff_agent/.n  (yes, we have downloaded 'n' into TMPDIR,
  # then used it to install 'npm', and now we use 'npm' to install "globally" n.
  # The proper installed 'n' will reisde under ff_agent/.n/ folder)
  npm install --verbose --global n || {
    # Error: clean up tmp folder, report an error and return error code 1
    popd || { state_set "${FUNCNAME[0]}" 'error_popd'; return 1; }; rm -fr "${TMPDIR}"  || { state_set "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }
    state_set "${FUNCNAME[0]}" 'error_installing_n'; return 1;
  }

  # Clean up tmp folder
  popd || { state_set "${FUNCNAME[0]}" 'error_popd'; return 1; }; rm -fr "${TMPDIR}"  || { state_set "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }

  # Chage state and return success
  state_set "${FUNCNAME[0]}" 'success'
}
export -f install_n

################################################################################
#
function install_nodejs {
  state_set "${FUNCNAME[0]}" 'started'

 # Check dependencies
  local DEPENDENCIES=(
    "install_n"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  # Get desired nodejs version
  local VERSION
  VERSION="$( nodejs_desired_version_get )"
  [ -z "${VERSION}" ] && { state_set "${FUNCNAME[0]}" 'failed_to_nodejs_desired_version_get'; abort 'failed_to_nodejs_desired_version_get'; }


  # # We need to stop pm2 before replacing location of nodejs, otherwise any pm2 command would faild
  # stop_pm2
  # uninstall_n_outside_ff_agent_home  || { state_set "${FUNCNAME[0]}" 'terminal_error_uninstall_n_outside_ff_agent_home'; abort 'terminal_error_uninstall_n_outside_ff_agent_home'; }
  install_n || { state_set "${FUNCNAME[0]}" 'terminal_error_install_n'; abort 'terminal_error_install_n'; }
  n install "${VERSION}" || { state_set "${FUNCNAME[0]}" 'terminal_error_switching_node_version'; abort 'terminal_error_switching_node_version'; }

  state_set "${FUNCNAME[0]}" 'success'
}
export -f install_nodejs

################################################################################
#
# Install nodejs latest environment
function install_nodejs_suite {
  state_set "${FUNCNAME[0]}" 'started'

 # Check dependencies
  local DEPENDENCIES=(
    "install_authbind"
    "install_nodejs"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  # We want nodejs to be able to open ports 443 and 80, so we will install_authbind before this.

  install_authbind || { state_set "${FUNCNAME[0]}" 'install_authbind_failed'; abort 'install_authbind_failed'; }

  install_nodejs || { state_set "${FUNCNAME[0]}" 'terminal_error_install_node'; abort 'terminal_error_install_node'; }

  state_set "${FUNCNAME[0]}" 'success'
}
export -f install_nodejs_suite


# ##########################################################################################
# #
# # The following function defines the list of packages required to run "puppeteer" as a part
# # of unit tests on our porjects.
# # See the official "Puppeteer: Troubleshooting" page:
# # https://github.com/puppeteer/puppeteer/blob/main/docs/troubleshooting.md
# #
# ##########################################################################################
# function apt_install_puppeteer_dependencies {
#   local REQUIRED_PACKAGES=(
#     ca-certificates
#     fonts-liberation
#     libappindicator3-1
#     libasound2
#     libatk-bridge2.0-0
#     libatk1.0-0
#     libc6
#     libcairo2
#     libcups2
#     libdbus-1-3
#     libexpat1
#     libfontconfig1
#     libgbm1
#     libgcc1
#     libglib2.0-0
#     libgtk-3-0
#     libnspr4
#     libnss3
#     libpango-1.0-0
#     libpangocairo-1.0-0
#     libstdc++6
#     libx11-6
#     libx11-xcb1
#     libxcb1
#     libxcomposite1
#     libxcursor1
#     libxdamage1
#     libxext6
#     libxfixes3
#     libxi6
#     libxrandr2
#     libxrender1
#     libxss1
#     libxtst6
#     lsb-release
#     wget
#     xdg-utils
#   )
# }


# ###############################################################################
# #
# # install_ntp disables timesyncd and installs ntp if missing
# #
# # The systemd-timesyncd is basically a small client-only NTP implementation more or less bundled with newer systemd releases.
# # It's more lightweight than a full ntpd but only supports time sync - i.e. it can't act as an NTP server for other machines.
# # We should not use both in parallel, as in theory they could pick different timeservers that have a slight delay between them,
# # leading to your system clock being periodically "jumpy".
# #
# # Comparing the ntp and systemd-timesyncd I found out that ntpd is much better solution:
# # systemd-timesyncd does no clock discipline: the clock is not trained or compensated, and internal clock drift over time is not reduced.
# # It has rudimentary logic to adjust poll interval but without disciplining the host will end up with uneven time forever as
# # systemd-timesyncd pushes or pulls at whatever interval it thinks the near-term drift requires. It also can't assess the
# # quality of the remote time source. You're unlikely to get accuracy much greater than 100ms. This is sufficient for simple
# # end user devices like laptops, but it could definitely cause problems for distributed systems that want greater time precision.
# # (source article: https://unix.stackexchange.com/questions/305643/ntpd-vs-systemd-timesyncd-how-to-achieve-reliable-ntp-syncing/464729#464729 )
# #
# # So install_ntp() disables "systemd-timesyncd" and leaves only "ntpd".
# #
# # Return value: 0 = success, 1 = failure
# #
# # Note: f-n also uses state_set()
# #
# function replace_timesyncd_with_ntpd {
#     state_set "${FUNCNAME[0]}" 'started'

#     # Check if timesyncd is active (disable if active)
#     IS_TIMESYNCD_ACTIVE=$( systemctl status systemd-timesyncd.service | grep -i active | awk '{print $2}' )  # returns 'active' or 'inactive'

#     # Have to commend out the "if" statement below. Here's the reason why:
#     #   Noted IBM agents, where "timedatectl status" still reports non-ntpd time syncing is in place: "Network time on: yes"
#     #   BUT AT THE SAME TIME the "systemctl status systemd-timesyncd.service" output shows "Active: inactive (dead)"
#     #   and only after we run "sudo timedatectl set-ntp no" the output of "timedatectl status" will be finally expected: "Network time on: no"
#     #
#     #if [ "${IS_TIMESYNCD_ACTIVE}" == "active" ]; then

#         # timesyncd is active, need to deactivate it:
#         sudo timedatectl set-ntp no

#         # make sure timedatectl is not not active
#         IS_TIMESYNCD_ACTIVE=$( systemctl status systemd-timesyncd.service | grep -i active | awk '{print $2}' )  # returns 'active' or 'inactive'
#         if [ "${IS_TIMESYNCD_ACTIVE}" == "active" ]; then
#             # Still active! Error out
#             state_set "${FUNCNAME[0]}" 'failed_stop_timesyncd'
#             return 1
#         fi

#     #fi

#     # Check if ntpd is insatalled (install if missing)
#     IS_NTP_INSTALLED=$( dpkg --get-selections ntp | grep -v deinstall | grep install | awk '{print $2}' )  # returns 'install' if is installed or emptry string if not
#     if [ "${IS_NTP_INSTALLED}" != "install" ]; then
#         # ntp is not installed, install it
#         apt_install ntp

#         # Check if ntp is now installed
#         IS_NTP_INSTALLED=$( dpkg --get-selections ntp | grep -v deinstall | grep install | awk '{print $2}' )  # returns 'install' if is installed or emptry string if not
#         if [ "${IS_NTP_INSTALLED}" != "install" ]; then
#             # Still not isntalled! Error out
#             state_set "${FUNCNAME[0]}" 'failed_to_install_ntp'
#             return 1
#         fi
#     fi

#     # Enble NTP (this will make it to autostart on reboot)
#     sudo systemctl enable ntp
#     if [ ${?} -ne 0 ]; then
#         state_set "${FUNCNAME[0]}" 'failed_to_enable_ntp'
#     fi

#     # Start NTP (note: it is safe to try to start in case it is already running - this might happen if ntp was not installed and was just added 1st time by apt)
#     sudo systemctl start ntp
#     if [ ${?} -ne 0 ]; then
#         state_set "${FUNCNAME[0]}" 'failed_to_start_ntp'
#     fi

#     # Last status check: query local ntpd
#     LOCAL_NTP_QUERY_STATUS=$( ntpq -pn )
#     LOCAL_NTP_QUERY_STATUS_EXIT_CODE=${?}

#     if [ ${LOCAL_NTP_QUERY_STATUS_EXIT_CODE} -ne 0 ]; then
#         state_set "${FUNCNAME[0]}" 'failed_to_query_ntp'
#         return 1
#     fi

#     state_set "${FUNCNAME[0]}" 'success'
#     return 0
# }

################################################################################
# Category: process
# pm2_configure_container
# Configures pm2 the way we want it configured for a container
# No .pm2/logs/* files -- Letting Docker/systemd/journald handle log routing
# Clean stdout/stderr separation
# Disable PM2 update banner
# Clean and readable timestamp format in log lines (stdout/stderr)
# Extend kill timeout for graceful shutdowns
# Set default memory cap for auto-restart
# Disable all file-based logging (PM2 won't write .pm2/logs/*)
function pm2_configure_container {
  state_set "${FUNCNAME[0]}" 'started'

  # Check dependencies
  local DEPENDENCIES=(
    "timeout"
    "pm2"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  # Disable PM2 update banner
  timeout 30 pm2 set pm2:update_notif false || {
    state_set "${FUNCNAME[0]}" 'pm2_set_update_notif_error'
    return 1
  }

  # Clean and readable timestamp format in log lines (stdout/stderr)
  timeout 30 pm2 set pm2:log_date_format 'YYYY-MM-DD HH:mm:ss' || {
    state_set "${FUNCNAME[0]}" 'pm2_set_log_date_format_error'
    return 1
  }

  # Extend kill timeout for graceful shutdowns
  timeout 30 pm2 set pm2:kill_timeout 5000 || {
    state_set "${FUNCNAME[0]}" 'pm2_set_kill_timeout_error'
    return 1
  }

  # Set default memory cap for auto-restart
  timeout 30 pm2 set pm2:max_memory_restart 500M || {
    state_set "${FUNCNAME[0]}" 'pm2_set_max_memory_restart_error'
    return 1
  }

  # Disable all file-based logging (PM2 won't write .pm2/logs/*)
  timeout 30 pm2 set pm2:out_file /dev/null || {
    state_set "${FUNCNAME[0]}" 'pm2_set_out_file_error'
    return 1
  }

  timeout 30 pm2 set pm2:error_file /dev/null || {
    state_set "${FUNCNAME[0]}" 'pm2_set_error_file_error'
    return 1
  }

  timeout 30 pm2 save || {
    state_set "${FUNCNAME[0]}" 'pm2_save_failed'
    return 1
  }

  state_set "${FUNCNAME[0]}" 'success'
}
export -f pm2_configure_container

################################################################################
# Category: process
# pm2_configure_host
# Configures pm2 the way we want it configured for a host
function pm2_configure_host {
    state_set "${FUNCNAME[0]}" 'started'

    # Define dependencies
    local DEPENDENCIES=(
      "timeout"
      "pm2"
    )
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
      state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
      return 1
    }
    # Automatically call pm2 save after every process start/stop/restart so that the current process list is persisted to disk.
    timeout 30 pm2 set pm2:autodump true            || { state_set "${FUNCNAME[0]}" "pm2_configure_autodump_error"; return 1; }

    # Disables PM2's periodic check for new versions (and annoying update banners in the CLI).
    timeout 30 pm2 set pm2:update_notif false

    # Customizes the timestamp format for PM2 log output.
    timeout 30 pm2 set pm2:log_date_format 'YYYY-MM-DD HH:mm:ss'

    # Time (in milliseconds) PM2 waits between sending SIGINT or SIGTERM and force-killing (SIGKILL) a process on stop/restart.
    timeout 30 pm2 set pm2:kill_timeout 5000

    # Sets the default maximum memory (in megabytes) any process is allowed to use before PM2 forcefully restarts it.
    # Can be overridden on a per-process basis. But applies to all apps if not set per app.
    pm2 set pm2:max_memory_restart 500M

    # Configure it to rotate logs
    timeout 45 pm2 install pm2-logrotate            || { state_set "${FUNCNAME[0]}" "pm2_install_logrotate_error"; return 1; }
    timeout 30 pm2 set pm2-logrotate:max_size 20M   || { state_set "${FUNCNAME[0]}" "pm2_configure_logrotate_error"; return 1; }
    timeout 30 pm2 set pm2-logrotate:retain 7       || { state_set "${FUNCNAME[0]}" "pm2_configure_logrotate_error"; return 1; }
    timeout 30 pm2 set pm2-logrotate:compress true  || { state_set "${FUNCNAME[0]}" "pm2_configure_logrotate_error"; return 1; }

    # configure it to rotate logs every hour
    timeout 30 pm2 set pm2-logrotate:rotateInterval '0 0 * * * *'  || { state_set "${FUNCNAME[0]}" "pm2_configure_logrotate_error"; return 1; }

  timeout 30 pm2 save || {
    state_set "${FUNCNAME[0]}" 'pm2_save_failed'
    return 1
  }
    state_set "${FUNCNAME[0]}" 'success'
}
export -f pm2_configure_host

################################################################################
# Category: process
# pm2_install
# Will install pm2 if there is no command 'pm2'
# Will not start it
function pm2_install {
    state_set "${FUNCNAME[0]}" 'started'

    # Define dependencies
    local DEPENDENCIES=(
      "command_exists"
      "npm"
    )
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
      state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
      return 1
    }

    local NPM_PACKAGE="pm2"
    local VERSION="latest"

    local PM2
    PM2=$( command_exists "${NPM_PACKAGE}" )
    [ "${PM2}" != "" ] && { state_set "${FUNCNAME[0]}" 'success_no_action_already_installed'; return 0; }

    # Actually install it -- globally
    local NPM
    NPM=$( command_exists "npm" )
    ${NPM} install --global "${NPM_PACKAGE}@${VERSION}"  || { state_set "${FUNCNAME[0]}" 'error_installing_pm2_npm'; return 1; }

    # Verify it is installed and it is working
    pm2_is_installed_and_working || { state_set "${FUNCNAME[0]}" 'error_installing_pm2_command_not_found'; return 1; }

    state_set "${FUNCNAME[0]}" 'success'
}
export -f pm2_install

################################################################################
# Category: process
# pm2_is_installed_and_working
# Checks if pm2 is installed
# Returns 0 if it is, 1 if it isn't
function pm2_is_installed_and_working {
  # Check dependencies
  local DEPENDENCIES=(
    "command_exists"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || return 1  # Note: check_dependencies will report missing dependencies

  # Return 1 if command does not exist
  command_exists pm2 >/dev/null || { return 1; }

  # Check if pm2 works
  pm2 ping >/dev/null || { return 1; }

}
export -f pm2_is_installed_and_working

################################################################################
# Category: process
# pm2_is_running_as_me
# Will return 0 if it is, 1 if it is not
function pm2_is_running_as_me {
    state_set "${FUNCNAME[0]}" 'started'

    # Define dependencies
    local DEPENDENCIES=(
      "process_is_running_as_me"
    )
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
      state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
      return 1
    }

    # Process will look like PM2 v4.5.5: God Daemon (/home/user/.pm2)
    local PATTERN="PM2 .*: God Daemon"

    # Check if process is running as local user.
    process_is_running_as_me "${PATTERN}"
    local STATUS=${?}

    if [ ${STATUS} -ne 0 ]; then
        state_set "${FUNCNAME[0]}" 'error_pm2_not_running_as_user'
        echo "DEBUG PM2======================================================"
        echo "id: $( id )"
        echo "pwd: $( pwd )"
        echo "USER: $( whoami )"
        echo "HOME: ${HOME}"
        echo "sudo ps aux"
        sudo ps aux
        echo "PM2 log:"
        cat ~/.pm2/pm2.log
        echo "pm2 ping"
        pm2 ping || echo "pm2 ping failed"
        return ${STATUS}
    fi
    state_set "${FUNCNAME[0]}" 'success'
}
export -f pm2_is_running_as_me

################################################################################
# Category: process
# pm2_start
function pm2_start {
    state_set "${FUNCNAME[0]}" 'started'

    # Define dependencies
    local DEPENDENCIES=(
      "command_exists"
      "pm2"
      "pm2_is_installed_and_working"
    )
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
      state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
      return 1
    }

    # Get the path to the pm2 command
    local PM2
    PM2=$( command_exists pm2 ) || { state_set "${FUNCNAME[0]}" 'error_pm2_command_not_found'; return 1; }

    # Check if it is running. If it is, we're happy.
    pm2_is_installed_and_working && { state_set "${FUNCNAME[0]}" 'success_no_action_pm2_is_already_running'; return 0; }

    # We want to install pm2 in home directory, so we need to make sure we are in the right place.
    pushd "${HOME}" || { state_set "${FUNCNAME[0]}" 'error_pushd'; return 1; }

    # Try and start pm2, and then save the state.
    "${PM2}" start || {
        state_set "${FUNCNAME[0]}" 'error_pm2_start_failed'
        error "Error - PM2 did not start. pm2 log last 1000 lines are:"
        tail -n 1000 "${HOME}/.pm2/pm2.log"
        error "Here are the last 1000 lines of pm2 log:"
        pm2 logs --lines 1000
        return 1
    }

    "${PM2}" save || {
        state_set "${FUNCNAME[0]}" 'error_pm2_save_failed'
        return 1
    }

    popd || { state_set "${FUNCNAME[0]}" 'error_popd'; return 1; }

    state_set "${FUNCNAME[0]}" 'success'
}
export -f pm2_start


################################################################################
# Category: process
# pm2_stop stops the running pm2 daemon running as the current user.
# does not stop any root level or other user pm2 daemons.
#
function pm2_stop {
  state_set "${FUNCNAME[0]}" 'started'

  local DEPENDENCIES=(
    "command_exists"
    "pm2_is_running_as_me"
    "state_set"
    "sleep"
    "timeout"
    "jq"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  local PM2
  PM2="$(command_exists pm2)" || {
    state_set "${FUNCNAME[0]}" 'error_pm2_command_not_found'
    return 1
  }

  # If PM2 is not running, no-op gracefully
  if ! pm2_is_running_as_me; then
    log "${FUNCNAME[0]}" "PM2 is not running â€” nothing to stop."
    state_set "${FUNCNAME[0]}" 'noop_pm2_not_running'
    return 0
  fi

  # Get list of managed processes
  local TASK_LIST_JSON
  if ! TASK_LIST_JSON="$("${PM2}" list --json 2>/dev/null)"; then
    state_set "${FUNCNAME[0]}" 'error_pm2_list_failed'
    return 1
  fi

  local TASK_COUNT=0
  local TASK_NAME
  while read -r TASK_NAME; do
    "${PM2}" stop "${TASK_NAME}" > /dev/null 2>&1
    ((TASK_COUNT++))
  done < <(echo "${TASK_LIST_JSON}" | jq -r '.[].name // empty')

  log "${FUNCNAME[0]}" "Requested stop for ${TASK_COUNT} PM2 process(es)."

  # Wait for processes to exit
  local STOP_WAIT_TIMEOUT_S=10
  local STOP_WAIT_INTERVAL_S=0.5
  local ELAPSED_S=0

  while "${PM2}" list --json | jq 'map(select(.pm2_env.status != "stopped")) | length > 0' | grep -q true; do
    sleep "${STOP_WAIT_INTERVAL_S}"
    ELAPSED_S=$(awk "BEGIN {print ${ELAPSED_S}+${STOP_WAIT_INTERVAL_S}}")
    if (( $(echo "${ELAPSED_S} >= ${STOP_WAIT_TIMEOUT_S}" | bc -l) )); then
      state_set "${FUNCNAME[0]}" 'warning_some_processes_did_not_stop_in_time'
      break
    fi
  done

  if ! timeout 10s "${PM2}" kill > /dev/null 2>&1; then
    state_set "${FUNCNAME[0]}" 'error_pm2_kill_timeout_or_failed'
    return 1
  fi

  sleep 1

  if pm2_is_running_as_me; then
    state_set "${FUNCNAME[0]}" 'error_pm2_still_running_after_graceful_shutdown'
    return 1
  fi

  state_set "${FUNCNAME[0]}" 'success'
}
export -f pm2_stop

################################################################################
# Category: process
# pm2_update
# Updates pm2 to the latest version
function pm2_update {
    state_set "${FUNCNAME[0]}" 'started'

    # Define dependencies
    local DEPENDENCIES=(
      "command_exists"
      "pm2"
      "timeout"
      "seq"
    )
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
      state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
      return 1
    }

    # Get the path to the pm2 command
    local PM2
    PM2=$( command_exists pm2 ) || { state_set "${FUNCNAME[0]}" 'error_pm2_command_not_found'; return 1; }

    # Check if it is running. If it is, we're happy.
    pm2_is_installed_and_working && { state_set "${FUNCNAME[0]}" 'success_no_action_pm2_is_already_running'; return 0; }
  # pm2 update performs a self-healing and state-preserving refresh of the PM2 runtime and ecosystem.
    # It does not update the pm2 NPM package itself â€” instead, it resets internal state, reloads the process list, and upgrades the underlying PM2 metadata if needed.
    # pm2 update sometimes fail on 1st attempt, but then works on the 2nd. Let's add 3 attempts to make sure.
    local IS_PM2_UPDATED=false
    local MAX_ATTEMPTS=3
    local ATTEMPT
    for ATTEMPT in $(seq 1 "${MAX_ATTEMPTS}"); do
      log "Attempt ${ATTEMPT}/${MAX_ATTEMPTS}: updating PM2..."
      if timeout 55 pm2 update; then
        IS_PM2_UPDATED=true
        break
      else
        warn "Attempt ${ATTEMPT} failed to update PM2."
      fi
    done

    [ "${IS_PM2_UPDATED}" == "true" ] || { state_set "${FUNCNAME[0]}" "pm2_update_error"; return 1; } # "Error: failed to update pm2 after ${ATTEMPT} attempts"

    state_set "${FUNCNAME[0]}" 'success'
}
export -f pm2_update

################################################################################
# Category: process
# pm2_uninstall
# Removes PM2 if it is globally installed via npm
function pm2_uninstall {
  state_set "${FUNCNAME[0]}" 'started'

  # Define dependencies
  local DEPENDENCIES=(
    "command_exists"
    "state_set"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  local PACKAGE="pm2"
  local NPM
  NPM="$(command_exists npm)"

  if [[ -z "${NPM}" ]]; then
    state_set "${FUNCNAME[0]}" 'error_dependency_not_met_npm'
    return 1
  fi

  # Check if pm2 is globally installed via npm
  local NPM_LIST_OUT
  if ! NPM_LIST_OUT="$("${NPM}" list --global --depth=0 --json 2>/dev/null)"; then
    state_set "${FUNCNAME[0]}" 'error_npm_list_failed'
    return 1
  fi

  local IS_INSTALLED
  IS_INSTALLED="$(echo "${NPM_LIST_OUT}" | jq -e --arg pkg "${PACKAGE}" '.dependencies[$pkg] // empty' > /dev/null && echo yes || echo no)"

  if [[ "${IS_INSTALLED}" != "yes" ]]; then
    state_set "${FUNCNAME[0]}" 'success_no_action_not_installed'
    return 0
  fi

  # Try to uninstall it
  if ! "${NPM}" remove --global "${PACKAGE}" > /dev/null 2>&1; then
    state_set "${FUNCNAME[0]}" 'error_uninstalling_package'
    return 1
  fi

  # Recheck to confirm removal
  if "${NPM}" list --global --depth=0 --json 2>/dev/null | jq -e --arg pkg "${PACKAGE}" '.dependencies[$pkg]' > /dev/null; then
    state_set "${FUNCNAME[0]}" 'error_validating_uninstallation'
    return 1
  fi

  state_set "${FUNCNAME[0]}" 'success'
}
export -f pm2_uninstall


################################################################################
#
# Function makes sure the symlink "set_environment_install" exists in the ${FF_AGENT_HOME}/bin/ folder.
# If symlink is missing it will be created:
#    ${FF_AGENT_HOME}/bin/set_environment_install -> ${FF_AGENT_HOME}/git/redwolfsecurity/set_environment/install
# The installed command "set_environment_install" can also be run to update set_environment.
#
function set_environment_ensure_install_exists {

  state_set "${FUNCNAME[0]}" 'started'

 # Check dependencies
  local DEPENDENCIES=(
    "ln"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  # Define required non-empty variables
  local REQUIRED_NON_EMPTY_VARIABLES=(
    "FF_AGENT_HOME"
  )
  ensure_variables_not_empty "${FUNCNAME[0]}" "${REQUIRED_NON_EMPTY_VARIABLES[@]}" || { # Note: ensure_variables_not_empty will report missing variables
    state_set "${FUNCNAME[0]}" 'ensure_variables_not_empty_failed'
    return 1
  }

  # Define symlink
  SYMLINK="${FF_AGENT_HOME}/bin/set_environment_install"

  # Define target file (which new symlink must point to)
  TARGET_FILE="${FF_AGENT_HOME}/git/redwolfsecurity/set_environment/install"

  # Check symlink exists. Note: -L returns true if the "file" exists and is a symbolic link (the linked file may or may not exist).
  [ -L "${SYMLINK}" ] || {
      # SYMLINK is missing. Try to create new symlink.
      ln -s "${TARGET_FILE}" "${SYMLINK}" || { state_set "${FUNCNAME[0]}" 'failed_to_create_symlink'; return 1; }
  }

  # Check the target file is present (symlink is not broken)
  [ -f "${TARGET_FILE}" ] || { state_set "${FUNCNAME[0]}" 'error_target_file_missing'; return 1; }

  # Check the target file is executable. Note: extra "-f" check added here since "-x" can say "yes, executable", but target points to directory.
  [[ -f "${TARGET_FILE}" && -x "${TARGET_FILE}" ]] || { state_set "${FUNCNAME[0]}" 'error_target_file_not_executable'; return 1; }

  state_set "${FUNCNAME[0]}" 'success'
}
export -f set_environment_ensure_install_exists

################################################################################
#
# Function set_environment_preserve_source_code require the only argument: root folder of the project
# from which the installer was started. It will analyze if the installer was started
# from the expected place (ff_agent/git/[companyname]/set_environment/ folder) and if not
# it will preserve source code into appropriate folder for future use (updates etc.).
#
function set_environment_preserve_source_code {
  state_set "${FUNCNAME[0]}" 'started'

 # Check dependencies
  local DEPENDENCIES=(
    "github_repository_url_parse"
    "grep"
    "mkdir"
    "popd"
    "pushd"
    "ssh-keyscan"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {  # Note: check_dependencies will report missing dependencies
    state_set "${FUNCNAME[0]}" 'dependencies_check_failed'
    return 1
  }

  # Define required non-empty variables
  local REQUIRED_NON_EMPTY_VARIABLES=(
    "FF_AGENT_HOME"
  )
  ensure_variables_not_empty "${FUNCNAME[0]}" "${REQUIRED_NON_EMPTY_VARIABLES[@]}" || { # Note: ensure_variables_not_empty will report missing variables
    state_set "${FUNCNAME[0]}" 'ensure_variables_not_empty_failed'
    return 1
  }

  # Before installer change directory multiple times let's preserve absolute path to the project's root
  # directory, so we can preserve soruces as one of the last steps after installation.
  [ -n "${SET_ENVIRONMENT_SCRIPT_DIRECTORY}" ] || { state_set "${FUNCNAME[0]}" "terminal_error_variable_set_environment_script_directory_not_set"; abort 'The environment variable SET_ENVIRONMENT_SCRIPT_DIRECTORY is unset and is required for set_environment_preserve_source_code'; }

  # As a preparation to preserve project source files (used during this installation), let's change directory to the project root directory.
  pushd "${SET_ENVIRONMENT_SCRIPT_DIRECTORY}" || { state_set "${FUNCNAME[0]}" 'failed_to_cd_into_project'; return 1; }

  # We need to trust github.com to avoid errors like this:
  # The authenticity of host 'github.com (140.82.113.4)' can't be established.
  mkdir -p "${FF_AGENT_USER_HOME}/.ssh" || { state_set "${FUNCNAME[0]}" 'failed_to_create_ff_agent_user_home_ssh_folder'; return 1; }
  if ! grep -q '^github\.com ' "${FF_AGENT_USER_HOME}/.ssh/known_hosts"; then
      ssh-keyscan github.com >> "${FF_AGENT_USER_HOME}/.ssh/known_hosts"
  fi

  # Extract project owner from github repository URL
  local URL
  URL="$(git remote get-url origin 2>/dev/null)" || { state_set ...; return 1; }
  [ -n "${URL}" ] || { state_set "${FUNCNAME[0]}" 'failed_to_extract_project_url'; return 1; }

  local OWNER
  OWNER=$( github_repository_url_parse "${URL}" --owner )
  [ -n "${OWNER}" ] || { state_set "${FUNCNAME[0]}" 'failed_to_extract_project_owner'; return 1; }

  # All projects sources got preserved in this folder
  local PRESERVED_PROJECTS_DIR="${FF_AGENT_HOME}/git"

  # Define current project-specific name and preserved project-specific directory
  local PROJECT_NAME='set_environment'
  local PRESERVED_PROJECT_DIR="${PRESERVED_PROJECTS_DIR}/${OWNER}/${PROJECT_NAME}"

  # Make sure the project-specific folder exists
  if [ ! -d "${PRESERVED_PROJECT_DIR}" ]; then
    # Does not exist, try to create it
    mkdir -p "${PRESERVED_PROJECT_DIR}" || { state_set "${FUNCNAME[0]}" 'failed_to_create_folder_for_code_preservation'; return 1; }
  fi

  # Check PWD is set or try to use $(pwd) or error out
  if [ -z "${PWD}" ]; then
    # PWD is not set, try to set it by "pwd" call
    PWD="$( pwd )" || { state_set "${FUNCNAME[0]}" 'failed_to_get_pwd'; return 1; }
  fi

  # Check if installer running from unexpected folder
  # TODO: check if folder from which we're running installation contains spaces (e.g.: "/tmp/some folder with spaces/" )
  if [ "${PWD}" != "${PRESERVED_PROJECT_DIR}" ]; then
      # Current installer run from unexpected place (like some temporary folder) - need to preserve installed project source folder.
      # Check if previously preserved folder exists, then remove its content before copying files
      # (we don't want the preserved folder to be a mix/merge with old deleted files).
      if [ -d "${PRESERVED_PROJECT_DIR}" ]; then
          # Remove old project source folder content (leaving the folder itself)
          # Note: we don't rm -fr some/path/* since this would miss hidden files. The 'find' gets them all!
          find "${PRESERVED_PROJECT_DIR}" -mindepth 1 -delete || { state_set "${FUNCNAME[0]}" 'failed_to_remove_old_project_source_folder'; return 1; }
      fi

      # Copy newly installed source folder (to preserve it)
      # Note: the "/." is here to copy all files including hidden (which starts with dot). Just '*' would not work.
      cp -a "${PWD}/." "${PRESERVED_PROJECT_DIR}" || { state_set "${FUNCNAME[0]}" 'failed_to_preserve_source_folder'; return 1; }
  fi

  # Restore the original folder
  popd || { state_set "${FUNCNAME[0]}" 'failed_to_popd_after_preserving_source_folder'; return 1; }

  state_set "${FUNCNAME[0]}" 'success'
}
export -f set_environment_preserve_source_code

################################################################################
# Log this script standard output and standard error to a log file AND system logger
function logging_script_set_deprecated {

  # Note: we can not yet call "state_set" on that early stages
 	#state_set "${FUNCNAME[0]}" 'started'

  # Let's find a good directory for logs. This assumes zero knowledge.
  # The _best_ place for these logs would be in "${HOME}/ff_agent/logs" -- if we can write to it we'll create it
  POTENTIAL_LOG_DIRECTORIES=( "${FF_AGENT_HOME}/logs" /var/log/ff_agent /tmp/ff_agent/logs /tmp/ff_agent.$$/logs )

  LOG_DIRECTORY=""

  # Find a directory we can write to. The first will do.
  for POTENTIAL_LOG_DIRECTORY in "${POTENTIAL_LOG_DIRECTORIES[@]}"
  do
      if mkdir -p "${POTENTIAL_LOG_DIRECTORY}"
      then
          LOG_DIRECTORY=${POTENTIAL_LOG_DIRECTORY}
          break
      fi
  done

  if [ -z "${LOG_DIRECTORY}" ]; then
      error "Unable to find a place to log! Tried: ${POTENTIAL_LOG_DIRECTORIES[*]}"
      LOG_PATH=$( tty )
      export LOG_PATH
  else
      # Get current epoch ms. (note: we can't yet use   # "$( epoch_ms_get )" because ff_bash_functions arent installed/updated yet)
      TIMESTAMP_EPOCH_MS="$( epoch_ms_get )"
      LOG_FILE="set_environment.${TIMESTAMP_EPOCH_MS}.log"
      LOG_PATH="${LOG_DIRECTORY}/${LOG_FILE}"
      export LOG_PATH
      # PREVIOUSLY THIS WAS exec &> >(tee -a "${LOG_PATH}")
      exec &> >(tee >(tee -a "${LOG_PATH}" | logger -t set_environment ))
  fi

  # Note: we can not yet call "state_set" on that early stages
 	#state_set "${FUNCNAME[0]}" 'success'
}
export -f logging_script_set_deprecated


