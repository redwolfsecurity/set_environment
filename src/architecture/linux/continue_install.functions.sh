#!/bin/bash -

#
# This script is a part of "set_environment" installer and should not be called directry.
# It got sourced from src/architecture/linux/continue_install.sh
#

# Table of contents generated by function file_toc():
#
#    - add_to_install_if_missing 
#    - apt_install_basic_packages 
#    - assert_baseline_components 
#    - assert_core_credentials 
#    - background_install 
#    - check_if_need_background_install 
#    - service_is_running
#    - set_environment_ensure_ff_agent_bin_exists 
#    - set_environment_ensure_install_exists 
#    - install_build_tools 
#    - install_ff_agent 
#    - install_ff_agent_bashrc 
#    - install_go 
#    - install_n 
#    - install_nodejs 
#    - install_nodejs_suite 
#    - install_set_environment_baseline 
#    - pm2_is_installed 
#    - pm2_is_running_as_me 
#    - pm2_configure 
#    - pm2_ensure 
#    - pm2_install 
#    - pm2_start 
#    - pm2_stop 
#    - pm2_uninstall 
#    - set_environment_preserve_source_code 
#    - set_script_logging 
#    - setup_logging 

###############################################################################
#
# Return information if package is installed in system, dpkg depend
# @param ${1} string package name
# @param ${2} array package list to append
#
# Return code value:
#  0 - Success
#      Note: disregard of package is already installed or not, the success
#            for function "add_to_install_if_missing" means we checked and added
#            (if it was missing) and didn't face any errors.
#
#  1 - on error (e.g.: bad arguments)
#
# Usage: add_to_install_if_missing "vim" PACKAGES
#
function add_to_install_if_missing {

  # Check inputs: ${1} - must be not empty string (package name to check)
  if [ "${1}" == "" ]; then
    error "${FUNCNAME[0]} bad arguments: package name is not specified (no arguments)"
    return 1
  fi

  # Take argument ${1} - package name
  local PACKAGE="${1}"

  # Take argument ${2} - reference to array
	declare -n PACKAGES_TO_INSTALL=${2}

  # Check inputs: ${2} - must be a reference to an array
  if [ "${PACKAGES_TO_INSTALL@a}" != "a" ]; then
    # Error: passed reference does not point to array
    error "${FUNCNAME[0]} bad arguments: 2nd argument must be reference to array"
    return 1
  fi

	# Grep exit code 0=installed, 1=not installed.
	# Note we use grep to cover case "Status: deinstall ok config-files" when package was uninstalled.
	dpkg --status ${PACKAGE} 2>/dev/null | grep --silent "installed"
	INSTALLED=${?}

  # Check exit code
	if [ ${INSTALLED} != 0 ]; then
    # Not installed. Add package name into the list.
		PACKAGES_TO_INSTALL+=(${PACKAGE})
	fi

  # Return success
	return 0
}
export -f add_to_install_if_missing

###############################################################################
#
# Install basic packages
#
function apt_install_basic_packages {

  set_state "${FUNCNAME[0]}" 'started'

  # Update apt index and installed components, before installing additional packages.
  assert_clean_exit apt_update
  assert_clean_exit apt_upgrade

  # Define list of all required packages (by category, comment why we need the package for non-obvious ones)
  local REQUIRED_PACKAGES=(
      apt-utils # apt-utils required to avoid error: debconf: delaying package configuration, since apt-utils is not installed
      apt-transport-https # APT transport for downloading via the HTTP Secure protocol (HTTPS)
      software-properties-common # Part of "apt": manage the repositories that you install software from 3rd party repos (i.e. add their repo + gpg key)
      
      # The GNU Core Utilities are the basic file, shell and text manipulation utilities of the GNU operating system.
      # These are the core utilities which are expected to exist on every operating system.
      coreutils

      # Curl must exist for this script and many others
      curl

      # The ff_bash_functions require jq
      jq

      # This script requires grep
      grep

      # Docker requires these
      gnupg2
      lsb-release

      # System: CA certificates
      ca-certificates # Common CA certificates - Docker requires

      # For generate_strong_password (which uuencode is part of)
      sharutils
  )
  local MISSING_PACKAGES=()

  # Iterate required packages and collect only missing ones
  for REQUIRED_PACKAGE in "${REQUIRED_PACKAGES[@]}"; do
    add_to_install_if_missing ${REQUIRED_PACKAGE} MISSING_PACKAGES
  done

  # Install only missing packages
  apt_install ${MISSING_PACKAGES[@]} || { set_state "${FUNCNAME[0]}" 'error_failed_apt_install'; return 1; }

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f apt_install_basic_packages

###############################################################################
#
# Install set of basic packages (most installed by "apt", but some installed by
# different means (example: docker, n, npm, nodejs)), bash functions, .bashrc and .profile files.
#
function assert_baseline_components {
  set_state "${FUNCNAME[0]}" 'started'

  # Install basic packages before installing anything else. This will install "curl", thus "set_state" will be able to POST JSON.
  assert_clean_exit apt_install_basic_packages

  # Install NTP and make sure timesyncd is disabled (not working in parallel)
  # assert_clean_exit replace_timesyncd_with_ntpd

  # Install docker (not using "apt") - COMMENTED OUT: docker is not part of baseline (it is part of "build" and/or "development", but not "baseline")
  #assert_clean_exit docker_install

  # Ensure file "ff_agent/.profile" created and sourced from ~/.bashrc (Note: this must be done before install node)
  assert_clean_exit install_ff_agent_bashrc

  # Install nodejs suite and all its fixings (not using "apt") (Note: this will modify ff_agent/.profile)
  assert_clean_exit install_nodejs_suite

  # Install pm2
  assert_clean_exit pm2_ensure

  # Install npm package "@ff/ff_agent" -> ff_agent/
  assert_clean_exit install_ff_agent

  set_state "${FUNCNAME[0]}" 'success'
}
export -f assert_baseline_components

###############################################################################
#
# Assert core credentials (npmrc, docker, ...)
#
function assert_core_credentials {
    set_state "${FUNCNAME[0]}" 'started'

    # [Q] We should be part of docker group. That's about it I think.
    # [A] Nope, we don't install docker as a 'baseline' environment, thus assection of core credentials will
    #     only take care of user being part of the 'docker group' in case corresponding environment was installed.

    set_state "${FUNCNAME[0]}" 'success'
}
export -f assert_core_credentials

###############################################################################
#
# background_install: run installer again under different user.
#
# Background install involves:
#   - Writing a copy of the set_environment into temporary location and changing permissions to the target user.
#   - Running that script as correct target user.
#
function background_install {

  # Take the only argument: target username to "run as"
  USER_TO_RUN_AS="${1}"

  # Check argument is not empty string
  [ "${USER_TO_RUN_AS}" != "" ] || { error "background_install error: missing argument"; abort; }

  # Get current user. Note: the ${USER} environment is NOT set when running as 'root' in docker, we must use f-n get_current_user() instead.
  CURRENT_USER="$(get_current_user)" || { error "Can not get current user"; return 1; }

  # Check if target user can sudo
  can_sudo "${USER_TO_RUN_AS}" || { error "background_install needs to sudo to user ${USER_TO_RUN_AS} but user ${CURRENT_USER} does not have sudo privileges"; abort; }

  # Create temporary folder
  TEMP_DIR=$( mktemp -d ) || { error "background_install tried to create directory ${TEMP_DIR}."; abort; }

  # Check if folder created
  [ -d "${TEMP_DIR}" ] || { error "background_install tried to create directory ${TEMP_DIR}."; abort; }

  # Copy set_environment project into the target temporary folder
  cp -a ../set_environment "${TEMP_DIR}" || {
    error "background_install failed to copy project to temporary folder '${TEMP_DIR}'"
    # Clean-up: remove temp directory we've just created
    rm -fr "${TEMP_DIR}"
    abort
  }

  # Change ownership of the temporary folder to the target user
  chown -R "${FF_AGENT_USERNAME}:$(id -gn ${FF_AGENT_USERNAME})" "${TEMP_DIR}" || {
    error "background_install error: missing argument";
    # Clean-up: remove temp directory we've just created
    rm -fr "${TEMP_DIR}"
    abort;
  }

  # Pass control to the newly created set_environment copy (run by the target user) and exit
  sudo --set-home --user="${USER_TO_RUN_AS}" bash -c "${TEMP_DIR}/set_environment/install.sh"

  # Clean-up: remove temp directory we've just created
  rm -fr "${TEMP_DIR}"
}
export -f background_install

###############################################################################
#
# Function analyzes currently selected user and might call "background_install()" to
# re-run the installer under a different user.
#
# We may need, for various reasons, to launch a background install.
#
# Return value:
#    - function prints "true" to standard output only if we need to background_install as "${FF_AGENT_USERNAME}"
#    - function returns/prints nothing if no need to background install
#    - on error function aborts (no need to errorcheck by the caller)
#
#
# Dependency:
#   FF_AGENT_USERNAME - must be set
#
function check_if_need_background_install {

  # Define required variables
  local REQUIRED_VARIABLES=(
    FF_AGENT_USERNAME
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      local ERROR_CODE="$( echo "failed_to_ensure_variable_not_empty_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # It might already exist, but not be writable due to chmod changes
  if [ -f "${FF_AGENT_HOME}" ] && [ ! -w "${FF_AGENT_HOME}" ]; then
      error "FF_AGENT_HOME at ${FF_AGENT_HOME} is not writable by user $( whoami ). Aborting."
      abort
  fi

  DO_BACKGROUND_INSTALL=false

  # Get current user. Note: the ${USER} environment is NOT set when running as 'root' in docker, we must use f-n get_current_user() instead.
  CURRENT_USER="$(get_current_user)" || { error "Can not get current user"; return 1; }

  # Suppose I'm not the best user, but I can sudo to become the best! e.g. If I am root - I'm not the best user.
  if [ "${CURRENT_USER}" != "${FF_AGENT_USERNAME}" ]; then
      if can_sudo "${CURRENT_USER}"; then
          DO_BACKGROUND_INSTALL=true
      fi
  fi

  # Am I effectively root?
  if [ "${EUID}" -eq 0 ]; then
      DO_BACKGROUND_INSTALL=true
  fi

  if [ "${DO_BACKGROUND_INSTALL}" == "true" ]; then
    echo "true"
    ## background_install "${FF_AGENT_USERNAME}"
    ## We can not exit, since "set_environment" installer is sourced: ". ./install.sh"
    ##exit 0
  fi

  # Otherwise we continue happily through this instance of the script. No need to change user.
  # i.e. I am not root, and I have sudo priveleges.
}
export -f check_if_need_background_install

###############################################################################
#
# Function checks if service by given name is running (return code 0 = yes, 
# other code = no).
# Usage example:
#   if service_is_running docker; then echo yes; else echo no; fi
#   yes
#
function service_is_running {
  local SERVICE_NAME="$1"
  # Check inputs (must be non-empty string)
  [ ! -z "${SERVICE_NAME}" ] || { set_state "${FUNCNAME[0]}" 'error_empty_argument'; return 1; }
  systemctl is-active --quiet docker
}
export -f service_is_running

###############################################################################
#
# Function makes sure "${FF_AGENT_HOME}/bin" folder is created.
#
function set_environment_ensure_ff_agent_bin_exists {

  set_state "${FUNCNAME[0]}" 'started'

  # Dependency check: 'tr' is installed
  if ! command_exists tr >/dev/null; then
    set_state "${FUNCNAME[0]}" 'error_dependency_not_met_tr'
    return 1
  fi

  # Define required variables
  local REQUIRED_VARIABLES=(
    FF_AGENT_HOME
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      local ERROR_CODE="$( echo "failed_to_ensure_variable_not_empty_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Define target directory
  TARGET_DIR="${FF_AGENT_HOME}/bin"

  # Check if target directory exists
  [ -d "${TARGET_DIR}" ] || {
    # Does not exist. Create new.
    mkdir "${TARGET_DIR}" || { set_state "${FUNCNAME[0]}" 'failed_to_create_directory'; return 1; }
  }

  set_state "${FUNCNAME[0]}" 'success'
}
export -f set_environment_ensure_ff_agent_bin_exists

###############################################################################
#
# Function makes sure symlink exists (or create new one if missing).
#    ${FF_AGENT_HOME}/bin/set_environment_install -> ${FF_AGENT_HOME}/git/redwolfsecurity/set_environment/install
#
function set_environment_ensure_install_exists {

  set_state "${FUNCNAME[0]}" 'started'

  # Define required variables
  local REQUIRED_VARIABLES=(
    FF_AGENT_HOME
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      local ERROR_CODE="$( echo "failed_to_ensure_variable_not_empty_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Define symlink
  SYMLINK="${FF_AGENT_HOME}/bin/set_environment_install"

  # Define target file (which new symlink must point to)
  TARGET_FILE="${FF_AGENT_HOME}/git/redwolfsecurity/set_environment/install"

  # Check symlink exists. Note: -L returns true if the "file" exists and is a symbolic link (the linked file may or may not exist).
  [ -L "${SYMLINK}" ] || {
      # SYMLINK is missing. Try to create new symlink.
      ln -s "${TARGET_FILE}" "${SYMLINK}" || { set_state "${FUNCNAME[0]}" 'failed_to_create_symlink'; return 1; }
  }

  # Check the target file is present (symlink is not broken)
  [ -f "${TARGET_FILE}" ] || { set_state "${FUNCNAME[0]}" 'error_target_file_missing'; return 1; }

  # Check the target file is executable. Note: extra "-f" check added here since "-x" can say "yes, executable", but target points to directory.
  [[ -f "${TARGET_FILE}" && -x "${TARGET_FILE}" ]] || { set_state "${FUNCNAME[0]}" 'error_target_file_not_executable'; return 1; }

  set_state "${FUNCNAME[0]}" 'success'
}
export -f set_environment_ensure_install_exists

###############################################################################
#
# Function installs "build_tools" project. 
function install_build_tools {
  set_state "${FUNCNAME[0]}" 'started'

  GIT_URL="git@github.com:redwolfsecurity/build_tools.git"

  cd /tmp                 || { set_state "${FUNCNAME[0]}" 'failed_to_change_directory_to_temporary_folder'; return 1; }
  rm -fr /tmp/build_tools || { set_state "${FUNCNAME[0]}" 'failed_to_cleanup_old_project_temporary_folder'; return 1; }
  git clone "${GIT_URL}"  || { set_state "${FUNCNAME[0]}" 'failed_to_git_clone_project'; return 1; }
  cd build_tools          || { set_state "${FUNCNAME[0]}" 'failed_to_change_directory_to_project_folder'; return 1; }
  ./install               || { set_state "${FUNCNAME[0]}" 'failed_to_install'; return 1; }

  set_state "${FUNCNAME[0]}" 'success'
}
export -f install_build_tools

###############################################################################
#
# Install npm package "@ff/ff_agent" -> ff_agent/
#
function install_ff_agent {
  set_state "${FUNCNAME[0]}" 'started'

  # Define the version of ff_agent npm package to install from CDN
  VERSION='latest'

  local ARCHITECTURE=$( get_hardware_architecture ) || { set_state "${FUNCNAME[0]}" "error_getting_hardware_architecture"; return 1; }
  
  # If we are on arm64, we likely need to install some extra packages
  # This is done as a case, just in case we have other such architectural changes for other architectures.
  case "${ARCHITECTURE}" in
    arm64 | amd64)
      PACKAGES_TO_INSTALL=(
        libcurl4-openssl-dev
        build-essential
      )
      apt_install ${PACKAGES_TO_INSTALL[@]} || { set_state "${FUNCNAME[0]}" 'terminal_error_unable_to_install_ff_agent_dependencies'; abort; }
    ;;
    *)
    ;;
  esac

  # Install ff_agent
  npm install --global "${FF_CONTENT_URL}/ff/npm/ff-ff_agent-${VERSION}.tgz" || { set_state "${FUNCNAME[0]}" 'terminal_error_failed_to_install_ff_agent'; abort; }

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f install_ff_agent

###############################################################################
#
# Ensure file "ff_agent/.profile" created and sourced from ~/.bashrc
#
# Require environment variables set:
#   - FF_AGENT_USERNAME
#   - FF_AGENT_HOME
#
function install_ff_agent_bashrc {
  set_state "${FUNCNAME[0]}" 'started'

  # Define required variables
  local REQUIRED_VARIABLES=(
    FF_AGENT_USERNAME
    FF_AGENT_HOME
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      local ERROR_CODE="$( echo "failed_to_ensure_variable_not_empty_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Make sure ${FF_AGENT_HOME} folder exists
  if [ ! -d "${FF_AGENT_HOME}" ]; then
    # ${FF_AGENT_HOME} folder is missing. Don't try to create it (it is responsibility of set_environment_ensure_ff_agent_home_exists()).
    # Report an error and abort.
    set_state "${FUNCNAME[0]}" 'terminal_error_ff_agent_home_folder_does_not_exist'
    error "FF_AGENT_HOME='${FF_AGENT_HOME}' directory Does not exist. Aborting."
    abort
  fi

  # Define location of two profile files
  local HOME_PROFILE_FILE="${HOME}/.profile"
  FF_AGENT_PROFILE_FILE="${FF_AGENT_HOME}/.profile"    # example: /home/ubuntu/ff_agent/.profile  (Note: FF_AGENT_PROFILE_FILE is not local, but shell environment used in other install functions)

  # Define location of .bashrc file
  local HOME_BASHRC_FILE="${HOME}/.bashrc"

  # --------------------------------------------------------------------
  # Inject sourcing ff_agent/.profile into files:
  TARGET_FILES=( "${HOME_BASHRC_FILE}" "${HOME_PROFILE_FILE}" )

  # Iterate target files
  for TARGET_FILE in "${TARGET_FILES[@]}"; do
    # Create TARGET_FILE if missing
    if [ ! -f "${TARGET_FILE}" ]; then
      (
        cat <<EOT
# File ${TARGET_FILE} created by set_environment ${FUNCNAME[0]}() on $(date --utc).
EOT
      ) > "${TARGET_FILE}" || { set_state "${FUNCNAME[0]}" "failed_to_create_file"; return 1; }
    fi

    PATTERN="^source \"${FF_AGENT_PROFILE_FILE}\""
    INJECT_CONTENT=$(
      cat <<EOT
# Sourcing ${FF_AGENT_PROFILE_FILE} injected by set_environment ${FUNCNAME[0]}() on $(date --utc).
source "${FF_AGENT_PROFILE_FILE}"
EOT
    )
    ERROR_CODE='error_injecting_source_custom_profile'

    # Do injection and check result
    inject_into_file "${TARGET_FILE}" "${PATTERN}" "${INJECT_CONTENT}" || { set_state "${FUNCNAME[0]}" "${ERROR_CODE}"; return 1; }
  done
  #
  # --------------------------------------------------------------------

  # --------------------------------------------------------------------
  # Inject sourcing ff_bash_functions

  # Define path to the installed ff_bash_functions
  local FF_BASH_FUNCTIONS_PATH="${FF_AGENT_HOME}/git/redwolfsecurity/set_environment/src/ff_bash_functions"

  # Inject into the custom .profile to source ff_bash_functions (if missing)
  # Search expected line
  TARGET_FILE="${FF_AGENT_PROFILE_FILE}"
  PATTERN="^source \"${FF_BASH_FUNCTIONS_PATH}"
  INJECT_CONTENT=$(
    cat <<EOT
# Sourcing bash functions library from ${FF_BASH_FUNCTIONS_PATH} injected by set_environment ${FUNCNAME[0]}() on $(date --utc).
source "${FF_BASH_FUNCTIONS_PATH}"
EOT
  )
  ERROR_CODE='error_injecting_source_ff_bash_functions'

  # Create TARGET_FILE if missing
  if [ ! -f "${TARGET_FILE}" ]; then
    (
      cat <<EOT
# File ${TARGET_FILE} created by set_environment ${FUNCNAME[0]}() on $(date --utc).
EOT
    ) > "${TARGET_FILE}" || { set_state "${FUNCNAME[0]}" "failed_to_create_file"; return 1; }
  fi

  # Do injection and check result
  inject_into_file "${TARGET_FILE}" "${PATTERN}" "${INJECT_CONTENT}" || { set_state "${FUNCNAME[0]}" "${ERROR_CODE}"; return 1; }
  #
  # --------------------------------------------------------------------

  # --------------------------------------------------------------------
  # Inject call to "discover_environment" into the custom .profile
  TARGET_FILE="${FF_AGENT_PROFILE_FILE}"
  PATTERN="^discover_environment"
  INJECT_CONTENT=$(
      cat <<EOT
discover_environment
EOT
  )
  ERROR_CODE='error_injecting_discover_environment_call_to_custom_profile'

  # Do injection and check result
  inject_into_file "${TARGET_FILE}" "${PATTERN}" "${INJECT_CONTENT}" || { set_state "${FUNCNAME[0]}" "${ERROR_CODE}"; return 1; }
  #
  # --------------------------------------------------------------------

  # --------------------------------------------------------------------
  # Inject ${FF_AGENT_BIN} into PATH in .profile and modify current PATH if needed.

  # Define the path to ff_agent/bin folder, which we will inject into PATH
  local FF_AGENT_BIN="${FF_AGENT_HOME}/bin"

  # Update PATH variable (if it not yet contains expected string)
  printenv PATH | grep --quiet "${FF_AGENT_BIN}"
  if [ ${?} -ne 0 ]; then
    export PATH="${FF_AGENT_BIN}:${PATH}" || { set_state "${FUNCNAME[0]}" 'error_modifying_path'; return 1; }
  fi

  TARGET_FILE="${FF_AGENT_PROFILE_FILE}"
  PATTERN="^export PATH=\"${FF_AGENT_BIN}"
  INJECT_CONTENT=$(
      cat <<EOT
export PATH="${FF_AGENT_BIN}:\${PATH}"
EOT
  )
  ERROR_CODE='error_injecting_ff_agent_bin_path_to_custom_profile'

  # Do injection and check result
  inject_into_file "${TARGET_FILE}" "${PATTERN}" "${INJECT_CONTENT}" || { set_state "${FUNCNAME[0]}" "${ERROR_CODE}"; return 1; }
  #
  # --------------------------------------------------------------------

  # Chage state and return success
  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f install_ff_agent_bashrc

###############################################################################
#
# Function installs "go" by certain version (see below) if it is not already installed.
#
# In case of successful install (or already at expected version) script return success code 0.
# In case of any errors script prints error to standard error stream and exit with code 1.
#
function install_go {
  set_state "${FUNCNAME[0]}" 'started'

  # Define required variables
  local REQUIRED_VARIABLES=(
    FF_AGENT_HOME
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      local ERROR_CODE="$( echo "failed_to_ensure_variable_not_empty_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Get the latest available version number. Note: the url below now returns 2 lines,
  # 1st with version (example: go1.21.0)
  # 2nd useless line that breaks it if not supressed (example: time 2023-08-04T20:14:06Z)
  local URL="https://go.dev/VERSION?m=text"
  local EXPECTED_VERSION=$( get_by_url "${URL}" '-' | head -n1 )
  
  # Check status of 1st command in the excuted bove pipeline
  if [ ${PIPESTATUS[0]} -ne 0 ]; then
    set_state "${FUNCNAME[0]}" 'failed_to_get_latest_version_number'
    return 1
  fi

  [ ! -z "${EXPECTED_VERSION}" ] || { set_state "${FUNCNAME[0]}" 'failed_to_get_latest_version_number'; return 1; }

  # Check if go is already installed and has expected vesrion
  if command_exists go >/dev/null; then
      # Yes, 'go' is installed. Check if installed version matches expected one.
      INSTALLED_VERSION="$( go version )" || { set_state "${FUNCNAME[0]}" 'failed_to_get_existing_version_number'; return 1; }

      # Compare to expected version
      if [[ "${INSTALLED_VERSION}" =~ ${EXPECTED_VERSION} ]]; then
        # Match. Version is up to date, nothing to do.
        set_state "${FUNCNAME[0]}" 'success'
        return 0
      fi
      # Version mismatch, simply continue installation (to upgrade)...
  fi

  # Create temporary folder (for downloading 'go' archive)
  local TEMP_DIR="$( mktemp --directory )" || { set_state "${FUNCNAME[0]}" 'failed_to_create_temp_dir'; return 1; }

  # Check temporary folder created and we can write to it
  if ! is_writable "${TEMP_DIR}"; then
    set_state "${FUNCNAME[0]}" "error_temp_dir_isnt_writable"
    return 1
  fi

  # Get OS
  local OS="$( get_os_name )" || { set_state "${FUNCNAME[0]}" "failed_to_get_os_name"; return 1; }
  [ ! -z "${OS}" ] || { set_state "${FUNCNAME[0]}" "failed_to_get_os_name"; return 1; }

  # Get ARCHITECTURE
  local ARCHITECTURE="$( get_hardware_architecture )" || { set_state "${FUNCNAME[0]}" "failed_to_get_hardware_architecture"; return 1; }
  [ ! -z "${OS}" ] || { set_state "${FUNCNAME[0]}" "failed_to_get_hardware_architecture"; return 1; }

  # Define archive filename
  TARBALL_FILENAME="${EXPECTED_VERSION}.${OS}-${ARCHITECTURE}.tar.gz"

  # Download archive
  URL="https://go.dev/dl/${TARBALL_FILENAME}"
  curl \
    --silent    \
    --retry 5    \
    --location    \
    --retry-delay 1 \
    --retry-max-time 60 \
    --max-time 185 \
    --connect-timeout 12 \
    -o "${TEMP_DIR}/${TARBALL_FILENAME}" \
    "${URL}" || { set_state "${FUNCNAME[0]}" "failed_to_download_archive"; return 1; }

  # Check if file downloaded (in case of "404 not found" curl return code 0 and will not create "-o file")
  [ -f "${TEMP_DIR}/${TARBALL_FILENAME}" ] || { set_state "${FUNCNAME[0]}" "failed_to_download_archive"; return 1; }

  # Remove previous local version of 'go' if exists
  # 1st "blind assumption" to remove go from expected place
  if [ -d "${FF_AGENT_HOME}/go" ]; then
    rm -fr "${FF_AGENT_HOME}/go" || { set_state "${FUNCNAME[0]}" "failed_to_remove_existing_go"; return 1; }
  fi
  # 2nd remove "go" if it is in the path
  if command_exists go >/dev/null; then
      # Yes, 'go' is installed.
      local EXISTING_GO_FILEPATH=$(command_exists go)
      sudo rm "${EXISTING_GO_FILEPATH}"
  fi
  # Also noted other locations! Must improve "remove go" functionality to cleanup these as well:
  # /usr/bin/go -> ../lib/go-1.13/bin/go
  # /usr/lib/go -> go-1.13/

  # Install 'go'

  # Unzip downloaded archive (the "bin" folder of the golang will be available here: ${FF_AGENT_HOME}/go/bin/ )
  tar -C "${FF_AGENT_HOME}" -xzf "${TEMP_DIR}/${TARBALL_FILENAME}" || { set_state "${FUNCNAME[0]}" "failed_to_extract_archive"; return 1; }

  # Remove temporary folder
  rm -fr "${TEMP_DIR}" || { error "Warning: failed to remove temporary folder: '${TEMP_DIR}'"; }

  # Define the path to ff_agent profile file (we need to add a path to 'go' into ff_agent/.profile if missing)
  TARGET_FILE="${FF_AGENT_HOME}/.profile"

  # Create TARGET_FILE if does not exist and add a comment (who/when creaeted it)
  if [ ! -f "${TARGET_FILE}" ]; then
    (
      cat <<EOT
# File ${TARGET_FILE} created by set_environment ${FUNCNAME[0]}() on $( date --utc ).
EOT
    ) > "${TARGET_FILE}" || { set_state "${FUNCNAME[0]}" "failed_to_create_file"; return 1; }
  fi

  # Check if expected line was already injected into the profile.
  # Note: it is not too specific, it is exactly the line that must be present in the ff_agent custom profille file.
  PATTERN="^export PATH=\${PATH}:${FF_AGENT_HOME}/go/bin"
  INJECT_CONTENT=$(
    cat <<EOT
# The path to 'go' inserted by $( pwd )/$( basename ${0} ) on $( date --utc )'
export PATH=\${PATH}:${FF_AGENT_HOME}/go/bin
EOT
  )
  ERROR_CODE='error_injecting_source_custom_profile'

  # Inject and check result code
  inject_into_file  \
    "${TARGET_FILE}" \
    "${PATTERN}" \
    "${INJECT_CONTENT}" || { set_state "${FUNCNAME[0]}" "${ERROR_CODE}"; return 1; }

  # Also inject path to 'go' into current PATH (if missing in PATH)
  # do the export, so we don't have to relogin in order to call "go version"
  echo ${PATH} | grep -q ${FF_AGENT_HOME}/go/bin
  if [ ${?} -ne 0 ]; then
    # Path to 'go' is missing from PATH environment variable. Inject it:
    export PATH=${PATH}:${FF_AGENT_HOME}/go/bin
  fi

  # Check installed 'go' version
  INSTALLED_VERSION="$( go version )" || { set_state "${FUNCNAME[0]}" 'failed_to_get_installed_version_number'; return 1; }

  # Compare to the expected version
  if [[ "${INSTALLED_VERSION}" =~ ${EXPECTED_VERSION} ]]; then
    # Good - expected version installed.
    set_state "${FUNCNAME[0]}" 'success'
    return 0
  else
    # Mismatch.
    set_state "${FUNCNAME[0]}" 'failed_to_match_expected_vs_installed_version'
    return 1
  fi
}
export -f install_go

###############################################################################
#
# Installations of "n" based on the tutorial:
#  "Getting started with n (node version management)"
#   https://zacharytodd.com/posts/n-version-manager/
#
#
# Require environment variables set:
#   - FF_AGENT_HOME
#
# Official n github page:
#   https://github.com/tj/n
#   https://github.com/tj/n#installation
#
function install_n {
  set_state "${FUNCNAME[0]}" "start"

  # Define required variables
  local REQUIRED_VARIABLES=(
    FF_AGENT_HOME
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      local ERROR_CODE="$( echo "failed_to_ensure_variable_not_empty_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Define path to ff_agent .profile
  FF_AGENT_PROFILE_FILE="${FF_AGENT_HOME}/.profile"    # example: /home/ubuntu/ff_agent/.profile  (Note: FF_AGENT_PROFILE_FILE is not local, but shell environment used in other install functions)

  # Check custom .profile file exists
  if [ ! -f "${FF_AGENT_PROFILE_FILE}" ]; then
    # Let's not try to re-create it if missing.
    # It should have been created by existing install_ff_agent_bashrc()
  	set_state "${FUNCNAME[0]}" "error_custom_ff_agent_profile_does_not_exist"
    return 1
  fi

  # Create tmp folder and change directory into it
  TMPDIR="$( mktemp -d )"
  pushd "${TMPDIR}" || { set_state "${FUNCNAME[0]}" 'error_pushd_to_tmp_directory'; return 1; }

  # Attempt 1: download 'n' from FF_CONTENT_URL
  # Try FF_CONTENT_URL first because it gives more control over what version of 'n' will be executed.
  # The magour update on the github might introduce some breaking change, let's leave it for 2nd attept only.
  SAVE_AS='n'
  URL="${FF_CONTENT_URL}/ff/ff_agent/hotpatch/hotpatch_files/${SAVE_AS}"
  curl \
    --silent    \
    --retry 5    \
    --location    \
    --retry-delay 1 \
    --retry-max-time 60 \
    --max-time 55 \
    --connect-timeout 12 \
    -o "${SAVE_AS}" \
    "${URL}"

  # Check curl exit code
  if [ ${?} -ne 0 ]; then
      set_state "${FUNCNAME[0]}" 'failed_to_download_n_from_content_server'

      # Attempt 2: download 'n' from from github
      URL="https://raw.githubusercontent.com/tj/n/master/bin/n"
      curl \
        --silent    \
        --retry 5    \
        --location    \
        --retry-delay 1 \
        --retry-max-time 60 \
        --max-time 55 \
        --connect-timeout 12 \
        -o "${SAVE_AS}" \
        "${URL}"

      # Check curl exit code
      if [ ${?} -ne 0 ]; then
        # The 2nd attempt failed too, giving up.
        # Error: clean up tmp folder, report an error and return error code 1
        popd || { set_state "${FUNCNAME[0]}" 'error_popd'; return 1; }
        rm -fr "${TMPDIR}" || { set_state "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }
        set_state "${FUNCNAME[0]}" 'warning_failed_to_download_n_from_github'
        return 1
      fi
  fi

  # Export 2 env variables we need for "n" to operate properly:  and NODE_PATH

  # ------------------ Export N_PREFIX and inject that export into FF_AGENT_PROFILE_FILE (begin) ----------------
  export N_PREFIX="${FF_AGENT_HOME}/.n"  # example: /home/ubuntu/ff_agent/.n

  # Add '# Export N_PREFIX' into the custom .profile file if in was not injected earlier.
  TARGET_FILE="${FF_AGENT_PROFILE_FILE}"
  PATTERN="^export N_PREFIX=\"${FF_AGENT_HOME}/.n\""
  EXPECTED_LINE="export N_PREFIX=\"${FF_AGENT_HOME}/.n\""
  INJECT_CONTENT=$(
  cat <<EOT
# N_PREFIX environment injected by set_environment ${FUNCNAME[0]} on $(date --utc)
${EXPECTED_LINE}
EOT
  )
  ERROR_CODE='error_injecting_export_n_prefix_to_ff_agent_profile'

  # Do injection and check result
  inject_into_file  \
    "${TARGET_FILE}" \
    "${PATTERN}" \
    "${INJECT_CONTENT}" || {
      # Error: clean up tmp folder, report an error and return error code 1
      popd || { set_state "${FUNCNAME[0]}" 'error_popd'; return 1; }
      rm -fr "${TMPDIR}" || { set_state "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
  }

  # ------------------ Export N_PREFIX and inject that export into FF_AGENT_PROFILE_FILE (begin) ----------------


  # ------------------ Export NODE_PATH and inject that export into FF_AGENT_PROFILE_FILE (begin) ----------------
  # We set NODE_PATH, so npm can load modules. Details: https://stackoverflow.com/questions/12594541/npm-global-install-cannot-find-module
  export NODE_PATH="${FF_AGENT_HOME}/.n/lib/node_modules"

  # Add '# Export NODE_PATH' into the custom .profile file if in was not injected earlier.
  TARGET_FILE="${FF_AGENT_PROFILE_FILE}"
  PATTERN="^export NODE_PATH=\"${FF_AGENT_HOME}/.n/lib/node_modules\""
  EXPECTED_LINE="export NODE_PATH=\"${FF_AGENT_HOME}/.n/lib/node_modules\""
  INJECT_CONTENT=$(
  cat <<EOT
# Injected by set_environment ${FUNCNAME[0]} on $(date --utc)
${EXPECTED_LINE}
EOT
  )
  ERROR_CODE='error_injecting_export_node_path_to_ff_agent_profile'

  # Do injection and check result
  inject_into_file  \
    "${TARGET_FILE}" \
    "${PATTERN}" \
    "${INJECT_CONTENT}" || {
      # Error: clean up tmp folder, report an error and return error code 1
      popd || { set_state "${FUNCNAME[0]}" 'error_popd'; return 1; }
      rm -fr "${TMPDIR}" || { set_state "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
  }
  # ------------------ Export NODE_PATH and inject that export into FF_AGENT_PROFILE_FILE (end) ----------------


  # ------------------ Inject "ff_agent/.n/bin" into PATH and inject that export into FF_AGENT_PROFILE_FILE (begin) ----------------

  # Update PATH variable (if it not yet contains expected string)
  printenv PATH | grep --quiet "${N_PREFIX}/bin"
  if [ ${?} -ne 0 ]; then
    export PATH="${N_PREFIX}/bin:${PATH}" || {
        # Error: clean up tmp folder, report an error and return error code 1
        popd || { set_state "${FUNCNAME[0]}" 'error_popd'; return 1; }; rm -fr "${TMPDIR}"  || { set_state "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }
        set_state "${FUNCNAME[0]}" 'error_modifying_path'; return 1;
    }
  fi

  # Note: we escape "\$" in front of the PATH, so it does not get expanded
  TARGET_FILE="${FF_AGENT_PROFILE_FILE}"
  PATTERN="^export PATH=\"${N_PREFIX}/bin:\${PATH}\""
  EXPECTED_LINE="export PATH=\"${N_PREFIX}/bin:\${PATH}\""
  if ! file_contains_pattern "${TARGET_FILE}" "${PATTERN}"; then
    # Expected line is missing, Inject text
    (
      cat <<EOT
# Injected by set_environment ${FUNCNAME[0]} on $(date --utc)
${EXPECTED_LINE}
EOT
    ) >> "${TARGET_FILE}" || {
        # Error: clean up tmp folder, report an error and return error code 1
        popd || { set_state "${FUNCNAME[0]}" 'error_popd'; return 1; }; rm -fr "${TMPDIR}"  || { set_state "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }
        set_state "${FUNCNAME[0]}" 'error_injecting_n_prefix_bin_to_ff_agent_profile'; return 1;
    }
  fi
  # ------------------ Inject "ff_agent/.n/bin" into PATH and inject that export into FF_AGENT_PROFILE_FILE (end) ----------------


  # Install 'n_lts' using dowloaded into TMPDIR 'n' ('n_lts' will be installed into ff_agent/.n)
  retry_command 5 15 bash n lts || {
    # Error: clean up tmp folder, report an error and return error code 1
    popd || { set_state "${FUNCNAME[0]}" 'error_popd'; return 1; }; rm -fr "${TMPDIR}"  || { set_state "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }
    set_state "${FUNCNAME[0]}" 'error_installing_n_lts'; return 1;
  }

  # Install 'n' into ff_agent/.n  (yes, we have downloaded 'n' into TMPDIR,
  # then used it to install 'npm', and now we use 'npm' to install "globally" n.
  # The proper installed 'n' will reisde under ff_agent/.n/ folder)
  npm install --verbose --global n || {
    # Error: clean up tmp folder, report an error and return error code 1
    popd || { set_state "${FUNCNAME[0]}" 'error_popd'; return 1; }; rm -fr "${TMPDIR}"  || { set_state "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }
    set_state "${FUNCNAME[0]}" 'error_installing_n'; return 1;
  }

  # Clean up tmp folder
  popd || { set_state "${FUNCNAME[0]}" 'error_popd'; return 1; }; rm -fr "${TMPDIR}"  || { set_state "${FUNCNAME[0]}" 'failed_to_remove_tmpdir'; return 1; }

  # Chage state and return success
  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f install_n

###############################################################################
#
function install_nodejs {
  set_state "${FUNCNAME[0]}" 'started'

  local APPROACH='n'

  # Get expected nodejs version
  local VERSION="$( get_expected_nodejs_version )"
  [ -z "${VERSION}" ] && { set_state "${FUNCNAME[0]}" 'failed_to_get_expected_nodejs_version'; abort; }

  case ${APPROACH} in
      nvm)
          install_nvm_ubuntu
          export NVM_DIR="$([ -z "${XDG_CONFIG_HOME-}" ] && printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm")"
          [ -s "${NVM_DIR}/nvm.sh" ] && \. "${NVM_DIR}/nvm.sh"
          nvm install lts/*
      ;;
      n)
          # # We need to stop pm2 before replacing location of nodejs, otherwise any pm2 command would faild
          # stop_pm2
          # uninstall_n_outside_ff_agent_home  || { set_state "${FUNCNAME[0]}" 'terminal_error_uninstall_n_outside_ff_agent_home'; abort; }
          install_n || { set_state "${FUNCNAME[0]}" 'terminal_error_install_n'; abort; }
          n install "${VERSION}" || { set_state "${FUNCNAME[0]}" 'terminal_error_switching_node_version'; abort; }
      ;;
  esac

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f install_nodejs

###############################################################################
#
# Install nodejs latest environment
function install_nodejs_suite {
  set_state "${FUNCNAME[0]}" 'started'

  install_nodejs || { set_state "${FUNCNAME[0]}" 'terminal_error_install_node'; abort; }

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f install_nodejs_suite

###############################################################################
#
# Continuation of the "set_environment". Installing baseline components.
# On errror: function aborts (so no need to errorcheck on caller side)
#
function install_set_environment_baseline {

  # Discover environment (choose user, make sure it's home folder exists, check FF_CONTENT_URL is set etc.)
  discover_environment || { abort "terminal_error_failed_to_discover_environment"; }

  # Now we can set_state()
  set_state "${FUNCNAME[0]}" 'started'

  # Analyzes currently selected user and might call "background_install()" to re-run the installer under a different user
  # Note: it have a dependency: variable FF_AGENT_USERNAME - must be set (by get_best_ff_agent_home())
  if [ "$( check_if_need_background_install )" == "true" ]; then
    background_install "${FF_AGENT_USERNAME}"
    return 0
    # Note: we can not "exit 0" here since installer might be sourced by "root"
  fi

  # Put logs in best location
  setup_logging || { set_state "${FUNCNAME[0]}" "terminal_error_failed_to_setup_logging"; abort; }

  # Install set of basic packages, bash functions, .bashrc and .profile files
  assert_clean_exit assert_baseline_components || { set_state "${FUNCNAME[0]}" "terminal_error_failed_to_assert_baseline_components"; abort; }

  set_state "${FUNCNAME[0]}" 'success'
}
export -f install_set_environment_baseline

###############################################################################
# Category: process
# pm2_is_installed
# Checks if pm2 is installed
# Returns 0 if it is, 1 if it isn't
function pm2_is_installed {
    set_state "${FUNCNAME[0]}" 'started'
    local STATUS=0
    local PACKAGE="pm2"
    local NPM=$( command_exists npm ) || { set_state "${FUNCNAME[0]}" 'error_dependency_not_met_npm'; return 1; }

    # If it not installed, set STATUS=1
    ${NPM} list "${PACKAGE}" --global >/dev/null
    STATUS=${?}

    set_state "${FUNCNAME[0]}" 'success'
    return ${STATUS}
}
export -f pm2_is_installed

# ##########################################################################################
# #
# # The following function defines the list of packages required to run "puppeteer" as a part
# # of unit tests on our porjects.
# # See the official "Puppeteer: Troubleshooting" page:
# # https://github.com/puppeteer/puppeteer/blob/main/docs/troubleshooting.md
# #
# ##########################################################################################
# function apt_install_puppeteer_dependencies {
#   local REQUIRED_PACKAGES=(
#     ca-certificates
#     fonts-liberation
#     libappindicator3-1
#     libasound2
#     libatk-bridge2.0-0
#     libatk1.0-0
#     libc6
#     libcairo2
#     libcups2
#     libdbus-1-3
#     libexpat1
#     libfontconfig1
#     libgbm1
#     libgcc1
#     libglib2.0-0
#     libgtk-3-0
#     libnspr4
#     libnss3
#     libpango-1.0-0
#     libpangocairo-1.0-0
#     libstdc++6
#     libx11-6
#     libx11-xcb1
#     libxcb1
#     libxcomposite1
#     libxcursor1
#     libxdamage1
#     libxext6
#     libxfixes3
#     libxi6
#     libxrandr2
#     libxrender1
#     libxss1
#     libxtst6
#     lsb-release
#     wget
#     xdg-utils
#   )
# }


# ###############################################################################
# #
# # install_ntp disables timesyncd and installs ntp if missing
# #
# # The systemd-timesyncd is basically a small client-only NTP implementation more or less bundled with newer systemd releases.
# # It's more lightweight than a full ntpd but only supports time sync - i.e. it can't act as an NTP server for other machines.
# # We should not use both in parallel, as in theory they could pick different timeservers that have a slight delay between them,
# # leading to your system clock being periodically "jumpy".
# #
# # Comparing the ntp and systemd-timesyncd I found out that ntpd is much better solution:
# # systemd-timesyncd does no clock discipline: the clock is not trained or compensated, and internal clock drift over time is not reduced.
# # It has rudimentary logic to adjust poll interval but without disciplining the host will end up with uneven time forever as
# # systemd-timesyncd pushes or pulls at whatever interval it thinks the near-term drift requires. It also can't assess the
# # quality of the remote time source. You're unlikely to get accuracy much greater than 100ms. This is sufficient for simple
# # end user devices like laptops, but it could definitely cause problems for distributed systems that want greater time precision.
# # (source article: https://unix.stackexchange.com/questions/305643/ntpd-vs-systemd-timesyncd-how-to-achieve-reliable-ntp-syncing/464729#464729 )
# #
# # So install_ntp() disables "systemd-timesyncd" and leaves only "ntpd".
# #
# # Return value: 0 = success, 1 = failure
# #
# # Note: f-n also uses set_state()
# #
# function replace_timesyncd_with_ntpd {
#     set_state "${FUNCNAME[0]}" 'started'

#     # Check if timesyncd is active (disable if active)
#     IS_TIMESYNCD_ACTIVE=$( systemctl status systemd-timesyncd.service | grep -i active | awk '{print $2}' )  # returns 'active' or 'inactive'

#     # Have to commend out the "if" statement below. Here's the reason why:
#     #   Noted IBM agents, where "timedatectl status" still reports non-ntpd time syncing is in place: "Network time on: yes"
#     #   BUT AT THE SAME TIME the "systemctl status systemd-timesyncd.service" output shows "Active: inactive (dead)"
#     #   and only after we run "sudo timedatectl set-ntp no" the output of "timedatectl status" will be finally expected: "Network time on: no"
#     #
#     #if [ "${IS_TIMESYNCD_ACTIVE}" == "active" ]; then

#         # timesyncd is active, need to deactivate it:
#         sudo timedatectl set-ntp no

#         # make sure timedatectl is not not active
#         IS_TIMESYNCD_ACTIVE=$( systemctl status systemd-timesyncd.service | grep -i active | awk '{print $2}' )  # returns 'active' or 'inactive'
#         if [ "${IS_TIMESYNCD_ACTIVE}" == "active" ]; then
#             # Still active! Error out
#             set_state "${FUNCNAME[0]}" 'failed_stop_timesyncd'
#             return 1
#         fi

#     #fi

#     # Check if ntpd is insatalled (install if missing)
#     IS_NTP_INSTALLED=$( dpkg --get-selections ntp | grep -v deinstall | grep install | awk '{print $2}' )  # returns 'install' if is installed or emptry string if not
#     if [ "${IS_NTP_INSTALLED}" != "install" ]; then
#         # ntp is not installed, install it
#         apt_install ntp

#         # Check if ntp is now installed
#         IS_NTP_INSTALLED=$( dpkg --get-selections ntp | grep -v deinstall | grep install | awk '{print $2}' )  # returns 'install' if is installed or emptry string if not
#         if [ "${IS_NTP_INSTALLED}" != "install" ]; then
#             # Still not isntalled! Error out
#             set_state "${FUNCNAME[0]}" 'failed_to_install_ntp'
#             return 1
#         fi
#     fi

#     # Enble NTP (this will make it to autostart on reboot)
#     sudo systemctl enable ntp
#     if [ ${?} -ne 0 ]; then
#         set_state "${FUNCNAME[0]}" 'failed_to_enable_ntp'
#     fi

#     # Start NTP (note: it is safe to try to start in case it is already running - this might happen if ntp was not installed and was just added 1st time by apt)
#     sudo systemctl start ntp
#     if [ ${?} -ne 0 ]; then
#         set_state "${FUNCNAME[0]}" 'failed_to_start_ntp'
#     fi

#     # Last status check: query local ntpd
#     LOCAL_NTP_QUERY_STATUS=$( ntpq -pn )
#     LOCAL_NTP_QUERY_STATUS_EXIT_CODE=${?}

#     if [ ${LOCAL_NTP_QUERY_STATUS_EXIT_CODE} -ne 0 ]; then
#         set_state "${FUNCNAME[0]}" 'failed_to_query_ntp'
#         return 1
#     fi

#     set_state "${FUNCNAME[0]}" 'success'
#     return 0
# }

###############################################################################
# Category: process
# pm2_is_running_as_me
# Will return 0 if it is, 1 if it is not
function pm2_is_running_as_me {
    set_state "${FUNCNAME[0]}" 'started'
    # Process will look like PM2 v4.5.5: God Daemon (/home/user/.pm2)
    local PATTERN="PM2 .*: God Daemon"

    # Check if process is running as local user.
    process_is_running_as_me "${PATTERN}"
    local STATUS=${?}

    set_state "${FUNCNAME[0]}" 'success'

    return ${STATUS}
}
export -f pm2_is_running_as_me

###############################################################################
# Category: process
# pm2_configure
# Configures pm2 the way we want it configured
function pm2_configure {
    set_state "${FUNCNAME[0]}" 'started'
    # Now it is installed, and command is in path. So we shall configure it
    # Configure it to automatically save state
    timeout 30 pm2 set pm2:autodump true            || { set_state "${FUNCNAME[0]}" "pm2_configure_autodump_error"; return 1; }

    # Configure it to rotate logs
    timeout 45 pm2 install pm2-logrotate            || { set_state "${FUNCNAME[0]}" "pm2_install_logrotate_error"; return 1; }
    timeout 30 pm2 set pm2-logrotate:max_size 20M   || { set_state "${FUNCNAME[0]}" "pm2_configure_logrotate_error"; return 1; }
    timeout 30 pm2 set pm2-logrotate:retain 7       || { set_state "${FUNCNAME[0]}" "pm2_configure_logrotate_error"; return 1; }
    timeout 30 pm2 set pm2-logrotate:compress true  || { set_state "${FUNCNAME[0]}" "pm2_configure_logrotate_error"; return 1; }

    # configure it to rotate logs every hour
    timeout 30 pm2 set pm2-logrotate:rotateInterval '0 0 * * * *'  || { set_state "${FUNCNAME[0]}" "pm2_configure_logrotate_error"; return 1; }
    
    # pm2 update sometimes fail on 1st attempt, but then works on the 2nd. Let's add 3 attempts to make sure.
    local IS_PM2_UPDATED=false MAX_ATTEMPTS=3 ATTEMPT
    for ATTEMPT in $( seq 1 ${MAX_ATTEMPTS} ); do
      timeout 55 pm2 update && { IS_PM2_UPDATED=true; break; }
    done
    [ "${IS_PM2_UPDATED}" == "true" ] || { set_state "${FUNCNAME[0]}" "pm2_update_error"; return 1; } # "Error: failed to update pm2 after ${ATTEMPT} attempts"

    set_state "${FUNCNAME[0]}" 'success'
}
export -f pm2_configure

###############################################################################
# Category: process
# pm2_ensure
# This ensures that pm2 is running, and working as we wish. aborts otherwise.
# If it is not installed, we install it.
function pm2_ensure {
    set_state "${FUNCNAME[0]}" 'started'

    # If pm2 is running, then we ensure it is properly configured. It might have been running already, but not properly configured.
    pm2_is_running_as_me
    if [ ${?} == 0 ]; then
        pm2_configure || { set_state "${FUNCNAME[0]}" 'error_configuring_pm2'; abort 'error_configuring_pm2'; }
        set_state "${FUNCNAME[0]}" 'success'
        return 0
    fi

    # It is not running as me, it might not be installed. If that's the case, we install it.
    # Is pm2 installed? If not, install it
    pm2_is_installed || pm2_install || { set_state "${FUNCNAME[0]}" 'error_failed_to_install_pm2'; abort; }

    # Now it has to at least be installed, and not running, so we try to start it.
    pm2_start || { set_state "${FUNCNAME[0]}" 'failed_to_start_pm2'; abort 'failed_to_start_pm2'; }

    # Check if pm2 started and running by expected user
    pm2_is_running_as_me || { set_state "${FUNCNAME[0]}" 'error_pm2_not_running_as_user'; abort 'error_pm2_not_running_as_user'; }

    # Now it is running, so let's configure it
    pm2_configure || { set_state "${FUNCNAME[0]}" 'error_configuring_pm2'; abort 'error_configuring_pm2'; }

    # If all above works, we have it running
    set_state "${FUNCNAME[0]}" 'success'
}
export -f pm2_ensure

###############################################################################
# Category: process
# pm2_install
# Will install pm2 if there is no command 'pm2'
# Will not start it
function pm2_install {
    set_state "${FUNCNAME[0]}" 'started'

    local NPM_PACKAGE="pm2"
    local VERSION="latest"

    # Commented out, since stop_pm2() does not exist (was removed as empty function). If you want to kill that daemon process then run command
    # "pm2 kill" instead of trying to use f-n stop_pm(). Also then update f-n comments to say that this f-n stops pm2 if it is already installed.
    #
    # # We will try to stop it. But that won't stop us from uninstalling it.
    # pm2_is_running_as_me && stop_pm2

    local PM2=$( command_exists "${NPM_PACKAGE}" )
    [ "${PM2}" != "" ] && { set_state "${FUNCNAME[0]}" 'success_no_action_already_installed'; return 0; }

    local NPM=$( command_exists npm )
    [ "${NPM}" == "" ] && { set_state "${FUNCNAME[0]}" 'error_dependency_not_met_npm'; return 1; }

    # Actually install it -- globally
    ${NPM} install --global "${NPM_PACKAGE}@${VERSION}"  || { set_state "${FUNCNAME[0]}" 'error_installing_pm2_npm'; return 1; }

    # Verify command actually exists in path after we have installed it
    local PM2=$( command_exists "${NPM_PACKAGE}" )
    [ "${PM2}" == "" ] && { set_state "${FUNCNAME[0]}" 'error_installing_pm2_command_not_found'; return 1; }

    set_state "${FUNCNAME[0]}" 'success'
}
export -f pm2_install

###############################################################################
# Category: process
# pm2_start
function pm2_start {
    set_state "${FUNCNAME[0]}" 'started'

    # Check if it is running. If it is, we're happy.
    pm2_is_running_as_me && { set_state "${FUNCNAME[0]}" 'success_no_action_pm2_is_running'; return 0; }

    local PM2=$( command_exists pm2 )
    [ -z "${PM2}" ] && { set_state "${FUNCNAME[0]}" 'error_dependency_not_met_pm2_command'; return 1; }
    ${PM2} start

    # Check if it is running. If it is, we're happy.
    # Note: pm2 can start and still return non-zero (i.e. it started but there was no ecosystem.config.js
    # So it is not sufficient to test for return code, but if it is running as me, then it is at least started
    pm2_is_running_as_me && { set_state "${FUNCNAME[0]}" 'success'; return 0; }

    set_state "${FUNCNAME[0]}" 'error_failed_to_start_pm2'
}
export -f pm2_start

###############################################################################
# Category: process
# pm2_stop stops the running pm2 daemon running as the current user.
# does not stop any root level or other user pm2 daemons.
#
function pm2_stop {
    set_state "${FUNCNAME[0]}" 'started'

    # Check if it is running. If it isn't, we finish.
    pm2_is_running_as_me || { set_state "${FUNCNAME[0]}" 'success_no_action_pm2_not_running'; return 0; }

    # Check if we have the pm2 command. We need it to be able to stop pm2
    local PM2=$( command_exists pm2 ) || { set_state "${FUNCNAME[0]}" 'error_pm2_command_not_found'; return 1; }

    # Try and kill pm2
    # Todo: do this with timeout - sometimes pm2 hangs. We ask it to kill itself, but sometimes the cat comes back :)
    ${PM2} kill || { set_state "${FUNCNAME[0]}" 'error_pm2_kill_failed'; return 1; }

    # Verify that it is actually stopped. If it is still running after we killed it, it is a problem.
    pm2_is_running_as_me || { set_state "${FUNCNAME[0]}" 'error_unable_to_validate_pm2_daemon_gone_postcondition_pm2_still_running'; return 1; }

    # We have stopped it, and it is not running.
    set_state "${FUNCNAME[0]}" 'success'
}
export -f pm2_stop

###############################################################################
# Category: process
# pm2_uninstall
# Removes PM2
function pm2_uninstall {
    set_state "${FUNCNAME[0]}" 'started'

    local PACKAGE="pm2"

    # If it is not installed, we are done.
    pm2_is_installed || { set_state "${FUNCNAME[0]}" 'success_no_action_not_installed'; return 0; }

    # It's installed, so we will try to remove it
    local NPM=$( command_exists npm)
    [ "${NPM}" = "" ] && { set_state "${FUNCNAME[0]}" 'error_dependency_not_met_npm'; return 1; }
    ${NPM} remove --global "${PACKAGE}" || { set_state "${FUNCNAME[0]}" 'error_uninstalling_package'; return 1; }

    # Verify it is removed. If this returns 1, it is not found. If it returns 0, we still have it.
    pm2_is_installed || { set_state "${FUNCNAME[0]}" 'success'; return 0; }

    set_state "${FUNCNAME[0]}" 'error_validating_uninstallation'
}
export -f pm2_uninstall

###############################################################################
#
# Function set_environment_preserve_source_code require the only argument: root folder of the project
# from which the installer was started. It will analyze if the installer was started
# from the expected place (ff_agent/git/[companyname]/set_environment/ folder) and if not
# it will preserve source code into appropriate folder for future use (updates etc.).
#
function set_environment_preserve_source_code {
  set_state "${FUNCNAME[0]}" 'started'

  # Get passed parameters (path to currently installed project folder)
  PROJECT_ROOT_DIR="${1}"
  [ -d "${PROJECT_ROOT_DIR}" ] || { set_state "${FUNCNAME[0]}" 'failed_to_set_environment_preserve_source_code'; return 1; }

  # As a preparation to preserve project source files (used during this installation), let's change directory to the project root directory.
  pushd "${PROJECT_ROOT_DIR}" || { set_state "${FUNCNAME[0]}" 'failed_to_cd_into_project'; return 1; }

  # Make sure ${FF_AGENT_HOME} is set
  [ ! -z "${FF_AGENT_HOME}" ] || { set_state "${FUNCNAME[0]}" 'error_ff_agen_home_not_set'; return 1; }

  # We need to trust github.com to avoid errors like this:
  # The authenticity of host 'github.com (140.82.113.4)' can't be established.
  # This fix was found here:
  # https://gist.github.com/vikpe/34454d69fe03a9617f2b009cc3ba200b
  # https://github.com/ome/devspace/issues/38
  # And to avoid dublicates:
  # https://serverfault.com/questions/132970/can-i-automatically-add-a-new-host-to-known-hosts
  if ! grep --quiet "$(ssh-keyscan github.com 2>/dev/null)" ${HOME}/.ssh/known_hosts; then
    ssh-keyscan github.com >> ${FF_AGENT_USER_HOME}/.ssh/known_hosts
  fi

  # Extract project owner from github repository URL
  local URL=$( git remote show origin | grep 'Fetch URL:' | awk -F'Fetch URL: ' '{print $2}' )
  [ ! -z "${URL}" ] || { set_state "${FUNCNAME[0]}" 'failed_to_extract_project_url'; return 1; }

  local OWNER=$( parse_github_repository_url "${URL}" "OWNER" )
  [ ! -z "${OWNER}" ] || { set_state "${FUNCNAME[0]}" 'failed_to_extract_project_owner'; return 1; }

  # All projects sources got preserved in this folder
  local PRESERVED_PROJECTS_DIR="${FF_AGENT_HOME}/git"

  # Define current project-specific name and preserved project-specific directory
  local PROJECT_NAME='set_environment'
  local PRESERVED_PROJECT_DIR="${PRESERVED_PROJECTS_DIR}/${OWNER}/${PROJECT_NAME}"

  # Make sure the project-specific folder exists
  if [ ! -d "${PRESERVED_PROJECT_DIR}" ]; then
    # Does not exist, try to create it
    mkdir -p "${PRESERVED_PROJECT_DIR}" || { set_state "${FUNCNAME[0]}" 'failed_to_create_folder_for_code_preservation'; return 1; }
  fi

  # Check PWD is set or try to use $(pwd) or error out
  if [ -z "${PWD}" ]; then
    # PWD is not set, try to set it by "pwd" call
    PWD="$( pwd )" || { set_state "${FUNCNAME[0]}" 'failed_to_get_pwd'; return 1; }
  fi

  # Check if installer running from unexpected folder
  # TODO: check if folder from which we're running installation contains spaces (e.g.: "/tmp/some folder with spaces/" )
  if [ "${PWD}" != "${PRESERVED_PROJECT_DIR}" ]; then
      # Current installer run from unexpected place (like some temporary folder) - need to preserve installed project source folder.
      # Check if previously preserved folder exists, then remove its content before copying files
      # (we don't want the preserved folder to be a mix/merge with old deleted files).
      if [ -d "${PRESERVED_PROJECT_DIR}" ]; then
          # Remove old project source folder content (leaving the folder itself)
          # Note: we don't rm -fr some/path/* since this would miss hidden files. The 'find' gets them all!
          find "${PRESERVED_PROJECT_DIR}" -mindepth 1 -delete || { set_state "${FUNCNAME[0]}" 'failed_to_remove_old_project_source_folder'; return 1; }
      fi

      # Copy newly installed source folder (to preserve it)
      # Note: the "/." is here to copy all files including hidden (which starts with dot). Just '*' would not work.
      cp -a "${PWD}/." "${PRESERVED_PROJECT_DIR}" || { set_state "${FUNCNAME[0]}" 'failed_to_preserve_source_folder'; return 1; }
  fi

  # Restore the original folder
  popd || { set_state "${FUNCNAME[0]}" 'failed_to_popd_after_preserving_source_folder'; return 1; }

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f set_environment_preserve_source_code

###############################################################################
# Log this script standard output and standard error to a log file AND system logger
function set_script_logging {

  # Note: we can not yet call "set_state" on that early stages
 	#set_state "${FUNCNAME[0]}" 'started'

  # Let's find a good directory for logs. This assumes zero knowledge.
  # The _best_ place for these logs would be in "${HOME}/ff_agent/logs" -- if we can write to it we'll create it
  POTENTIAL_LOG_DIRECTORIES=( "${FF_AGENT_HOME}/logs" /var/log/ff_agent /tmp/ff_agent/logs /tmp/ff_agent.$$/logs )

  LOG_DIRECTORY=""

  # Find a directory we can write to. The first will do.
  for POTENTIAL_LOG_DIRECTORY in "${POTENTIAL_LOG_DIRECTORIES[@]}"
  do
      if mkdir -p "${POTENTIAL_LOG_DIRECTORY}"
      then
          LOG_DIRECTORY=${POTENTIAL_LOG_DIRECTORY}
          break
      fi
  done

  if [ -z "${LOG_DIRECTORY}" ]; then
      error "Unable to find a place to log! Tried: ${POTENTIAL_LOG_DIRECTORIES[@]}"
      export LOG_PATH=$( tty )
  else
      # Get current epoch ms. (note: we can't yet use   # "$( get_epoch_ms )" because ff_bash_functions arent installed/updated yet)
      TIMESTAMP_EPOCH_MS="$( get_epoch_ms )"
      LOG_FILE="set_environment.${TIMESTAMP_EPOCH_MS}.log"
      export LOG_PATH="${LOG_DIRECTORY}/${LOG_FILE}"
      # PREVIOUSLY THIS WAS exec &> >(tee -a "${LOG_PATH}")
      exec &> >(tee >(tee -a "${LOG_PATH}" | logger -t set_environment ))
  fi

  # Note: we can not yet call "set_state" on that early stages
 	#set_state "${FUNCNAME[0]}" 'success'
}
export -f set_script_logging

###############################################################################
#
function setup_logging {
	set_script_logging
}
export -f setup_logging
