### BEGIN UTILITY FUNCTIONS: CONTAINERS

# Note: for more details on the "docker_ensure" functions family
# see Jira ticket: "Plan "docker_ensure()" family of functions": https://redoki.atlassian.net/browse/REX-894
#

# Table of contents generated by: file_toc src/architecture/linux/ff_docker_functions
## BEGIN UTILITY FUNCTIONS: CONTAINERS
#    - docker_cleanup
#    - docker_container_name_exists
#    - docker_grep
#    - docker_ensure
#    - docker_ensure_log_to_syslog
#    - docker_get_default_minimum_major_version
#    - docker_get_installed_version
#    - docker_install
#    - docker_is_container_healthy
#    - docker_is_container_log_to_syslog
#    - docker_is_container_running
#    - docker_is_every_container_log_to_syslog
#    - docker_is_installed
#    - docker_is_log_to_syslog
#    - docker_login
#    - docker_login_aws_ecr
#    - docker_login_legacy
#    - docker_minimal_version_check
#    - docker_remove_all_containers
#    - docker_restart
#    - docker_restart_containers
#    - docker_set_log_to_syslog
#    - docker_stop_all_containers
#    - docker_stop_and_remove_container_by_name
#    - docker_stop_container_by_name
#    - docker_volumes_to_containers_list
## END UTILITY FUNCTIONS: DOCKERS


###############################################################################
# CATEGORY
#   CONTAINER MANAGEMENT FUNCTIONS
#
# NAME
#   docker_cleanup - Removes all unused Docker containers, networks, and images.
#
# SYNOPSIS
#   docker_cleanup
#
# DESCRIPTION
#   Executes a 'docker system prune' command with the '--all' and '--force' options to remove
#   all unused Docker containers, networks, and images (both dangling and unreferenced).
#   It checks for necessary dependencies before proceeding and is designed to free up space
#   by cleaning up resources that are no longer in use. Additional checks are implemented to
#   handle potential errors, such as insufficient permissions, ensuring the command's execution
#   is robust across different system configurations.
#
# NOTE
#   Adding '--volumes' to the prune command may delete data from stopped containers, so it's
#   used with caution. More details can be found in the Docker documentation:
#   https://docs.docker.com/engine/reference/commandline/system_prune/
#
# EXAMPLE
#   # Call function and check for errors
#   if docker_cleanup; then
#       echo "Cleanup successful."
#   else
#       echo "Cleanup failed."
#   fi
#
# EXIT STATUS
#   0 - Success, unused Docker resources removed.
#   1 - Error, such as failed cleanup or insufficient permissions.
#
###############################################################################
function docker_cleanup {

  # Check dependencies
  local DEPENDENCIES="docker error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Cleanup some space
  # docker system prune: Remove all unused containers, networks, images (both dangling and unreferenced), and optionally, volumes if --volumes used.
  # Note: adding --volumes might be risky since it will erase DATA from stopped containers.
  # More details: https://docs.docker.com/engine/reference/commandline/system_prune/
  docker system prune --all --force || { error "${FUNCNAME[0]}" 'failed_to_docker_cleanup'; return 1; }
}
export -f docker_cleanup

###############################################################################
# CATEGORY
#   CONTAINER QUERY FUNCTIONS
#
# NAME
#   docker_container_name_exists - Checks if a Docker container exists by name.
#
# SYNOPSIS
#   docker_container_name_exists CONTAINER_IDENTIFIER
#
# DESCRIPTION
#   Determines whether a Docker container with the specified name or ID exists. This function
#   utilizes 'docker inspect' with the '--type container' option to accurately identify
#   the container, ensuring that the command only inspects containers (not images or other
#   Docker objects). It performs dependency checks and validates the input to ensure robust
#   operation. If no container name is specified or dependencies are missing, the function
#   will return an error.
#
# USAGE EXAMPLE
#   docker_container_name_exists "my_container" || { error "${FUNCNAME[0]}" "failed_to_docker_container_name_exists"; return 1; }
#   docker_container_name_exists 6bdea105cbbb || { error "${FUNCNAME[0]}" "failed_to_docker_container_name_exists"; return 1; }
#
# EXIT STATUS
#   0 - Container with the specified name exists.
#   1 - Dependency check failed or container does not exist.
#   2 - No container name specified or other errors.
#
###############################################################################
function docker_container_name_exists {

  # Check dependencies
  local DEPENDENCIES="docker error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  local CONTAINER_IDENTIFIER="${1}"
  # -z - true if the length of string is zero
  # -n - true if the length of string is nonzero
  if [ -z "${CONTAINER_IDENTIFIER}" ]; then
    error "${FUNCNAME[0]}: error_no_container_name_specified"
    return 2
  fi

  # Note: simple "docker inspect some-name" is ambiguous and can inspect either container or image.
  # To disambiguate we use "--type" (can be one of: container|image|node|network|secret|service|volume|task|plugin).
  # For more details see the official docs: https://docs.docker.com/engine/reference/commandline/inspect/
  #
  local CONTAINER_ID
  CONTAINER_ID=$(docker inspect --type container --format="{{.Id}}" ${CONTAINER_IDENTIFIER} 2> /dev/null)
}
export -f docker_container_name_exists

###############################################################################
# CATEGORY
#   DOCKER SEARCH FUNCTIONS
#
# NAME
#   docker_grep - Recursively searches the filesystem within a Docker container for a given string.
#
# SYNOPSIS
#   docker_grep CONTAINER_IDNAME SEARCH_TERM
#
# DESCRIPTION
#   This function performs a recursive search for a specified string within the filesystem of a Docker container,
#   identified by either its name or ID. It leverages 'docker exec' with root privileges (-u 0) to execute a 'find'
#   command, excluding several directories to optimize the search process. The search is further refined by employing
#   'grep' with options to ignore binary files, include filenames, and display line numbers for matches. It is designed
#   to handle large filesystems efficiently while avoiding common errors such as 'Argument list too long'.
#
# USAGE EXAMPLE
#   # Search for a string within a Docker container
#   docker_grep "action_manager" "LOG_DIR"
#   docker_grep "34d4cf" "LOG_DIR"
#
#   # The result is printed to the standard output.
#
# EXIT STATUS
#   0 - Search completed successfully.
#   1 - Dependency check failed, container name/ID or search term not specified, or other errors.
#
###############################################################################
function docker_grep {

  # Check dependencies
  local DEPENDENCIES="docker cut error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Get arguments
  CONTAINER_IDNAME="${1}"
  SEARCH_TERM="${2}"

  # Check arguments
  [ ! -z "${CONTAINER_IDNAME}" ] || { error "${FUNCNAME[0]}: Failed to get the container name from the arguments."; exit 1; }
  [ ! -z "${MATCH}" ] || { error "${FUNCNAME[0]}: Failed to extract match term."; exit 1; }

  # Newer call exclude non-ascii files, exclude certain paths, prints filename and line numbers (very fast)
  # Note: had to split to 2 calls: find() and collect to array, later iterate and grep, otherwise
  #
  # Getting several errors:
  #  - while calling "file": sudo: unable to execute /usr/bin/file: Argument list too long
  #
  # Note: we use "-u 0" to run the command as root, but if we pipe to any
  # other commands they will be run as regular user (might require "sudo").
  docker exec \
  -u 0 \
  "${CONTAINER_IDNAME}" \
  find / \
  ! -path '/lib/*'   \
  ! -path '/sys/*'    \
  ! -path '/proc/*'    \
  ! -path '/usr/lib/*'  \
  ! -path '/var/cache/*' \
  ! -path '/usr/share/*'  \
  ! -path '/usr/include/*' \
  ! -path '/var/lib/dpkg/*' \
  ! -path '/usr/local/lib/*' \
  ! -path '/var/lib/systemd/*' \
  ! -path '/usr/local/include/*'\
  -type f \
  -exec grep \
  --binary-files=without-match \
  --with-filename -n "${SEARCH_TERM}" {} \
  \;
}
export docker_grep

###############################################################################
# CATEGORY
#   DOCKER INSTALLATION AND CONFIGURATION FUNCTIONS
#
# NAME
#   docker_ensure - Ensures Docker is installed with the minimum required version and configured to log to syslog.
#
# SYNOPSIS
#   docker_ensure
#
# DESCRIPTION
#   This function serves as the main entry point for validating and setting up the Docker environment. It checks
#   for Docker's presence, verifies that it meets a specified minimum version requirement, and configures Docker
#   to send logs to syslog. The function uses a multi-step process to achieve this, including the installation
#   or upgrade of Docker if necessary. It relies on auxiliary functions for specific tasks and maintains a state
#   to indicate the progress and success of these operations. Failure at any step will halt the process and return
#   an appropriate error code.
#   Function sets state to indicate success or error code (because it is a complex multi-step function).
#
# USAGE EXAMPLE
#   # Ensure Docker environment is correctly set up
#   docker_ensure
#
#   # Function sets a state to indicate success or specific error codes for troubleshooting.
#
# EXIT STATUS
#   0 - Docker is correctly installed, meets the version requirement, and is configured to log to syslog.
#   1 - Failure due to missing dependencies, Docker not installed, version not met, or logging configuration failure.
#
###############################################################################
function docker_ensure {

  # Check dependencies
  local DEPENDENCIES="state_set docker_is_installed docker_minimal_version_check docker_ensure_log_to_syslog"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  state_set "${FUNCNAME[0]}" 'started'

  # Check if docker is already installed
  if ! docker_is_installed; then
    # Docker is not installed. Install it now.
    docker_install || { state_set "${FUNCNAME[0]}" 'failed_to_docker_install'; return 1; }
  fi

  # Do the docker_minimal_version_check
  if ! docker_minimal_version_check "${MINIMUM_MAJOR_VERSION}"; then
    # Docker does not have expected version. Install proper version now.
    docker_install || { state_set "${FUNCNAME[0]}" 'failed_to_docker_install'; return 1; }
  fi

  # Ensure docker logs sent to syslog
  docker_ensure_log_to_syslog || { state_set "${FUNCNAME[0]}" 'failed_to_docker_ensure_log_to_syslog'; return 1; }

  state_set "${FUNCNAME[0]}" 'success'
}
export -f docker_ensure

###############################################################################
# CATEGORY
#   DOCKER LOGGING CONFIGURATION FUNCTIONS
#
# NAME
#   docker_ensure_log_to_syslog - Ensures the Docker daemon logs are configured to use syslog.
#
# SYNOPSIS
#   docker_ensure_log_to_syslog
#
# DESCRIPTION
#   Verifies whether the current Docker daemon configuration is set to log to syslog. If not,
#   it updates the Docker daemon configuration to enable logging to syslog and then restarts
#   the Docker daemon to apply the changes. This function aims to standardize Docker logging
#   configurations across environments for better log management. It performs checks for necessary
#   dependencies and maintains a state throughout the process to track its execution status and
#   handle errors appropriately.
#   Function sets state to indicate success or error code (because it is a complex multi-step function).
#
# USAGE EXAMPLE
#   # Ensure Docker daemon logs are configured to syslog
#   docker_ensure_log_to_syslog
#
# EXIT STATUS
#   0 - Docker daemon is configured to log to syslog successfully.
#   1 - Failure due to missing dependencies, inability to set syslog logging, or daemon restart failure.
#
###############################################################################
function docker_ensure_log_to_syslog {

  # Check dependencies
  local DEPENDENCIES="state_set docker_is_log_to_syslog docker_set_log_to_syslog docker_restart"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  state_set "${FUNCNAME[0]}" 'started'

  # Check if docker logs to syslog
  if ! docker_is_log_to_syslog; then
    # No, docker logs somewhere else. Reconfigure docker daemon.
    docker_set_log_to_syslog || { state_set "${FUNCNAME[0]}" 'failed_to_docker_set_log_to_syslog'; return 1; }

    # And restart daemon
    docker_restart || { state_set "${FUNCNAME[0]}" 'failed_to_docker_restart'; return 1; }
  fi

  state_set "${FUNCNAME[0]}" 'success'
}
export -f docker_ensure_log_to_syslog

###############################################################################
# CATEGORY
#   DOCKER VERSION MANAGEMENT FUNCTIONS
#
# NAME
#   docker_get_default_minimum_major_version - Outputs the default minimum major version of Docker required.
#
# SYNOPSIS
#   docker_get_default_minimum_major_version
#
# DESCRIPTION
#   This function is a utility within the 'docker_ensure' family of functions. It specifies the minimum
#   major version number of Docker considered necessary for compatibility and successful operation of
#   Docker-dependent functions. By executing this function, users and other functions can programmatically
#   retrieve the required Docker version threshold, facilitating checks and validations against the currently
#   installed Docker version.
#
# USAGE EXAMPLE
#   # Retrieve and store the minimum required Docker major version
#   MINIMUM_MAJOR_VERSION=$(docker_get_default_minimum_major_version) || { error "${FUNCNAME[0]}" 'failed to get docker minimum/major version'; return 1; }
#
#   # Now MINIMUM_MAJOR_VERSION holds the value '23'
#
# NOTE
#   This function does not perform any checks or modifications. It solely outputs the value '23',
#   indicating the default minimum major version of Docker required.
#
###############################################################################
function docker_get_default_minimum_major_version {
  echo 23
}
export -f docker_get_default_minimum_major_version

###############################################################################
# CATEGORY
#   DOCKER VERSION MANAGEMENT FUNCTIONS
#
# NAME
#   docker_get_installed_version - Retrieves the version of the installed Docker daemon.
#
# SYNOPSIS
#   docker_get_installed_version
#
# DESCRIPTION
#   Determines the version of the Docker daemon currently installed on the system and outputs it
#   to the standard output. This function follows the official Docker documentation for retrieving
#   the version using the 'docker version' command with a specific format option. It includes
#   dependency checks and error handling to ensure that Docker is installed and accessible. If Docker
#   is not found, or the version cannot be determined, the function sets an error state.
#
# USAGE EXAMPLE
#   # Retrieve and display the installed Docker version
#   installed_version=$(docker_get_installed_version)
#   if [ $? -eq 0 ]; then
#       echo "Docker version: ${installed_version}"
#   else
#       echo "Error retrieving Docker version."
#   fi
#
# EXIT STATUS
#   0 - Successfully retrieved the Docker version.
#   1 - Dependency check failed, Docker not found, or version retrieval failed.
#
###############################################################################
function docker_get_installed_version {

  # Check dependencies
  local DEPENDENCIES="docker error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check installed version
  #   Official docker documentation: how to get version: https://docs.docker.com/engine/reference/commandline/version/
  INSTALLED_VERSION="$( docker version --format '{{.Server.Version}}' )" || { error "${FUNCNAME[0]}" 'failed_to_get_installed_version_number'; return 1; }

  # Check exit code
  [ "${?}" -eq 0 ] || { error "${FUNCNAME[0]}" "failed_to_get_docker_version"; return 1; }

  # Check we got non-empty version output from docker
  [ ! -z "${INSTALLED_VERSION}" ] || { error "${FUNCNAME[0]}" "error_got_blank_docker_version"; return 1; }

  # Print result to standard output
  echo "${INSTALLED_VERSION}"

}
export -f docker_get_installed_version

###############################################################################
# CATEGORY
#   DOCKER INSTALLATION AND CONFIGURATION FUNCTIONS
#
# NAME
#   docker_install - Installs Docker with an optional specified minimum major version.
#
# SYNOPSIS
#   docker_install [MINIMUM_MAJOR_VERSION]
#
# DESCRIPTION
#   Installs Docker on supported Ubuntu versions (16.04, 18.04, 20.04) if it is not already installed or
#   if the installed version is below the specified minimum major version. If the minimum version is not
#   specified, the default version returned by docker_get_default_minimum_major_version() is used. This
#   function checks for necessary dependencies and required environment variables, handles the installation
#   or upgrade process, configures Docker to log to syslog, and adds the user specified by the FF_AGENT_USERNAME
#   environment variable to the Docker group. It includes comprehensive error handling and state setting at each
#   step to indicate success or specific error conditions. This function supports a complex, multi-step installation
#   and configuration process.
#   Function sets state to indicate success or error code (because it is a complex multi-step function).
#
# SUPPORTED SYSTEMS
#   Ubuntu 16.04, 18.04, 20.04
#
# REQUIREMENTS
#   Environment variable: FF_AGENT_USERNAME must be set.
#
# USAGE EXAMPLE
#   # Install Docker with default minimum version
#   docker_install
#
#   # Install Docker specifying a minimum major version
#   docker_install 20
#
# EXIT STATUS
#   0 - Docker installed or updated successfully, configured to log to syslog, and user added to Docker group.
#   1 - Failure due to missing dependencies, environment variable checks, unsupported system, installation errors,
#       or configuration failures.
#
###############################################################################
function docker_install {

  state_set "${FUNCNAME[0]}" 'started'

  # Check dependencies
  local DEPENDENCIES=(
    "add-apt-repository"
    "apt_install"
    "apt_update"
    "docker_get_default_minimum_major_version"
    "docker_minimal_version_check"
    "docker_set_log_to_syslog"
    "ensure_variable_not_empty"
    "hardware_architecture_get"
    "is_user_in_group"
    "lsb_codename_get"
    "lsb_id_get"
    "lsb_release_get"
    "service_is_running"
    "state_set"
    "sudo"
    "systemctl"
    "usermod"
  )

  # Note: check_dependencies will report missing dependencies
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || {
    state_set "${FUNCNAME[0]}" 'dependenciesfailed'; return 1;
  }

  # Define required variables
  local REQUIRED_VARIABLES=(
    FF_AGENT_USERNAME
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      # Dynamically generate an error_code, which include failed variable name (lowercase)
      local ERROR_CODE="$( echo "failed_to_ensure_variable_not_empty_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )"
      state_set "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Take optional MINIMUM_MAJOR_VERSION argument, if empty, then set default value
  local MINIMUM_MAJOR_VERSION="${1}"
  if [ -z "${MINIMUM_MAJOR_VERSION}" ]; then
    # Use default value
    MINIMUM_MAJOR_VERSION=$( docker_get_default_minimum_major_version ) || { state_set "${FUNCNAME[0]}" "failed_to_get_default_minimum_version"; return 1; }
  fi

  # Do the docker_minimal_version_check
  if docker_minimal_version_check "${MINIMUM_MAJOR_VERSION}"; then
    # Installed version passed the minimal version check, no need to install
    state_set "${FUNCNAME[0]}" "no_action_already_installed"
    return 0
  fi

  # Need to install since we don't have the minimum version, or docker is not installed

  # Get ID, RELEASE and DISTRO and verify the values are actually set
  local LSB_ID
  LSB_ID=$( lsb_id_get_downcase ) || { state_set "${FUNCNAME[0]}" "failed_to_lsb_id_get"; return 1; } # ubuntu
  [ "${LSB_ID}" == "" ] && { state_set "${FUNCNAME[0]}" "failed_to_lsb_id_get"; return 1; }

  local RELEASE
  RELEASE=$( lsb_release_get ) || { state_set "${FUNCNAME[0]}" "failed_to_lsb_release_get"; return 1; }  # 18.04, 20.04, ...
  [ "${RELEASE}" == "" ] && { state_set "${FUNCNAME[0]}" "failed_to_lsb_release_get"; return 1; }

  local DISTRO
  DISTRO=$( lsb_codename_get ) || { state_set "${FUNCNAME[0]}" "failed_to_lsb_codename_get"; return 1; }  # bionic, focal, ...
  [ "${DISTRO}" == "" ] && { state_set "${FUNCNAME[0]}" "failed_to_lsb_codename_get"; return 1; }

  local ARCHITECTURE
  ARCHITECTURE=$( hardware_architecture_get ) || { state_set "${FUNCNAME[0]}" "error_getting_hardware_architecture"; return 1; }

  # Sanity check: ARCHITECTURE is not empty
  [ -n "${ARCHITECTURE}" ] || { state_set "${FUNCNAME[0]}" "error_getting_hardware_architecture"; return 1; }

  # Only Ubuntu for now.
  if [ "${LSB_ID}" != "ubuntu" ]; then
    state_set "${FUNCNAME[0]}" "error_docker_install_unsupported_operating_system"
    return 1
  fi

  # Add GPG key for download.docker.com
  # TODO: We might not have sudo, so we should request command to be run.
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg \
    | sudo --non-interactive DEBIAN_FRONTEND=noninteractive apt-key add -
  [ ${?} -ne 0 ] && { state_set "${FUNCNAME[0]}" "failed_to_add_gpg_key"; return 1; }

  # Add docker apt repository (apt = Advanced package tool)
  # TODO: We might not have sudo, so we should request command to be run.
  sudo add-apt-repository --yes "deb [arch=${ARCHITECTURE}] https://download.docker.com/linux/ubuntu ${DISTRO} stable"
  [ ${?} -ne 0 ] && { state_set "${FUNCNAME[0]}" "failed_to_add_repository"; return 1; }

  # Update the apt package index file (apt = Advanced package tool)
  apt_update

  # Define required pagage names
  local PACKAGES=(
    docker-ce
    docker-ce-cli
    docker-compose

    # The containerd is available as a daemon for Linux and Windows.
    # It manages the complete container lifecycle of its host system,
    # from image transfer and storage to container execution and supervision
    # to low-level storage to network attachments and beyond.
    containerd.io
  )

  # Install required packages
  for PACKAGE in "${PACKAGES[@]}"; do
    apt_install "${PACKAGE}" || {
      local ERROR_CODE="$( echo "failed_to_install_package_${PACKAGE}" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]' )"
      state_set "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Add ourselves as a user to be able to run docker
  GROUP="docker"
  # Check the 'docker' group exists.
  if ! check_group_exists "${GROUP}"; then
    state_set "${FUNCNAME[0]}" "error_group_docker_does_not_exist"
    return 1
  fi

  # TODO: We might not have sudo, so we should request command to be run.
  # Check if user is in this group. If not, add them
  if ! is_user_in_group "${FF_AGENT_USERNAME}" "${GROUP}"; then
    # Not in group
    sudo usermod -aG "${GROUP}" "${FF_AGENT_USERNAME}"
    if [ ${?} -ne 0 ]; then state_set "${FUNCNAME[0]}" "failed_to_modify_docker_user_group"; return 1; fi
    # Now check that we actually are in the group. This will work in current shell because it reads the groups file directly
    if ! is_user_in_group "${FF_AGENT_USERNAME}" "${GROUP}"; then
      state_set "${FUNCNAME[0]}" "failed_postcondition_user_in_group"
      return 1
    fi
  fi

  # Postcondition checks
  # Verify docker is properly set up
  # Note we are running via sudo, and if we added user to the ${GROUP} then it won't be applied in this shell.
  secret_set docker_release "$( docker --version )" || { state_set "${FUNCNAME[0]}" "failed_to_run_docker_to_get_release"; return 1; }
  secret_set docker_compose_relase "$( docker-compose --version )" || { state_set "${FUNCNAME[0]}" "failed_to_run_docker_compose_to_get_release"; return 1; }

  # Check if installed docker version is less than minimally required
  # Do the docker_minimal_version_check
  if ! docker_minimal_version_check "${MINIMUM_MAJOR_VERSION}"; then
    # Error: installed version did not pass the minimal version check
    state_set "${FUNCNAME[0]}" "failed_postcondition_docker_minimal_version_check"
    return 1
  fi

  # Restart docker to apply logging configuration (to syslog) only if docker is running
  # When we're inside docker with /var/run/docker.sock mounted there is no need to restart nor to configure logging
  if service_is_running docker; then

    # Set up docker daemon logging (log to syslog) if not already done
    if ! docker_is_log_to_syslog; then
      docker_set_log_to_syslog || { state_set "${FUNCNAME[0]}" "failed_to_docker_set_log_to_syslog"; return 1; }
    fi

    # Restart docker
    docker_restart || { state_set "${FUNCNAME[0]}" "failed_to_restart_docker"; return 1; }

    # Since docker is running we can check it is logging to syslog
    local EXPECTED_DOCKER_LOGGING="syslog"
    local ACTUAL_DOCKER_LOGGING=$( docker info --format '{{.LoggingDriver}}' )
    if [ "${EXPECTED_DOCKER_LOGGING}" != "${ACTUAL_DOCKER_LOGGING}" ]; then
      state_set "${FUNCNAME[0]}" "failed_to_confirm_logging_configuration_applied"
      return 1
    fi
  fi

  state_set "${FUNCNAME[0]}" 'success'
}
export -f docker_install

###############################################################################
# CATEGORY
#   CONTAINER HEALTH CHECK FUNCTIONS
#
# NAME
#   docker_is_container_healthy - Checks if a specified Docker container is healthy.
#
# SYNOPSIS
#   docker_is_container_healthy CONTAINER_IDENTIFIER
#
# DESCRIPTION
#   Determines the health status of a Docker container by verifying its current state against
#   the 'running' status. This function is designed to distinguish between containers that are
#   actively running and those that may be in a restarting or unhealthy state. It requires the
#   name or ID of the container as an argument and performs necessary dependency checks before
#   proceeding. If the container is found to be in the 'running' state, the function returns
#   success; otherwise, it returns failure.
#
# USAGE EXAMPLE
#   docker_is_container_healthy "my_container" || { error "Container is not healthy."; return 1; }
#   docker_is_container_healthy ac8f8b7be551   || { error "Container is not healthy."; return 1; }
#
# EXIT STATUS
#   0 - Container is in a 'running' state and considered healthy.
#   1 - Container is not in a 'running' state or command failed.
#   2 - No container name specified.
#
###############################################################################
function docker_is_container_healthy {

  # Check dependencies
  local DEPENDENCIES="error docker"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # TAke arguments
  local CONTAINER_IDENTIFIER="${1}"

  # -z - true if the length of string is zero
  # -n - true if the length of string is nonzero
  if [ -z "${CONTAINER_IDENTIFIER}" ]; then
    error "${FUNCNAME[0]}: error_no_container_name_specified"
    return 2
  fi
  if [ "$( docker container inspect -f '{{.State.Status}}' ${CONTAINER_IDENTIFIER} )" == "running" ]; then
    return 0
  else
    return 1
  fi
}
export -f docker_is_container_healthy

###############################################################################
# CATEGORY
#   CONTAINER LOGGING CONFIGURATION FUNCTIONS
#
# NAME
#   docker_is_container_log_to_syslog - Checks if a specified Docker container is configured to log to syslog.
#
# SYNOPSIS
#   docker_is_container_log_to_syslog CONTAINER_IDENTIFIER
#
# DESCRIPTION
#   Verifies the log configuration of a Docker container, identified by its name or
#   a partial container ID, to determine whether it is configured to send logs to syslog.
#   This function is essential for ensuring that container logs are being managed according
#   to specified logging policies. It performs a check against the container's logging driver
#   configuration, comparing it to the expected syslog driver. An error is reported if Docker
#   is not installed, the container does not exist, or if the container's logging driver does
#   not match the expected syslog configuration.
#
# EXAMPLES
#   # Check if a container is configured to log to syslog
#   if docker_is_container_log_to_syslog "abcdefa021da"; then
#       echo "Container is configured to log to syslog."
#   else
#       echo "Container does not log to syslog."
#   fi
#
#   # Another example using container name
#   if docker_is_container_log_to_syslog "mongo"; then
#       echo "Mongo container logs to syslog."
#   else
#       echo "Mongo container does not log to syslog."
#   fi
#
# EXIT STATUS
#   0 - Container is configured to log to syslog.
#   1 - Container does not send logs to syslog, or other errors occurred.
#
###############################################################################
function docker_is_container_log_to_syslog {

  # Check dependencies
  local DEPENDENCIES="state_set error docker"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check number of arguments: must be exactly 1
  [ $# -eq 1 ] || { error "${FUNCNAME[0]}" 'error_wrong_number_of_arguments'; return 1; }

  # Take argument (container ID or name)
  local CONTAINER_IDENTIFIER="${1}"

  # Check if docker installed
  docker_is_installed || { error "${FUNCNAME[0]}" 'error_docker_is_not_installed'; return 1; }

  # Check such container exists
  local MATCHING_CONTAINERS_NUMBER
  MATCHING_CONTAINERS_NUMBER=$( docker ps -a  )=$( docker ps -a ) || { error "${FUNCNAME[0]}" 'Failed to list docker containers by command: docker ps -a'; return 1; }

  # Define expected logging driver
  local EXPECTED_LOGGING_DRIVER="syslog"

  # Get actually configured logging driver
  local ACTUAL_LOGGING_DRIVER
  ACTUAL_LOGGING_DRIVER=$( docker inspect -f '{{.HostConfig.LogConfig.Type}}' "${CONTAINER_IDENTIFIER}" ) || { error "${FUNCNAME[0]}" 'failed_to_get_docker_log_config_type'; return 1; }

  # Note: Same can be extracted using "jq":
  # local ACTUAL_LOGGING_DRIVER
  # ACTUAL_LOGGING_DRIVER=$( docker inspect "${CONTAINER_IDENTIFIER}" | jq --raw-output .[].HostConfig.LogConfig.Type ) || { error "${FUNCNAME[0]}" 'failed_to_get_docker_log_config_type'; return 1; }

  # Compare actual vs. expected
  if [ "${ACTUAL_LOGGING_DRIVER}" != "${EXPECTED_LOGGING_DRIVER}" ]; then
    # Mismatch: docker has some unexpected logging driver
    error "${FUNCNAME[0]}" 'error_unexpected_logging_driver'
    return 1
  fi
}
export -f docker_is_container_log_to_syslog

###############################################################################
# CATEGORY
#   CONTAINER STATUS CHECK FUNCTIONS
#
# NAME
#   docker_is_container_running - Checks if a Docker container, identified by name or partial ID, is currently running.
#
# SYNOPSIS
#   docker_is_container_running CONTAINER_IDENTIFIER
#
# DESCRIPTION
#   Evaluates the running status of a Docker container using its name or a partial container ID. This function
#   is particularly useful for scenarios where containers may be in a 'restart' loop, indicating an attempt to
#   run but facing continuous failures. It leverages 'docker container inspect' to directly query the container's
#   operational state. Dependency checks ensure that the necessary tools are available before attempting the
#   operation. The function returns an error if the container identifier is not provided, dependencies are missing,
#   or the container is not found to be in the 'running' state.
#
# EXAMPLES
#   # Check if a container with a specific name or partial ID is running
#   docker_is_container_running "my_container" || { error "${FUNCNAME[0]} container is not running"; return 1; }
#   docker_is_container_running 80c338f9af84 || { error "${FUNCNAME[0]} container is not running"; return 1; }
#
# EXIT STATUS
#   0 - Container is running.
#   1 - Container is not running.
#   2 - Error due to missing container identifier argument.
#   3 - Error due to missing dependencies.
#
###############################################################################
function docker_is_container_running {

  # Check dependencies
  local DEPENDENCIES="docker error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 3  # Note: check_dependencies will report missing dependencies

  # Take argument, check it is not empty
  local CONTAINER_IDENTIFIER="${1}"
  [ ! -z "${CONTAINER_IDENTIFIER}" ] || { error "${FUNCNAME[0]}: error_no_container_name_specified"; return 2; }

  # Inspect given container, make sure it is in ranning state
  # Note: simple "docker inspect some-name" is ambiguous and can inspect either container or image.
  # To disambiguate we use "--type" (can be one of: container|image|node|network|secret|service|volume|task|plugin).
  # For more details see the official docs: https://docs.docker.com/engine/reference/commandline/inspect/
  # Or alternatively we can use "docker container inspect"
  if [ "$( docker container inspect -f '{{.State.Running}}' ${CONTAINER_IDENTIFIER} 2>/dev/null)" == "true" ]; then
    return 0
  else
    return 1
  fi
}
export -f docker_is_container_running

###############################################################################
# CATEGORY
#   CONTAINER LOGGING CONFIGURATION FUNCTIONS
#
# NAME
#   docker_is_every_container_log_to_syslog - Verifies if all running Docker containers are configured to log to syslog.
#
# SYNOPSIS
#   docker_is_every_container_log_to_syslog
#
# DESCRIPTION
#   Iterates over all currently running Docker containers to check if each is configured to log to syslog. This
#   function is crucial for ensuring a uniform logging configuration across all containers, facilitating centralized
#   log management. It relies on the docker_is_container_log_to_syslog function to check the logging configuration
#   of individual containers. The process includes dependency checks to ensure all necessary commands and functions
#   are available. The function succeeds only if every inspected container is confirmed to be logging to syslog,
#   otherwise, it returns an error.
#
# EXAMPLES
#   # Verify all running containers log to syslog
#   docker_is_every_container_log_to_syslog || { error "${FUNCNAME[0]}" "One or more containers are not configured to log to syslog."; return 1; }
#
# EXIT STATUS
#   0 - All running containers are configured to log to syslog.
#   1 - One or more containers are not logging to syslog, Docker is not installed, or other errors occurred.
#
###############################################################################
function docker_is_every_container_log_to_syslog {

  # Check dependencies
  local DEPENDENCIES="docker_is_container_log_to_syslog docker awk error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check if docker installed
  docker_is_installed || { error "${FUNCNAME[0]}" 'error_docker_is_not_installed'; return 1; }

  # Get list of running container names
  local CONTAINERS
  CONTAINERS=$(docker ps | awk '{if(NR>1) print $NF}') || { error "${FUNCNAME[0]}" 'failed_to_get_continers_list'; return 1; }

  # Iterate running containers and check docker_is_container_log_to_syslog() on each
  for CONTAINER in ${CONTAINERS}; do
    docker_is_container_log_to_syslog "${CONTAINER}" || { error "${FUNCNAME[0]}" 'error_found_container_not_logging_to_syslog'; return 1; }
  done
}
export -f docker_is_every_container_log_to_syslog

###############################################################################
# CATEGORY
#   DOCKER INSTALLATION CHECK FUNCTIONS
#
# NAME
#   docker_is_installed - Checks if Docker is installed on the system.
#
# SYNOPSIS
#   docker_is_installed
#
# DESCRIPTION
#   Determines the presence of the Docker command in the system's PATH, thereby verifying if Docker is installed.
#   This function is essential for scripts that depend on Docker to make informed decisions based on Docker's
#   availability. A successful check (docker found) returns a 0 exit code, while any failure to find Docker results
#   in a nonzero exit code. This design allows for straightforward integration with conditional logic in scripts.
#   The function, however, does not currently support distinguishing between a Docker installation's absence and
#   potential errors encountered while checking for Docker, which is a known limitation and an area for future enhancement.
#
# USAGE EXAMPLE
#   # Check if Docker is installed
#   docker_is_installed || { error "${FUNCNAME[0]}" 'error_docker_is_not_installed'; return 1; }
#
# EXIT STATUS
#   0 - Docker is installed.
#   Non-zero - Docker is not installed or an error occurred during the check.
#
###############################################################################
function docker_is_installed {

  # Check dependencies
  local DEPENDENCIES="command_exists"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # If it not installed, set STATUS=1
  command_exists docker >/dev/null
}
export -f docker_is_installed

###############################################################################
# CATEGORY
#   DOCKER LOGGING CONFIGURATION CHECK FUNCTIONS
#
# NAME
#   docker_is_log_to_syslog - Verifies if Docker daemon is configured to log to syslog.
#
# SYNOPSIS
#   docker_is_log_to_syslog
#
# DESCRIPTION
#   Checks the logging configuration of the Docker daemon to determine whether it is set to
#   use syslog as the logging driver. This verification is critical for ensuring that Docker
#   logs are centralized and managed according to system-wide logging policies. The function
#   performs a dependency check to ensure Docker is installed before querying Docker's
#   configuration. A successful check indicates Docker is correctly configured to send logs
#   to syslog, facilitating easier log management and integration with syslog-based tools.
#
# USAGE EXAMPLE
#   # Check Docker's logging configuration
#   docker_is_log_to_syslog || { error "${FUNCNAME[0]}" "Docker logs are not sent to syslog."; return 1; }
#
# EXIT STATUS
#   0 - Docker is configured to send logs to syslog.
#   1 - Docker is not configured to send logs to syslog, Docker is not installed, or an error occurred during the check.
#
###############################################################################
function docker_is_log_to_syslog {

  # Check dependencies
  local DEPENDENCIES="docker_is_installed error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check if docker installed
  docker_is_installed || { error "${FUNCNAME[0]}" 'error_docker_is_not_installed'; return 1; }

  # Define expected logging driver
  local EXPECTED_LOGGING_DRIVER="syslog"

  # Get actually configured logging driver
  local ACTUAL_LOGGING_DRIVER
  ACTUAL_LOGGING_DRIVER=$( docker info --format '{{.LoggingDriver}}' ) || { error "${FUNCNAME[0]}" 'failed_to_get_docker_logging_driver'; return 1; }

  # Compare actual vs. expected
  if [ "${ACTUAL_LOGGING_DRIVER}" != "${EXPECTED_LOGGING_DRIVER}" ]; then
    # Mismatch: docker has some unexpected logging driver
    error "${FUNCNAME[0]}" 'error_unexpected_logging_driver'
    return 1
  fi
}
export -f docker_is_log_to_syslog

###############################################################################
# CATEGORY
#   DOCKER REGISTRY LOGIN FUNCTIONS
#
# NAME
#   docker_login - Logs in to a container repository, supporting both legacy and AWS ECR repositories.
#
# SYNOPSIS
#   docker_login FQDN [USERNAME] [PASSWORD] [AWS_ACCESS_KEY_ID] [AWS_SECRET_ACCESS_KEY]
#
# DESCRIPTION
#   This function facilitates logging into container repositories by abstracting the login process
#   for both legacy repositories and AWS Elastic Container Registry (ECR). It supports various login
#   scenarios, including using fully qualified domain names (FQDNs) for the repository, with credentials
#   either supplied directly as arguments or pre-set via environment variables for AWS ECR. For legacy
#   repositories, it requires the repository's FQDN, username, and password. For AWS ECR, it can operate
#   with the FQDN and region alone (assuming AWS credentials are set in the environment) or with all
#   credentials provided as arguments. This flexibility ensures compatibility across different registry
#   types and authentication methods.
#
#   Basically function supports 2 cases:
#     1) "legacy" repositories (requres 3 arguments: FQDN, username and password)
#     2) AWS ECR (require: FQDN + Amazon secrets)
#
#   Note: for the AWS ECR there can be 2 or 4 arguments used:
#     1) only 1 argument: FQDN and the Amazon secrets alrady set via environment variables:
#          export AWS_ACCESS_KEY_ID=xxx
#          export AWS_SECRET_ACCESS_KEY=xxx
#     2) 3 arguments: FQDN, aws_access_key_id and aws_secret_access_key
#
# DEPENDENCIES
#   Requires 'docker_login_aws_ecr', 'docker_login_legacy', 'secret_get', and 'error' utilities.
#
# EXAMPLES
#
#    # The following usage examples demonstrate usage for all supported cases:
#
#    # Legacy registry
#    docker_login \
#      production_docker_registry_legacy_fqdn \
#      production_docker_registry_legacy_installer_username \
#      production_docker_registry_legacy_installer_password
#
#    # AWS ECR registry (with AWS secrets pre-set via environment)
#    docker_login \
#      production_docker_registry_aws_ecr_fqdn \
#      production_docker_registry_aws_ecr_region
#
#    # AWS ECR registry (with AWS secrets passed as arguments)
#    docker_login \
#      production_docker_registry_aws_ecr_fqdn \
#      production_docker_registry_aws_ecr_region \
#      production_docker_registry_aws_ecr_installer_aws_access_key_id \
#      production_docker_registry_aws_ecr_installer_aws_secret_access_key
#
# EXIT STATUS
#   0 - Login successful.
#   1 - Error occurred, such as wrong number of arguments, failure to retrieve secrets, or login failures.
#
###############################################################################
function docker_login {

  # Check dependencies
  local DEPENDENCIES="state_set docker_login_aws_ecr docker_login_legacy secret_get error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check number of arguments: must be either 2, 3 or 4
  if [ $# -ne 2 ] && [ $# -ne 3 ] && [ $# -ne 4 ]; then
    state_set "${FUNCNAME[0]}" 'error_wrong_number_of_arguments'
    return 1
  fi

  # Get arguments
  local FQDN="$1"

  # Get secrets
  FQDN=$( secret_get "${FQDN}" ) || { error "${FUNCNAME[0]}" 'failed_to_secret_get_fqdn'; return 1; }

  # Decide if we need docker_login_aws_ecr or docker_login_legacy
  # Check if FQDN ends with "amazonaws.com"
  if [[ ${FQDN} =~ amazonaws.com$ ]]; then
    # Match: use AWS ERC login functino
    docker_login_aws_ecr "${@}" || { error "${FUNCNAME[0]}" 'failed_to_docker_login_aws_ecr'; return 1; }

  else
    # No match found: use "legacy" login function
    docker_login_legacy "${@}" || { error "${FUNCNAME[0]}" 'failed_to_docker_login_legacy'; return 1; }
  fi
}
export -f docker_login

###############################################################################
# CATEGORY
#   AWS ECR LOGIN FUNCTIONS
#
# NAME
#   docker_login_aws_ecr - Logs in to an AWS Elastic Container Registry (ECR) with optional AWS credentials.
#
# SYNOPSIS
#   docker_login_aws_ecr FQDN REGION [AWS_ACCESS_KEY_ID] [AWS_SECRET_ACCESS_KEY]
#
# DESCRIPTION
#   Provides a mechanism for logging into AWS ECR by either using AWS credentials supplied as arguments
#   or by leveraging credentials set in the environment. This function supports two primary use cases:
#   1) Using AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables if AWS credentials are not
#      explicitly provided as arguments.
#   2) Directly using AWS credentials provided as arguments for situations where environment variables
#      are not set or different credentials are required for the login session.
#   It retrieves an authentication token using AWS CLI and uses it to perform docker login to the specified
#   ECR. This function is essential for automating Docker operations in AWS environments, ensuring secure
#   and authenticated access to ECR repositories.
#   Function sets state to indicate success or error code (because it is a complex multi-step function).
#
#   Basically this function supports 2 sets of arguments:
#     1) 2 arguments:
#            - production_docker_registry_aws_ecr_fqdn
#            - production_docker_registry_aws_ecr_region
#
#        This case requires the Amazon secrets alrady set via environment variables:
#          export AWS_ACCESS_KEY_ID=xxx
#          export AWS_SECRET_ACCESS_KEY=xxx
#
#     2) 4 arguments:
#          - production_docker_registry_aws_ecr_fqdn
#          - production_docker_registry_aws_ecr_region
#          - production_docker_registry_aws_ecr_installer_aws_access_key_id
#          - production_docker_registry_aws_ecr_installer_aws_secret_access_key
#
# DEPENDENCIES
#   This function depends on 'state_set', 'ensure_variable_not_empty', 'secret_get', 'docker', 'aws', and 'logger' utilities.
#
# EXAMPLES
#   # Login with environment variables
#   docker_login_aws_ecr "my-ecr-registry.amazonaws.com" "us-east-1"
#
#   # Login with credentials provided
#   docker_login_aws_ecr \
#     "my-ecr-registry.amazonaws.com" \
#     "us-east-1" \
#     "AKIAIOSFODNN7EXAMPLE" \
#     "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
#
# EXIT STATUS
#   0 - Successful login to AWS ECR.
#   1 - Error occurred, such as wrong number of arguments, missing dependencies, failure to retrieve AWS credentials,
#       failure to get the authentication token, or failure during the docker login process.
#
###############################################################################
function docker_login_aws_ecr {
  state_set "${FUNCNAME[0]}" 'started'

  # Check dependencies
  local DEPENDENCIES="state_set ensure_variable_not_empty secret_get docker aws logger"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check number of arguments: must be either 2 or 4
  if [ $# -ne 2 ] && [ $# -ne 4 ]; then
    echo "error_wrong_number_of_arguments: $# "
    state_set "${FUNCNAME[0]}" 'error_wrong_number_of_arguments'
    return 1
  fi

  # Get required arguments
  local FQDN="$1"
  local REGION="$2"

  # Check we got non-empty arguments
  # Define required variables
  local REQUIRED_VARIABLES=(
    FQDN
    REGION
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      # Dynamically generate an error_code, which include failed variable name (lowercase)
      local ERROR_CODE="$( echo "failed_to_ensure_variable_not_empty_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )"
      state_set "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Get secrets
  FQDN=$( secret_get "${FQDN}" ) || { state_set "${FUNCNAME[0]}" 'failed_to_secret_get_fqdn'; return 1; }
  REGION=$( secret_get "${REGION}" ) || { state_set "${FUNCNAME[0]}" 'failed_to_secret_get_region'; return 1; }

  # Get 2 optional arguments:
  #   - AWS_ACCESS_KEY_ID
  #   - AWS_SECRET_ACCESS_KEY
  # If arguments are missing, try to get secrets from environment.
  if [ $# -eq 4 ]; then

    # AWS secrets were provided as arguments: get arguments
    local SELECTED_AWS_ACCESS_KEY_ID="$3"
    local SELECTED_AWS_SECRET_ACCESS_KEY="$4"

    # Get secrets
    SELECTED_AWS_ACCESS_KEY_ID=$( secret_get "${SELECTED_AWS_ACCESS_KEY_ID}" ) || { state_set "${FUNCNAME[0]}" 'failed_to_secret_get_aws_access_key_id'; return 1; }
    SELECTED_AWS_SECRET_ACCESS_KEY=$( secret_get "${SELECTED_AWS_SECRET_ACCESS_KEY}" ) || { state_set "${FUNCNAME[0]}" 'failed_to_secret_get_aws_secret_access_key'; return 1; }

  else
    # AWS secrets were not provided as arguments.
    # Try to get them from environment or error out.
    [ ! -z "${AWS_ACCESS_KEY_ID}" ]     || { state_set "${FUNCNAME[0]}" 'failed_to_get_aws_access_key_id_from_environment'; return 1; }
    [ ! -z "${AWS_SECRET_ACCESS_KEY}" ] || { state_set "${FUNCNAME[0]}" 'failed_to_get_aws_secret_access_key_from_environment'; return 1; }
    local SELECTED_AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
    local SELECTED_AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
  fi

  # At this point both SELECTED_AWS_ACCESS_KEY_ID and SELECTED_AWS_SECRET_ACCESS_KEY must be non-empty strings
  [ ! -z "${SELECTED_AWS_ACCESS_KEY_ID}" ]     || { state_set "${FUNCNAME[0]}" 'failed_to_get_best_aws_access_key_id'; return 1; }
  [ ! -z "${SELECTED_AWS_SECRET_ACCESS_KEY}" ] || { state_set "${FUNCNAME[0]}" 'failed_to_get_best_aws_secret_access_key'; return 1; }

  # Retrieve an authentication token using the GetAuthorizationToken API
  local TOKEN=$(
    export AWS_ACCESS_KEY_ID="${SELECTED_AWS_ACCESS_KEY_ID}"
    export AWS_SECRET_ACCESS_KEY="${SELECTED_AWS_SECRET_ACCESS_KEY}"
    aws ecr get-login-password --region "${REGION}"
  ) || { state_set "${FUNCNAME[0]}" 'failed_to_get_token'; return 1; }

  # Check the token is not blank
  [ ! -z "${TOKEN}" ] || { state_set "${FUNCNAME[0]}" 'error_got_blank_token'; return 1; }

  # Actual "docker login"
  # Note: we use piped command here. The exit code of piped commands will be the one of the last command (docker login).
  # Note: we also collect the output.
  DOCKER_LOGIN_OUTPUT=$( \
    echo "${TOKEN}" \
    | docker login \
    --username AWS \
    --password-stdin "${FQDN}" \
    2>&1
  ) || { state_set "${FUNCNAME[0]}" 'failed_to_docker_login'; return 1; }

  # Send the "docker login" output to the logger with f-n name tag (simplifies debugging, audit, etc.)
  echo "${DOCKER_LOGIN_OUTPUT}" | logger -t "${FUNCNAME[0]}"

  state_set "${FUNCNAME[0]}" 'success'
}
export -f docker_login_aws_ecr

###############################################################################
# CATEGORY
#   LEGACY DOCKER REGISTRY LOGIN FUNCTIONS
#
# NAME
#   docker_login_legacy - Authenticates on a legacy Docker registry using credentials retrieved from secrets.
#
# SYNOPSIS
#   docker_login_legacy FQDN_SECRET_NAME USERNAME_SECRET_NAME PASSWORD_SECRET_NAME
#
# DESCRIPTION
#   This function facilitates Docker registry authentication by retrieving the fully qualified domain name (FQDN),
#   username, and password from named secrets. It is specifically designed for legacy Docker registries where
#   authentication credentials need to be securely stored and retrieved for login purposes. The function ensures
#   all necessary credentials are available and then executes the "docker login" command to authenticate against
#   the specified registry. It sets the state throughout its execution to provide detailed feedback on operation
#   status, which can be retrieved using "state_get docker_login_legacy" for error analysis.
#
# DEPENDENCIES
#   Relies on 'state_set', 'ensure_variable_not_empty', 'secret_get', 'docker', and 'logger' utilities.
#   Function sets state to indicate success or error code (because it is a complex multi-step function).
#
# EXAMPLES
#   docker_login_legacy \
#     "production_docker_registry_general_fqdn" \
#     "production_docker_registry_general_installer_username" \
#     "production_docker_registry_general_installer_password" || { error "${FUNCNAME[0]}" "Failed to authenticate"; exit 1; }
#
# EXIT STATUS
#   0 - Successful authentication with the Docker registry.
#   1 - Failure due to missing dependencies, incorrect number of arguments, retrieval errors for secrets, or
#       authentication failures.
#
#
###############################################################################
function docker_login_legacy {
  state_set "${FUNCNAME[0]}" 'started'

  # Check dependencies
  local DEPENDENCIES="state_set ensure_variable_not_empty secret_get docker logger"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check number of arguments: must be exactly 3
  [ $# -eq 3 ] || { state_set "${FUNCNAME[0]}" 'error_wrong_number_of_arguments'; return 1; }

  # Get arguments
  local FQDN="$1"
  local USERNAME="$2"
  local PASSWORD="$3"

  # Check we got non-empty arguments
  # Define required variables
  local REQUIRED_VARIABLES=(
    FQDN
    USERNAME
    PASSWORD
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      # Dynamically generate an error_code, which include failed variable name (lowercase)
      local ERROR_CODE="$( echo "failed_to_ensure_variable_not_empty_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )"
      state_set "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Retrieve actual values by "secret_get()"
  FQDN=$( secret_get "${FQDN}" ) || { state_set "${FUNCNAME[0]}" 'failed_to_secret_get_fqdn'; return 1; }
  USERNAME=$( secret_get "${USERNAME}" ) || { state_set "${FUNCNAME[0]}" 'failed_to_secret_get_username'; return 1; }
  PASSWORD=$( secret_get "${PASSWORD}" ) || { state_set "${FUNCNAME[0]}" 'failed_to_secret_get_password'; return 1; }

  # Check if we got non-empty values for container registry: FQDN, username and password
  # TODO: DRY violation: list attributes as array, iterate, check..
  [ ! -z ${FQDN} ] || { state_set "${FUNCNAME[0]}" 'error_got_empty_fqdn'; return 1; }
  [ ! -z ${USERNAME} ] || { state_set "${FUNCNAME[0]}" 'error_got_empty_username'; return 1; }
  [ ! -z ${PASSWORD} ] || { state_set "${FUNCNAME[0]}" 'error_got_empty_password'; return 1; }

  # Actual "docker login"
  # Note: we use piped command here. The exit code of piped commands will be the one of the last command (docker login).
  # Note: we also collect the output.
  DOCKER_LOGIN_OUTPUT=$( \
    echo "${PASSWORD}" \
    | docker login \
    --username "${USERNAME}" \
    --password-stdin "${FQDN}" \
    2>&1
  ) || { state_set "${FUNCNAME[0]}" 'failed_to_docker_login'; return 1; }

  # Send the "docker login" output to the logger with f-n name tag (simplifies debugging, audit, etc.)
  echo "${DOCKER_LOGIN_OUTPUT}" | logger -t "${FUNCNAME[0]}"

  state_set "${FUNCNAME[0]}" 'success'
}
export -f docker_login_legacy

###############################################################################
# CATEGORY
#   DOCKER VERSION MANAGEMENT FUNCTIONS
#
# NAME
#   docker_minimal_version_check - Checks if the installed Docker version meets a specified minimum major version requirement.
#
# SYNOPSIS
#   docker_minimal_version_check [MINIMUM_MAJOR_VERSION]
#
# DESCRIPTION
#   This function assesses the installed Docker version against a minimum major version requirement to ensure compatibility
#   and functionality. It accepts an optional argument specifying the minimum major version. If no argument is provided, it
#   defaults to using the version returned by docker_get_default_minimum_major_version(). The check includes verifying Docker's
#   installation status and comparing the installed version's major component with the minimum requirement. The function sets
#   state to indicate success or error code because it is a complex multi-step function.
#
# DEPENDENCIES
#   Requires 'state_set', 'docker_is_installed', 'docker_get_installed_version', 'semantic_version_parse', and
#   'docker_get_default_minimum_major_version' utilities.
#
# EXAMPLES
#   # Check if the installed Docker version meets the minimum required major version
#   docker_minimal_version_check "${MINIMUM_MAJOR_VERSION}" || { error "${FUNCNAME[0]}" "Docker version does not meet the minimum requirement."; return 1; }
#
# EXIT STATUS
#   0 - Installed Docker version meets or exceeds the specified minimum major version requirement.
#   1 - Docker is not installed, the installed version is below the minimum requirement, or other errors occurred.
#
###############################################################################
function docker_minimal_version_check {

  state_set "${FUNCNAME[0]}" 'started'

  # Check dependencies
  local DEPENDENCIES="state_set docker_is_installed docker_get_installed_version semantic_version_parse docker_get_default_minimum_major_version"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Take optional MINIMUM_MAJOR_VERSION argument, if empty, then set default value
  local MINIMUM_MAJOR_VERSION="${1}"
  if [ -z "${MINIMUM_MAJOR_VERSION}" ]; then
    # Use default value
    MINIMUM_MAJOR_VERSION=$( docker_get_default_minimum_major_version ) || { state_set "${FUNCNAME[0]}" "failed_to_get_default_minimum_version"; return 1; }
  fi

  # Check if docker is installed
  docker_is_installed || { state_set "${FUNCNAME[0]}" 'error_docker_is_not_installed'; return 1; }

  # Get full docker version (example: 23.0.1)
  local INSTALLED_VERSION
  INSTALLED_VERSION="$( docker_get_installed_version )" || { state_set "${FUNCNAME[0]}" "failed_to_get_installed_docker_version"; return 1; }

  # Extract major version component from docker version (example: 23)
  # Note the semantic_version_parse() checked its return value is not blank
  local INSTALLED_MAJOR_VERSION
  INSTALLED_MAJOR_VERSION=$( semantic_version_parse --major "${INSTALLED_VERSION}" ) || { state_set "${FUNCNAME[0]}" 'falied_to_extract_major_version'; return 1; }

  # Check we got non-empty values
  [ ! -z "${INSTALLED_MAJOR_VERSION}" ] || { state_set "${FUNCNAME[0]}" 'error_got_blank_major_version'; return 1; }
  [ ! -z "${MINIMUM_MAJOR_VERSION}" ] || { state_set "${FUNCNAME[0]}" 'error_got_blank_minimum_major_version'; return 1; }

  # Check if docker is installed and has major version >= minimally required
  if [ "${INSTALLED_MAJOR_VERSION}" -ge "${MINIMUM_MAJOR_VERSION}" ]; then
    state_set "${FUNCNAME[0]}" "success"
    return 0
  fi

  # Check didn't pass (installed version is less than minimally required)
  state_set "${FUNCNAME[0]}" 'error_minimal_version_check_did_not_pass'
  return 1
}
export -f docker_minimal_version_check

###############################################################################
# CATEGORY
#   CONTAINER MANAGEMENT FUNCTIONS
#
# NAME
#   docker_remove_all_containers - Removes all Docker containers.
#
# SYNOPSIS
#   docker_remove_all_containers
#
# DESCRIPTION
#   Facilitates the removal of all Docker containers from the system. This function first ensures
#   that all containers are stopped using docker_stop_all_containers before attempting removal.
#   It validates the presence of necessary commands and utilities to perform the operation, with
#   error handling to address potential failures during the stop or remove process. A postcondition
#   check ensures that no containers remain, verifying the success of the operation. This utility
#   is particularly useful for cleaning up all Docker containers in an environment, aiding in
#   system maintenance or preparation for a clean state.
#
# DEPENDENCIES
#   Requires 'command_exists', 'docker_stop_all_containers', 'docker', 'wc', 'ps', and 'error' utilities.
#
# EXAMPLES
#   # Remove all Docker containers from the system
#   docker_remove_all_containers
#   if [ $? -eq 0 ]; then
#       echo "All Docker containers have been successfully removed."
#   else
#       echo "Failed to remove all Docker containers."
#   fi
#
# EXIT STATUS
#   0 - All Docker containers successfully removed.
#   1 - Failure due to missing dependencies, inability to stop or remove containers, or postcondition check failure.
#
###############################################################################
function docker_remove_all_containers {

  # Check dependencies
  local DEPENDENCIES="command_exists docker_stop_all_containers docker wc ps error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Loop through dependencies
  for DEPENDENCY in "${DEPENDENCIES[@]}"; do
    if ! command_exists "${DEPENDENCY}" > /dev/null; then
      error "${FUNCNAME[0]}: error_dependency_not_met_${DEPENDENCY}"
      return 1
    fi
  done

  # Stop all containers
  docker_stop_all_containers || { error "${FUNCNAME[0]}: Failed to stop all containers"; return 1; }
  docker rm $(docker ps -aq) > /dev/null || { error "${FUNCNAME[0]}: Failed to remove all containers"; return 1; }

  # Postcondition check: all containers are removed
  local RUNNING_CONTAINERS_COUNT="$(docker ps -aq | wc -l)"
  [ "${RUNNING_CONTAINERS_COUNT}" -eq 0 ] || { error "${FUNCNAME[0]}: Postcondition check failed. Number of existing containers: ${RUNNING_CONTAINERS_COUNT} (expected: 0)"; return 1; }
}
export -f docker_remove_all_containers

###############################################################################
# CATEGORY
#   DOCKER SERVICE MANAGEMENT FUNCTIONS
#
# NAME
#   docker_restart - Restarts the Docker daemon.
#
# SYNOPSIS
#   docker_restart
#
# DESCRIPTION
#   Executes a restart of the Docker daemon to apply configuration changes or recover from an unstable state.
#   This function follows the recommended approach for managing the Docker service via systemd, as outlined in
#   the official Docker documentation. It checks for Docker's installation before attempting the restart to
#   ensure that the operation can proceed. The function employs 'sudo systemctl restart' for the daemon restart,
#   encapsulating this best practice within a utility function for ease of use. This action is critical for
#   maintaining or restoring the proper functioning of Docker services on systems using systemd.
#
# DEPENDENCIES
#   Requires 'docker_is_installed', 'sudo', 'systemctl', and 'error' utilities.
#
# EXAMPLES
#   # Restart the Docker daemon
#   docker_restart || { error "${FUNCNAME[0]}" "Failed to restart Docker daemon."; exit 1; }
#
# EXIT STATUS
#   0 - Docker daemon successfully restarted.
#   1 - Failure due to Docker not being installed or the restart command failing.
#
###############################################################################
function docker_restart {

  # Check dependencies
  local DEPENDENCIES="docker_is_installed sudo systemctl error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check if docker installed
  docker_is_installed || { error "${FUNCNAME[0]}" 'error_docker_is_not_installed'; return 1; }

  # Restart docker daemon
  sudo systemctl restart docker || { error "${FUNCNAME[0]}" 'failed_to_docker_restart'; return 1; }
}
export -f docker_restart

###############################################################################
# CATEGORY
#   CONTAINER MANAGEMENT FUNCTIONS
#
# NAME
#   docker_restart_containers - Restarts specified Docker containers by names or IDs.
#
# SYNOPSIS
#   docker_restart_containers CONTAINER_NAMES_OR_IDS...
#
# DESCRIPTION
#   Provides the functionality to restart one or more Docker containers identified by their names or IDs. This function
#   iterates through the provided list of container identifiers, checking each to ensure it exists before attempting a restart.
#   Only containers verified to exist are added to the restart queue. This targeted approach prevents unnecessary errors and
#   ensures that only specified, existing containers are restarted. It's a convenient utility for managing container states,
#   particularly in environments where selective container restarts are frequently needed.
#
# DEPENDENCIES
#   Requires 'docker_container_name_exists' and 'docker' utilities.
#
# EXAMPLES
#   # Restart multiple Docker containers by name or ID
#   docker_restart_containers "web_app" "db_service" || { echo "Failed to restart one or more specified Docker containers."; exit 1; }
#
# EXIT STATUS
#   0 - All specified, existing containers were successfully restarted.
#   1 - No containers were restarted due to being unspecified, non-existent, or errors during the restart process.
#
###############################################################################
function docker_restart_containers {

  # Check dependencies
  local DEPENDENCIES="docker_container_name_exists docker"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # if [ -z "${@}" ]; then
  #     error "${FUNCNAME[0]}: error_no_container_names_specified"
  #     return 2
  # fi
  local CONTAINERS=(${@})
  local CONTAINERS_TO_RESTART=()

  for CONTAINER in "${CONTAINERS[@]}"; do
    # We only restart a container if it is defined
    if docker_container_name_exists "${CONTAINER}"
    then
      CONTAINERS_TO_RESTART+=( ${CONTAINER} )
    fi
  done

  if (( ${#CONTAINERS_TO_RESTART[@]} )); then
    docker restart ${CONTAINERS_TO_RESTART[@]}
    return ${?}
  fi

  return 1
}
export -f docker_restart_containers

###############################################################################
# CATEGORY
#   DOCKER LOGGING CONFIGURATION FUNCTIONS
#
# NAME
#   docker_set_log_to_syslog - Configures Docker to log to syslog.
#
# SYNOPSIS
#   docker_set_log_to_syslog
#
# DESCRIPTION
#   Alters the Docker daemon's logging configuration to direct its output to syslog, using the JSON
#   configuration file method as the preferred option. This approach centralizes Docker's log management,
#   facilitating easier integration with system-wide log handling mechanisms. The function ensures Docker is
#   installed, verifies the existence of the Docker configuration directory, creates or overwrites the
#   daemon.json configuration file to set syslog as the log driver, and restarts the Docker daemon to apply
#   the changes. It sets state to indicate success or error code because it is a complex multi-step function.
#
#   See official docker configuration man pages:
#     https://docs.docker.com/config/daemon/
#
#   (quote)
#     Configure the Docker daemon
#     There are two ways to configure the Docker daemon:
#
#       1) Use a JSON configuration file. This is the preferred option, since it keeps all configurations in a single place.
#       2) Use flags when starting dockerd.
#
#     You can use both of these options together as long as you dont specify the same option both as a flag and in the JSON file. If that happens, the Docker daemon wont start and prints an error message.
#   (end of quote)
#
# DEPENDENCIES
#   Requires 'docker_is_installed', 'sudo', 'tee', 'error', 'state_set', and 'docker_restart' utilities.
#
# EXAMPLES
#   # Configure Docker to use syslog for logging
#   docker_set_log_to_syslog || { echo "Failed to set Docker to log to syslog."; exit 1; }
#
# EXIT STATUS
#   0 - Docker successfully configured to log to syslog and daemon restarted.
#   1 - Failure due to missing dependencies, Docker not installed, configuration directory missing, errors in
#       writing the configuration file, or failure to restart the Docker daemon.
#
###############################################################################
function docker_set_log_to_syslog {
  state_set "${FUNCNAME[0]}" 'started'

  # Check dependencies
  local DEPENDENCIES="docker_is_installed sudo tee error state_set docker_restart"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || { state_set "${FUNCNAME[0]}" 'error_check_dependencies'; return 1; }

  # Check if docker installed
  docker_is_installed || { state_set "${FUNCNAME[0]}" 'error_docker_is_not_installed'; return 1; }

  # Check if docker configuration directory exists
  local DOCKER_CONFIGURATION_PATH="/etc/docker"
  if [ ! -d "${DOCKER_CONFIGURATION_PATH}" ]; then
    # Error: docker configuration directory does not exist
    state_set "${FUNCNAME[0]}" 'error_docker_configuration_directory_does_not_exist'
    return 1
  fi

  # Create docker configuration file (or overwrite existing)
  local FILEPATH="${DOCKER_CONFIGURATION_PATH}/daemon.json"
  (
cat <<EOT
{
  "log-driver": "syslog",
  "log-opts": {"tag": "{{.Name}}/{{.ID}}"}
}
EOT
  ) | sudo tee ${FILEPATH} > /dev/null

  # Check exit code
  # Note: when $? used for piped commands it returns the exit code of the last commain in chain
  if [ "${?}" -ne 0 ]; then
    state_set "${FUNCNAME[0]}" "failed_to_docker_install_logging_configuration"
    return 1
  fi

  # Restart docker daemon after configuration change
  docker_restart || { state_set "${FUNCNAME[0]}" 'failed_to_docker_restart'; return 1; }

  state_set "${FUNCNAME[0]}" 'success'
}
export -f docker_set_log_to_syslog

###############################################################################
# CATEGORY
#   CONTAINER MANAGEMENT FUNCTIONS
#
# NAME
#   docker_stop_all_containers - Stops all running Docker containers.
#
# SYNOPSIS
#   docker_stop_all_containers
#
# DESCRIPTION
#   Executes a command to stop all currently running Docker containers on the system. This function is
#   particularly useful for quickly halting all container activities, whether for system maintenance,
#   performance recovery, or preparation for a clean slate before deploying new containers. It performs
#   a pre-action check to ensure the necessary dependencies are available, then proceeds to stop all
#   containers. A post-action verification step ensures that no containers remain running, confirming the
#   successful execution of the command.
#
# DEPENDENCIES
#   Requires 'docker', 'wc', and 'error' utilities to perform the stop operation and validate action success.
#
# EXAMPLES
#   # Stop all Docker containers
#   docker_stop_all_containers || { error "Failed to stop all containers."; return 1; }
#
# EXIT STATUS
#   0 - All running containers successfully stopped.
#   1 - Failure to stop all containers or postcondition check failure indicating running containers remain.
#
###############################################################################
function docker_stop_all_containers {

  # Check dependencies
  local DEPENDENCIES="docker wc error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Stop all containers
  docker stop $(docker ps -aq) > /dev/null || { error "${FUNCNAME[0]}: Failed to stop all containers"; return 1; }

  # Postcondition check: all containers are stopped
  local RUNNING_CONTAINERS_COUNT="$(docker ps -q | wc -l)"
  [ "${RUNNING_CONTAINERS_COUNT}" -eq 0 ] || { error "${FUNCNAME[0]}: Postcondition check failed. Number of running containers: ${RUNNING_CONTAINERS_COUNT} (expected: 0)"; return 1; }
}
export -f docker_stop_all_containers


###############################################################################
# CATEGORY
#   CONTAINER MANAGEMENT FUNCTIONS
#
# NAME
#   docker_stop_and_remove_container_by_name - Stops and removes Docker containers matching a specified name or ID pattern.
#
# SYNOPSIS
#   docker_stop_and_remove_container_by_name CONTAINER_IDENTIFIER
#
# DESCRIPTION
#   This function identifies Docker containers that match a given name or ID (even partially) and proceeds to stop
#   and remove each of them. It handles cases where containers might be in various states, including stopped or
#   potentially unresponsive/broken states. In cases where a container cannot be stopped or removed through normal
#   Docker commands, it attempts a more forceful approach by terminating the underlying host process associated
#   with the container before removing it. This ensures that even containers that are stuck or in a broken state
#   can be cleaned up effectively. The function sets clear expectations for argument presence, ensuring that
#   it does not proceed with blank inputs.
#
# DEPENDENCIES
#   Requires 'docker', 'error', 'grep', 'sudo', 'kill', 'awk', and 'wc' utilities to identify, stop, and remove containers.
#
# EXAMPLES
#   # Stop and remove all containers matching a partial name
#   docker_stop_and_remove_container_by_name "my_app" || { error "Failed to stop and remove containers."; return 1; }
#
# EXIT STATUS
#   0 - Successfully stopped and removed all matching containers.
#   1 - Failure due to missing dependencies, invalid arguments, or errors in stopping/removing containers.
#
###############################################################################
function docker_stop_and_remove_container_by_name {

  # Check dependencies
  local DEPENDENCIES="docker error grep sudo kill awk wc"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  local CONTAINER_IDENTIFIER="${1}"

  # Check the container name isn't blank
  [ -n "${CONTAINER_IDENTIFIER}" ] || { error "${FUNCNAME[0]}" 'error_bad_arguments'; return 1; }

  # Count existing container(s) by given docker name
  local FOUND_CONTAINERS_COUNT
  FOUND_CONTAINERS_COUNT=$( docker ps -a | grep "${CONTAINER_IDENTIFIER}" | wc -l )

  # Check if we found >1
  if [ ${FOUND_CONTAINERS_COUNT} -gt 1 ]; then
    # Yes, we found >1 containers to stop/remove
    for DOCKER_ID in $(docker ps -a | grep "${CONTAINER_IDENTIFIER}" | awk '{print $1}'); do
      # Make sure DOCKER_ID is not a blank string
      if [ "${DOCKER_ID}" == "" ]; then
        error "${FUNCNAME[0]}" 'failed_to_get_docker_id'
        return 1
      fi

      # Try to stop and remove the container
      docker stop "${DOCKER_ID}"
      docker rm "${DOCKER_ID}"

      # Sometimes container can be in the broken state, in this case even after stopping and removing it
      # the DOCKER_ID is still visible in the "docker ps" list. In this cas we need to kill -9 corresponding
      # process on the host level:
      local STILL_PRESENT_DOCKER_ID
      STILL_PRESENT_DOCKER_ID=$( docker ps -a | grep "${DOCKER_ID}" | wc -l )
      if [ -n "${STILL_PRESENT_DOCKER_ID}" ]; then
        # Yes, we have found "unstoppable" docker. Kill -9 the corresponding process now
        local PID_TO_KILL_COUNT
        PID_TO_KILL_COUNT=$( sudo ps aux | grep "${DOCKER_ID}" | wc -l )
        local PID_TO_KILL
        PID_TO_KILL=$( sudo ps aux | grep "${DOCKER_ID}" )
        if [ ${PID_TO_KILL_COUNT} -ne 1 ]; then
          # Something went wrong, we supposed to find exactly ONE pid to terminate.
          error "${FUNCNAME[0]}" 'failed_to_get_docker_pid'
          return 1
        fi

        # Send "SIGKILL" signal to the found process
        sudo kill -9 "${PID_TO_KILL}" || { error "${FUNCNAME[0]}" 'error_killing_process'; return 1; }

        # The "unstoppable" docker terminated, now we can safely remove the container
        docker rm "${DOCKER_ID}" || { error "${FUNCNAME[0]}" 'error_removing_docker'; return 1; }
      fi
    done

  fi
}
export -f docker_stop_and_remove_container_by_name

###############################################################################
# CATEGORY
#   CONTAINER MANAGEMENT FUNCTIONS
#
# NAME
#   docker_stop_container_by_name - Stops Docker containers matching a specified name pattern.
#
# SYNOPSIS
#   docker_stop_container_by_name CONTAINER_IDENTIFIER
#
# DESCRIPTION
#   Targets and stops Docker containers that match a specified name or partial name pattern, regardless of their current state.
#   It iteratively identifies matching containers, then proceeds to stop each, ensuring that containers are gracefully halted.
#   This function is particularly useful for managing container instances systematically based on naming conventions or patterns,
#   facilitating bulk container operations. It's designed to ensure action only on specified, existent containers, with error
#   handling for various potential issues such as blank input or failure to identify container IDs.
#
# DEPENDENCIES
#   Requires 'docker', 'grep', 'awk', 'wc', and 'error' utilities to identify and stop the targeted containers.
#
# EXAMPLES
#   # Stop all containers with a name containing "control_fron"
#   docker_stop_container_by_name "control_fron" || { error "Failed to stop containers."; return 1; }
#
# EXIT STATUS
#   0 - Successfully stopped all matching containers.
#   1 - Failure due to missing dependencies, invalid arguments, or errors in stopping containers.
#
###############################################################################
function docker_stop_container_by_name {

  # Check dependencies
  local DEPENDENCIES="docker grep awk wc error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Get arguments
  local CONTAINER_IDENTIFIER="${1}"

  # Check the container name isn't blank
  [ -n "${CONTAINER_IDENTIFIER}" ] || { error "${FUNCNAME[0]}" 'error_bad_arguments'; return 1; }

  # Count existing container(s) by given docker name
  local FOUND_CONTAINERS_COUNT
  FOUND_CONTAINERS_COUNT=$( docker ps -a | grep "${CONTAINER_IDENTIFIER}" | wc -l )

  # Check if we have at least 1 container by given name (or simply return success)
  [ ${FOUND_CONTAINERS_COUNT} -gt 0 ] || return 0; # Nothing is running, reutnurn success

  # Yes, we found >1 containers
  for DOCKER_ID in $(docker ps -a | grep "${CONTAINER_IDENTIFIER}" | awk '{print $1}'); do
    # Make sure DOCKER_ID is not a blank string
    [ -n "${DOCKER_ID}" ] || { error "${FUNCNAME[0]}" 'failed_to_get_docker_id'; return 1; }

    # Try to stop the container
    docker stop "${DOCKER_ID}"
  done
}
export -f docker_stop_container_by_name


###############################################################################
# Category: container
# Utility function - Get list of volumes and print list of containers, which use them.
#
# TODO: improve it to also show the size of each volume by combining output from "docker system df --verbose"
#
function docker_volumes_to_containers_list {

  # Check dependencies
  local DEPENDENCIES="docker error sed"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Get list of all docker volumes names
  VOLUMES=$(docker volume ls  --format '{{.Name}}') || { error "${FUNCNAME[0]}" 'failed_to_list_docker_volumes'; return 1; }

  # Iterate all volumes and check if i-th volume is used by any container (even if container is stopped)
  for VOLUME in ${VOLUMES}; do

    # Simply print volume identifier
    echo "${VOLUME}"

    # Note: the following command will print associated container names prefixed with 2 spaces
    docker ps -a --filter volume="${VOLUME}"  --format '{{.Names}}' | sed 's/^/  /'
  done
}
export -f docker_volumes_to_containers_list

### END UTILITY FUNCTIONS: DOCKERS
