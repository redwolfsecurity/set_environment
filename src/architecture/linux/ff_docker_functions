### BEGIN UTILITY FUNCTIONS: CONTAINERS

# Note: for more details on the "docker_ensure" functions family
# see Jira ticket: "Plan "docker_ensure()" family of functions": https://redoki.atlassian.net/browse/REX-894
#

# Table of contents (generated by: file_toc src/architecture/linux/ff_docker_functions)
## BEGIN UTILITY FUNCTIONS: CONTAINERS
#    - docker_cleanup 
#    - docker_container_name_exists 
#    - docker_ensure 
#    - docker_ensure_log_to_syslog 
#    - docker_get_default_minimum_major_version 
#    - docker_get_installed_version 
#    - docker_install 
#    - docker_is_container_healthy 
#    - docker_is_container_log_to_syslog 
#    - docker_is_container_running 
#    - docker_is_every_container_log_to_syslog 
#    - docker_is_installed 
#    - docker_is_log_to_syslog 
#    - docker_login 
#    - docker_login_aws_ecr 
#    - docker_login_legacy 
#    - docker_minimal_version_check 
#    - docker_restart 
#    - docker_restart_containers 
#    - docker_set_log_to_syslog 
#    - docker_stop_and_remove_container_by_name 
#    - docker_volumes_to_containers_list 
## END UTILITY FUNCTIONS: DOCKERS

###############################################################################
# Category: container
# Utility function - Remove all unused containers, networks, images (both dangling and unreferenced)
#
# Function return code 0 on success, 1 on error (example: not enough permissions)
#
# Note: function also prints result to the standard output. 
# Example: 
#    Total reclaimed space: 0B
#
# TODO: And in that new function please add an error check. It is possible the docker system prune --al --force won't always work.
# On some systems we might need to be root to run that command, so we will need to build out more robust docker functions that
# might try one way vs. another and properly track what's going on.
#
function docker_cleanup {
  set_state "${FUNCNAME[0]}" 'started'

  # Cleanup some space
  # docker system prune: Remove all unused containers, networks, images (both dangling and unreferenced), and optionally, volumes if --volumes used.
  # Note: adding --volumes might be risky since it will erase DATA from stopped containers.
  # More details: https://docs.docker.com/engine/reference/commandline/system_prune/
  docker system prune --all --force || { set_state "${FUNCNAME[0]}" 'failed_to_docker_cleanup'; return 1; }

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f docker_cleanup

###############################################################################
# Category: container
# Utility function - Check if container exists
#
# Usage example:
#    if docker_container_name_exists "some_container_name"; then
#       # Yes, container by given name does exist.
#    else
#       # No such container found
#    fi
#
function docker_container_name_exists {
  
  CONTAINER_NAME="${1}"
  # -z - true if the length of string is zero
  # -n - true if the length of string is nonzero
  if [ -z "${CONTAINER_NAME}" ]; then
      error "error_no_container_name_specified"
      return 2
  fi

  CONTAINER_ID=$(docker inspect --format="{{.Id}}" ${CONTAINER_NAME} 2> /dev/null)
  if [[ "${CONTAINER_ID}" ]]; then
    return 0
  else
    return 1
  fi
}
export -f docker_container_name_exists

###############################################################################
#
# Main entry point to make sure we have docker installed (of expected minimal major version)
# and logging driver is set to syslog.
#
function docker_ensure {
  set_state "${FUNCNAME[0]}" 'started'

  # Check if docker is already installed
  if ! docker_is_installed; then
    # Docker is not installed. Install it now.
    docker_install || { set_state "${FUNCNAME[0]}" 'failed_to_docker_install'; return 1; }
  fi
  
  # Do the docker_minimal_version_check
  if ! docker_minimal_version_check "${MINIMUM_MAJOR_VERSION}"; then
    # Docker does not have expected version. Install proper version now.
    docker_install || { set_state "${FUNCNAME[0]}" 'failed_to_docker_install'; return 1; }
  fi
  
  # Ensure docker logs sent to syslog
  docker_ensure_log_to_syslog || { set_state "${FUNCNAME[0]}" 'failed_to_docker_ensure_log_to_syslog'; return 1; }

  set_state "${FUNCNAME[0]}" 'success'
}
export -f docker_ensure

###############################################################################
#
# Function checks if currently installed docker daemon logs to syslog and if not,
# then it overwrites docker daemon configuration and restarts it.
# Function has no argumetns.
# Function set state.
#
function docker_ensure_log_to_syslog {
  set_state "${FUNCNAME[0]}" 'started'

  # Check if docker logs to syslog
  if ! docker_is_log_to_syslog; then
    # No, docker logs somewhere else. Reconfigure docker daemon.
    docker_set_log_to_syslog || { set_state "${FUNCNAME[0]}" 'failed_to_docker_set_log_to_syslog'; return 1; }

    # And restart daemon
    docker_restart || { set_state "${FUNCNAME[0]}" 'failed_to_docker_restart'; return 1; }
  fi

  set_state "${FUNCNAME[0]}" 'success'
}
export -f docker_ensure_log_to_syslog

###############################################################################
# Function is part of docker_ensure functions family. It prints the minimully
# required docker version.
function docker_get_default_minimum_major_version {
  set_state "${FUNCNAME[0]}" 'started'
  echo 23
  set_state "${FUNCNAME[0]}" 'success'
}
export -f docker_get_default_minimum_major_version

###############################################################################
#
# Function prints installed docker version to standard output
# or set error state if docker not found.
#
function docker_get_installed_version {
  set_state "${FUNCNAME[0]}" 'started'

  # Check installed version
  #   Official docker documentation: how to get version: https://docs.docker.com/engine/reference/commandline/version/
  INSTALLED_VERSION="$( docker version --format '{{.Server.Version}}' )" || { set_state "${FUNCNAME[0]}" 'failed_to_get_installed_version_number'; return 1; }
  
  # Check exit code
  [ "${?}" -eq 0 ] || { set_state "${FUNCNAME[0]}" "failed_to_get_docker_version"; return 1; }

  # Check we got non-empty version output from docker
  [ ! -z "${INSTALLED_VERSION}" ] || { set_state "${FUNCNAME[0]}" "error_got_blank_docker_version"; return 1; }

  # Print result to standard output
  echo "${INSTALLED_VERSION}"

  set_state "${FUNCNAME[0]}" 'success'
}
export -f docker_get_installed_version

###############################################################################
#
# Function installs docker. It takes 1 optional argement "minimum major version", if not provided,
# then by default the major version returned by docker_get_default_minimum_major_version() will be used.
#
# Supports Ubuntu 16.04, 18.04, 20.04
#
# Require environment variables set:
#   - FF_AGENT_USERNAME
#
function docker_install {

  set_state "${FUNCNAME[0]}" 'started'

  # Define required variables
  local REQUIRED_VARIABLES=(
    FF_AGENT_USERNAME
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      # Dynamically generate an error_code, which include failed variable name (lowercase)
      local ERROR_CODE="$( echo "failed_to_ensure_variable_not_empty_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Take optional MINIMUM_MAJOR_VERSION argument, if empty, then set default value
  local MINIMUM_MAJOR_VERSION="${1}"
  if [ -z "${MINIMUM_MAJOR_VERSION}" ]; then
      # Use default value
      MINIMUM_MAJOR_VERSION=$( docker_get_default_minimum_major_version ) || { set_state "${FUNCNAME[0]}" "failed_to_get_default_minimum_version"; return 1; }
  fi

  # Do the docker_minimal_version_check
  if docker_minimal_version_check "${MINIMUM_MAJOR_VERSION}"; then
    # Installed version passed the minimal version check, no need to install
    set_state "${FUNCNAME[0]}" "no_action_already_installed"
    return 0
  fi

  # OK We install since we don't have the minimum version, or docker is not installed

  # Get ID, RELEASE and DISTRO and verify the values are actually set
  local LSB_ID=$( get_lsb_id ) || { set_state "${FUNCNAME[0]}" "failed_to_get_lsb_id"; return 1; } # Ubuntu
  [ "${LSB_ID}" == "" ] && { set_state "${FUNCNAME[0]}" "failed_to_get_lsb_id"; return 1; } # Ubuntu

  local RELEASE=$( get_lsb_release ) || { set_state "${FUNCNAME[0]}" "failed_to_get_lsb_release"; return 1; }  # 18.04, 20.04, ...
  [ "${RELEASE}" == "" ] && { set_state "${FUNCNAME[0]}" "failed_to_get_lsb_release"; return 1; }

  local DISTRO=$( get_lsb_codename ) || { set_state "${FUNCNAME[0]}" "failed_to_get_lsb_codename"; return 1; }  # bionic, focal, ...
  [ "${DISTRO}" == "" ] && { set_state "${FUNCNAME[0]}" "failed_to_get_lsb_codename"; return 1; }

  local ARCHITECTURE=$( get_hardware_architecture ) || { set_state "${FUNCNAME[0]}" "error_getting_hardware_architecture"; return 1; }

  # Only Ubuntu for now
  if [ "${LSB_ID}" != "Ubuntu" ]; then
      set_state "${FUNCNAME[0]}" "error_docker_install_unsupported_operating_system"
      return 1
  fi

  # TODO: We might not have sudo, so we should request command to be run.
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
  [ ${?} -ne 0 ] && { set_state "${FUNCNAME[0]}" "failed_to_add_gpg_key"; return 1; }

  # TODO: We might not have sudo, so we should request command to be run.
  sudo add-apt-repository "deb [arch=${ARCHITECTURE}] https://download.docker.com/linux/ubuntu ${DISTRO} stable"
  [ ${?} -ne 0 ] && { set_state "${FUNCNAME[0]}" "failed_to_add_repository"; return 1; }

  apt_update

  # Define required pagage names
  local PACKAGES=(
    docker-ce
    docker-ce-cli
    docker-compose
    
    # The containerd is available as a daemon for Linux and Windows.
    # It manages the complete container lifecycle of its host system,
    # from image transfer and storage to container execution and supervision
    # to low-level storage to network attachments and beyond.
    containerd.io
  )

  # Install required packages
  for PACKAGE in "${PACKAGES[@]}"; do
    apt_install "${PACKAGE}" || { 
      local ERROR_CODE="$( echo "failed_to_install_package_${PACKAGE}" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]' )"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Add ourselves as a user to be able to run docker
  GROUP="docker"
  # Check the 'docker' group exists.
  if ! check_group_exists "${GROUP}"; then
    set_state "${FUNCNAME[0]}" "error_group_docker_does_not_exist"
    return 1
  fi

  # TODO: We might not have sudo, so we should request command to be run.
  # Check if user is in this group. If not, add them
  if ! is_user_in_group "${FF_AGENT_USERNAME}" "${GROUP}"; then
    # Not in group
    sudo usermod -aG "${GROUP}" "${FF_AGENT_USERNAME}"
    if [ ${?} -ne 0 ]; then set_state "${FUNCNAME[0]}" "failed_to_modify_docker_user_group"; return 1; fi
    # Now check that we actually are in the group. This will work in current shell because it reads the groups file directly
    if ! is_user_in_group "${FF_AGENT_USERNAME}" "${GROUP}"; then
      set_state "${FUNCNAME[0]}" "failed_postcondition_user_in_group"
      return 1
    fi
  fi

  # Postcondition checks
  # Verify docker is properly set up
  # Note we are running via sudo, and if we added user to the ${GROUP} then it won't be applied in this shell.
  set_secret docker_release "$( docker --version )" || { set_state "${FUNCNAME[0]}" "failed_to_run_docker_to_get_release"; return 1; }
  set_secret docker_compose_relase "$( docker-compose --version )" || { set_state "${FUNCNAME[0]}" "failed_to_run_docker_compose_to_get_release"; return 1; }

  # Check if installed docker version is less than minimally required
  # Do the docker_minimal_version_check
  if ! docker_minimal_version_check "${MINIMUM_MAJOR_VERSION}"; then
    # Error: installed version did not pass the minimal version check
    set_state "${FUNCNAME[0]}" "failed_postcondition_docker_minimal_version_check"
    return 1
  fi
  
  # Set up docker daemon logging (log to syslog)
  docker_set_log_to_syslog || { set_state "${FUNCNAME[0]}" "failed_to_docker_set_log_to_syslog"; return 1; }
  
  set_state "${FUNCNAME[0]}" 'success'
}
export -f docker_install

###############################################################################
# Category: container
# Utility function - Check if docker container healthy or not. This checks if the container is actually in the state 'running' vs. restarting
function docker_is_container_healthy {
    CONTAINER_NAME="${1}"

    # -z - true if the length of string is zero
    # -n - true if the length of string is nonzero
    if [ -z "${CONTAINER_NAME}" ]; then
        error "error_no_container_name_specified"
        return 2
    fi
    if [ "$( docker container inspect -f '{{.State.Status}}' ${CONTAINER_NAME} )" == "running" ]; then
        return 0
    else
        return 1
    fi
}
export -f docker_is_container_healthy

###############################################################################
#
# Function checks a single existing container (by given container ID or name)
# log configuration. Usually container logs to file or to syslog.
#
# Function takes 1 argument: container ID or container Name.
#
# Return code:
#   0 - yes, container is configured to log to syslog
#   1 - no, container does not send logs to syslog
#
# Usage examples:
#    docker_is_container_log_to_syslog abcdefa021da
#    docker_is_container_log_to_syslog mongo
#
function docker_is_container_log_to_syslog {
  
  set_state "${FUNCNAME[0]}" 'started'

  # Check number of arguments: must be exactly 1
  [ $# -eq 1 ] || { set_state "${FUNCNAME[0]}" 'error_wrong_number_of_arguments'; return 1; }
  
  # Take argument (container ID or name)
  local CONTAINER_IDENTIFIER="${1}"

  # Check if docker installed
  docker_is_installed || { set_state "${FUNCNAME[0]}" 'error_docker_is_not_installed'; return 1; }

  # Check such container exists
  local MATCHING_CONTAINERS_NUMBER=$( docker ps -a  )

  # Define expected logging driver
  local EXPECTED_LOGGING_DRIVER="syslog"

  # Get actually configured logging driver
  local ACTUAL_LOGGING_DRIVER=$( docker inspect -f '{{.HostConfig.LogConfig.Type}}' "${CONTAINER_IDENTIFIER}" ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_docker_log_config_type'; return 1; }
  # Note: Same can be extracted using "jq":
  # local ACTUAL_LOGGING_DRIVER=$( docker inspect "${CONTAINER_IDENTIFIER}" | jq --raw-output .[].HostConfig.LogConfig.Type ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_docker_log_config_type'; return 1; }

  # Compare actual vs. expected
  if [ "${ACTUAL_LOGGING_DRIVER}" != "${EXPECTED_LOGGING_DRIVER}" ]; then
    # Mismatch: docker has some unexpected logging driver
    set_state "${FUNCNAME[0]}" 'error_unexpected_logging_driver'
    return 1
  fi

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f docker_is_container_log_to_syslog

###############################################################################
# Category: container
# Utility function - Check if docker container running by given container name.
# This checks if it is running, but it could be in a 'restart' loop.
#
# Return code:
#   0 - container is running
#   1 - container is not running
#   2 - error: missing argument
#
function docker_is_container_running {

    # Take argument, check it is not empty
    CONTAINER_NAME="${1}"
    [ ! -z "${CONTAINER_NAME}" ] || { error "error_no_container_name_specified"; return 2; }

    # Inspect given container, make sure it is in ranning state
    if [ "$( docker container inspect -f '{{.State.Running}}' ${CONTAINER_NAME} )" == "true" ]; then
        return 0
    else
        return 1
    fi
}
export -f docker_is_container_running

###############################################################################
#
# Function docker_is_every_container_log_to_syslog() calls docker_is_container_log_to_syslog()
# against each running container and return success only if all of present containers 
# configured to log to syslog.
#
function docker_is_every_container_log_to_syslog {
  set_state "${FUNCNAME[0]}" 'started'

  # Check if docker installed
  docker_is_installed || { set_state "${FUNCNAME[0]}" 'error_docker_is_not_installed'; return 1; }

  # Get list of running container names
  local CONTAINERS=$(docker ps | awk '{if(NR>1) print $NF}') || { set_state "${FUNCNAME[0]}" 'failed_to_get_continers_list'; return 1; }

  # Iterate running containers and check docker_is_container_log_to_syslog() on each
  for CONTAINER in $CONTAINERS; do
    docker_is_container_log_to_syslog "${CONTAINER}" || { set_state "${FUNCNAME[0]}" 'error_found_container_not_logging_to_syslog'; return 1; }
  done

  set_state "${FUNCNAME[0]}" 'success'
}
export -f docker_is_every_container_log_to_syslog

###############################################################################
#
# Function docker_is_installed() checks the presence of "docker" command in the PATH
# and return code 0 on success (docker found) or other code otherwise.
#
# Usage example:
#   docker_is_installed || { set_state "${FUNCNAME[0]}" 'error_docker_is_not_installed'; return 1; }
#
# [Q] Best practice to return values and errors in ff_bash_functions:
# All our "set_environment" functions in family "is_xxx()" return 0 or 1, but also
# need to return an error. If we, for example, query "apt" on presence of certain
# package, but "apt" is not installed (or broken in some way), then our "is_abc_installed()"
# should have 3 supported outcomes:
#   - yes
#   - no
#   - error (failed to check)   <-- we don't support this
#
# So then after "is_installed" check we'd come up with wrong conclusion "not installed"
# and might try to start installing it, which is wrong.. and we lost the root cause of the problem.
#
function docker_is_installed {
  set_state "${FUNCNAME[0]}" 'started'
  
  # If it not installed, set STATUS=1
  command_exists docker >/dev/null
  local STATUS=${?}

  set_state "${FUNCNAME[0]}" 'success'
  return ${STATUS}
}
export -f docker_is_installed

###############################################################################
#
# Function docker_is_log_to_syslog() checks if the currently running docker
# is configured to log to syslog.
# Return code:
#   0 - yes, configured to send logs to syslog
#   1 - no, configured to send logs to somewhere else
#
function docker_is_log_to_syslog {
  set_state "${FUNCNAME[0]}" 'started'

  # Check if docker installed
  docker_is_installed || { set_state "${FUNCNAME[0]}" 'error_docker_is_not_installed'; return 1; }

  # Define expected logging driver
  local EXPECTED_LOGGING_DRIVER="syslog"

  # Get actually configured logging driver
  local ACTUAL_LOGGING_DRIVER=$( docker info --format '{{.LoggingDriver}}' ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_docker_logging_driver'; return 1; }

  # Compare actual vs. expected
  if [ "${ACTUAL_LOGGING_DRIVER}" != "${EXPECTED_LOGGING_DRIVER}" ]; then
    # Mismatch: docker has some unexpected logging driver
    set_state "${FUNCNAME[0]}" 'error_unexpected_logging_driver'
    return 1
  fi

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f docker_is_log_to_syslog

###############################################################################
#
# Function docker_login() takes 1-3 arguments and login to container repository.
# It supports 2 cases:
#   1) "legacy" repositories (requres 3 arguments: FQDN, username and password)
#   2) AWS ECR (require: FQDN + Amazon secrets)
#
# Note: for the AWS ECR there can be 2 or 4 arguments used:
#   1) only 1 argument: FQDN and the Amazon secrets alrady set via environment variables:
#        export AWS_ACCESS_KEY_ID=xxx
#        export AWS_SECRET_ACCESS_KEY=xxx
#   2) 3 arguments: FQDN, aws_access_key_id and aws_secret_access_key
#
# Usage examples for all supported cases:
#
#    # Legacy registry
#    docker_login \
#      production_docker_registry_legacy_fqdn \
#      production_docker_registry_legacy_installer_username \
#      production_docker_registry_legacy_installer_password
#
#    # AWS ECR registry (with AWS secrets pre-set via environment)
#    docker_login \
#      production_docker_registry_aws_ecr_fqdn \
#      production_docker_registry_aws_ecr_region
#
#    # AWS ECR registry (with AWS secrets passed as arguments)
#    docker_login \
#      production_docker_registry_aws_ecr_fqdn \
#      production_docker_registry_aws_ecr_region \
#      production_docker_registry_aws_ecr_installer_aws_access_key_id \
#      production_docker_registry_aws_ecr_installer_aws_secret_access_key
#
function docker_login {
  set_state "${FUNCNAME[0]}" 'started'

  # Check number of arguments: must be either 2, 3 or 4
  if [ $# -ne 2 ] && [ $# -ne 3 ] && [ $# -ne 4 ]; then
    set_state "${FUNCNAME[0]}" 'error_wrong_number_of_arguments'
    return 1
  fi

  # Get required argument
  local FQDN="$1"

  # Get secrets
  FQDN=$( get_secret "${FQDN}" ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_secret_fqdn'; return 1; }

  # Decide if we need docker_login_aws_ecr or docker_login_legacy
  # Check if FQDN ends with "amazonaws.com"
  if [[ ${FQDN} =~ amazonaws.com$ ]]; then
    # Match: use AWS ERC login functino
    docker_login_aws_ecr "${@}" || { set_state "${FUNCNAME[0]}" 'failed_to_docker_login_aws_ecr'; return 1; }

  else
    # No match found: use "legacy" login function
    docker_login_legacy "${@}" || { set_state "${FUNCNAME[0]}" 'failed_to_docker_login_legacy'; return 1; }
  fi

  set_state "${FUNCNAME[0]}" 'success'
}
export -f docker_login

###############################################################################
#
# Function supports 2 sets of arguments:
#   1) 2 arguments:
#          - production_docker_registry_aws_ecr_fqdn
#          - production_docker_registry_aws_ecr_region
#
#      This case requires the Amazon secrets alrady set via environment variables:
#        export AWS_ACCESS_KEY_ID=xxx
#        export AWS_SECRET_ACCESS_KEY=xxx
#
#   2) 4 arguments:
#          - production_docker_registry_aws_ecr_fqdn
#          - production_docker_registry_aws_ecr_region
#          - production_docker_registry_aws_ecr_installer_aws_access_key_id
#          - production_docker_registry_aws_ecr_installer_aws_secret_access_key
#
function docker_login_aws_ecr {
  set_state "${FUNCNAME[0]}" 'started'

  # Check number of arguments: must be either 2 or 4
  if [ $# -ne 2 ] && [ $# -ne 4 ]; then
  echo "error_wrong_number_of_arguments: $# "
    set_state "${FUNCNAME[0]}" 'error_wrong_number_of_arguments'
    return 1
  fi

  # Get required arguments
  local FQDN="$1"
  local REGION="$2"

  # Check we got non-empty arguments
  # Define required variables
  local REQUIRED_VARIABLES=(
    FQDN
    REGION
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      # Dynamically generate an error_code, which include failed variable name (lowercase)
      local ERROR_CODE="$( echo "failed_to_ensure_variable_not_empty_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Get secrets
  FQDN=$( get_secret "${FQDN}" ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_secret_fqdn'; return 1; }
  REGION=$( get_secret "${REGION}" ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_secret_region'; return 1; }

  # Get 2 optional arguments:
  #   - AWS_ACCESS_KEY_ID
  #   - AWS_SECRET_ACCESS_KEY
  # If arguments are missing, try to get secrets from environment.
  if [ $# -eq 4 ]; then

    # AWS secrets were provided as arguments: get arguments
    local SELECTED_AWS_ACCESS_KEY_ID="$3"
    local SELECTED_AWS_SECRET_ACCESS_KEY="$4"

    # Get secrets
    SELECTED_AWS_ACCESS_KEY_ID=$( get_secret "${SELECTED_AWS_ACCESS_KEY_ID}" ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_secret_aws_access_key_id'; return 1; }
    SELECTED_AWS_SECRET_ACCESS_KEY=$( get_secret "${SELECTED_AWS_SECRET_ACCESS_KEY}" ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_secret_aws_secret_access_key'; return 1; }

  else
    # AWS secrets were not provided as arguments.
    # Try to get them from environment or error out.
    [ ! -z "${AWS_ACCESS_KEY_ID}" ]     || { set_state "${FUNCNAME[0]}" 'failed_to_get_aws_access_key_id_from_environment'; return 1; }
    [ ! -z "${AWS_SECRET_ACCESS_KEY}" ] || { set_state "${FUNCNAME[0]}" 'failed_to_get_aws_secret_access_key_from_environment'; return 1; }
    local SELECTED_AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
    local SELECTED_AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
  fi

  # At this point both SELECTED_AWS_ACCESS_KEY_ID and SELECTED_AWS_SECRET_ACCESS_KEY must be non-empty strings
  [ ! -z "${SELECTED_AWS_ACCESS_KEY_ID}" ]     || { set_state "${FUNCNAME[0]}" 'failed_to_get_best_aws_access_key_id'; return 1; }
  [ ! -z "${SELECTED_AWS_SECRET_ACCESS_KEY}" ] || { set_state "${FUNCNAME[0]}" 'failed_to_get_best_aws_secret_access_key'; return 1; }
  
  # Retrieve an authentication token using the GetAuthorizationToken API
  local TOKEN=$(
    export AWS_ACCESS_KEY_ID="${SELECTED_AWS_ACCESS_KEY_ID}"
    export AWS_SECRET_ACCESS_KEY="${SELECTED_AWS_SECRET_ACCESS_KEY}"
    aws ecr get-login-password --region "${REGION}"
    ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_token'; return 1; }
  
  # Check the token is not blank
  [ ! -z "${TOKEN}" ] || { set_state "${FUNCNAME[0]}" 'error_got_blank_token'; return 1; }

  # Actual "docker login"
  # Note: we use piped command here. The exit code of piped commands will be the one of the last command (docker login).
  # Note: we also collect the output.
  DOCKER_LOGIN_OUTPUT=$( \
    echo "${TOKEN}" \
    | docker login \
        --username AWS \
        --password-stdin "${FQDN}" \
        2>&1
    ) || { set_state "${FUNCNAME[0]}" 'failed_to_docker_login'; return 1; }

  # Send the "docker login" output to the logger with f-n name tag (simplifies debugging, audit, etc.)
  echo "${DOCKER_LOGIN_OUTPUT}" | logger -t "${FUNCNAME[0]}"

  set_state "${FUNCNAME[0]}" 'success'
}
export -f docker_login_aws_ecr

###############################################################################
#
# Function retrieves required named secrets and calls "docker login" to authenticate
# on the given docker registry.
#
# Function takes 3 arguments (names of the corresponding secrets):
#   - docker registry FQDN
#   - docker registry username
#   - docker registry password
#
# Function exits with code:
#   0 - on success
#   1 - on errror
#
# Function also sets state (you can get more details on error by "get_state docker_login_legacy" call).
# Usage examples:
#    docker_login_legacy \
#      production_docker_registry_general_fqdn \
#      production_docker_registry_general_installer_username \
#      production_docker_registry_general_installer_password
#
function docker_login_legacy {
  set_state "${FUNCNAME[0]}" 'started'

  # Check number of arguments: must be exactly 3
  [ $# -eq 3 ] || { set_state "${FUNCNAME[0]}" 'error_wrong_number_of_arguments'; return 1; }

  # Get arguments
  local FQDN="$1"
  local USERNAME="$2"
  local PASSWORD="$3"

  # Check we got non-empty arguments
  # Define required variables
  local REQUIRED_VARIABLES=(
    FQDN
    USERNAME
    PASSWORD
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      # Dynamically generate an error_code, which include failed variable name (lowercase)
      local ERROR_CODE="$( echo "failed_to_ensure_variable_not_empty_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Retrieve actual values by "get_secret()"
  FQDN=$( get_secret "${FQDN}" ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_secret_fqdn'; return 1; }
  USERNAME=$( get_secret "${USERNAME}" ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_secret_username'; return 1; }
  PASSWORD=$( get_secret "${PASSWORD}" ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_secret_password'; return 1; }
  
  # Check if we got non-empty values for container registry: FQDN, username and password
  # TODO: DRY violation: list attributes as array, iterate, check..
  [ ! -z ${FQDN} ] || { set_state "${FUNCNAME[0]}" 'error_got_empty_fqdn'; return 1; }
  [ ! -z ${USERNAME} ] || { set_state "${FUNCNAME[0]}" 'error_got_empty_username'; return 1; }
  [ ! -z ${PASSWORD} ] || { set_state "${FUNCNAME[0]}" 'error_got_empty_password'; return 1; }

  # Actual "docker login"
  # Note: we use piped command here. The exit code of piped commands will be the one of the last command (docker login).
  # Note: we also collect the output.
  DOCKER_LOGIN_OUTPUT=$( \
    echo "${PASSWORD}" \
    | docker login \
        --username "${USERNAME}" \
        --password-stdin "${FQDN}" \
        2>&1
    ) || { set_state "${FUNCNAME[0]}" 'failed_to_docker_login'; return 1; }

  # Send the "docker login" output to the logger with f-n name tag (simplifies debugging, audit, etc.)
  echo "${DOCKER_LOGIN_OUTPUT}" | logger -t "${FUNCNAME[0]}"

  set_state "${FUNCNAME[0]}" 'success'
}
export -f docker_login_legacy

###############################################################################
#
# Function checks installed docker major version against minumally required.
# It takes 1 optional argement "minimum major version", if not provided,
# then by default the major version returned by docker_get_default_minimum_major_version() will be used.
#
# Function return code:
#   0 - on success (installed major version is >= minimally required)
#   1 - on any check failure (example: docker not installed, installed major version is less than minimally required)
#
# Usage example:
#   # Do the docker_minimal_version_check
#   if docker_minimal_version_check "${MINIMUM_MAJOR_VERSION}"; then
#     # Installed version passed the minimal version check, no need to install
#     set_state "${FUNCNAME[0]}" "no_action_already_installed"
#     return 0
#   fi
#
function docker_minimal_version_check {

  set_state "${FUNCNAME[0]}" 'started'

  # Take optional MINIMUM_MAJOR_VERSION argument, if empty, then set default value
  local MINIMUM_MAJOR_VERSION="${1}"
  if [ -z "${MINIMUM_MAJOR_VERSION}" ]; then
      # Use default value
      MINIMUM_MAJOR_VERSION=$( docker_get_default_minimum_major_version ) || { set_state "${FUNCNAME[0]}" "failed_to_get_default_minimum_version"; return 1; }
  fi
  
  # Check if docker is installed
  docker_is_installed || { set_state "${FUNCNAME[0]}" 'error_docker_is_not_installed'; return 1; }

  # Get full docker version (example: 23.0.1)
  local INSTALLED_VERSION="$( docker_get_installed_version )" || { set_state "${FUNCNAME[0]}" "failed_to_get_installed_docker_version"; return 1; }

  # Extract major version component from docker version (example: 23)
  # Note the get_version_component() checked its return value is not blank
  local INSTALLED_MAJOR_VERSION=$( get_version_component major "${INSTALLED_VERSION}" ) || { set_state "${FUNCNAME[0]}" 'falied_to_extract_major_version'; return 1; }

  # Check if docker is installed and has major version >= minimally required
  if [ "${INSTALLED_MAJOR_VERSION}" -ge "${MINIMUM_MAJOR_VERSION}" ]; then
      set_state "${FUNCNAME[0]}" "success"
      return 0
  fi

  # Check didn't pass (installed version is less than minimally required)
  set_state "${FUNCNAME[0]}" 'error_minimal_version_check_did_not_pass'
  return 1
}
export -f docker_minimal_version_check

###############################################################################
#
# Function restarts docker daemon.
#
# The official docker documentation suggests:
# https://docs.docker.com/config/daemon/systemd/
#
function docker_restart {
  set_state "${FUNCNAME[0]}" 'started'

  # Check if docker installed
  docker_is_installed || { set_state "${FUNCNAME[0]}" 'error_docker_is_not_installed'; return 1; }

  # Restart docker daemon
  sudo systemctl restart docker || { set_state "${FUNCNAME[0]}" 'failed_to_docker_restart'; return 1; } 

  set_state "${FUNCNAME[0]}" 'success'
}
export -f docker_restart

###############################################################################
# Category: container
# Utility function - Restart docker containers by given continer names or IDs list.
function docker_restart_containers {

    # if [ -z "${@}" ]; then
    #     error "error_no_container_names_specified"
    #     return 2
    # fi
    CONTAINERS=(${@})
    CONTAINERS_TO_RESTART=()
    for CONTAINER in "${CONTAINERS[@]}"
    do
        # We only restart a container if it is defined
        if docker_container_name_exists "${CONTAINER}"
        then
            CONTAINERS_TO_RESTART+=( ${CONTAINER} )
        fi
    done

    if (( ${#CONTAINERS_TO_RESTART[@]} )); then
        docker restart ${CONTAINERS_TO_RESTART[@]}
        return ${?}
    fi

    return 1
}
export -f docker_restart_containers

###############################################################################
#
# Function overwrites docker configuration and restarts docker daemon.
#
# See official docker configuration man pages:
#   https://docs.docker.com/config/daemon/
#
# (quote)
#   Configure the Docker daemon
#   There are two ways to configure the Docker daemon:
#
#     1) Use a JSON configuration file. This is the preferred option, since it keeps all configurations in a single place.
#     2) Use flags when starting dockerd.
#
#   You can use both of these options together as long as you don’t specify the same option both as a flag and in the JSON file. If that happens, the Docker daemon won’t start and prints an error message.
# (end of quote)
#
function docker_set_log_to_syslog {
  set_state "${FUNCNAME[0]}" 'started'

  # Check if docker installed
  docker_is_installed || { set_state "${FUNCNAME[0]}" 'error_docker_is_not_installed'; return 1; }

  # Check if docker configuration directory exists
  local DOCKCER_CONFIGURATION_PATH="/etc/docker"
  if [ ! -d "${DOCKCER_CONFIGURATION_PATH}" ]; then
    # Error: docker configuration directory does not exist
    set_state "${FUNCNAME[0]}" 'error_docker_configuration_directory_does_not_exist'
    return 1
  fi

  # Create docker configuration file (or overwrite existing)
  local FILEPATH="${DOCKCER_CONFIGURATION_PATH}/daemon.json"
(
cat <<EOT
{
  "log-driver": "syslog",
  "log-opts": {"tag": "{{.Name}}/{{.ID}}"}
}
EOT
  ) | sudo tee ${FILEPATH} > /dev/null

  # Check exit code
  # Note: when $? used for piped commands it returns the exit code of the last commain in chain
  if [ "${?}" -ne 0 ]; then
      set_state "${FUNCNAME[0]}" "failed_to_docker_install_logging_configuration"
      return 1
  fi

  # Restart docker daemon after configuration change
  docker_restart || { set_state "${FUNCNAME[0]}" 'failed_to_docker_restart'; return 1; }

  set_state "${FUNCNAME[0]}" 'success'
}
export -f docker_set_log_to_syslog

###############################################################################
# Category: container
# Utility function - Restart docker containers
# Function gets container name (case sensitive) (can be partial) as the only input argument and
# tries to find all matching containers (even if they're in stopped state). Then for every found
# container it will "docker stop" and "docker remove" them.
# Function return code 0 on success
#
function docker_stop_and_remove_container_by_name {
  set_state "${FUNCNAME[0]}" 'started'

  CONTAINER_NAME="${1}"

  # Check the container name isn't blank
  [ "${CONTAINER_NAME}" != "" ] || { set_state "${FUNCNAME[0]}" 'error_bad_arguments'; return 1; }

  # Count existing container(s) by given docker name
  FOUND_CONTAINERS_COUNT=$( docker ps -a | grep "${CONTAINER_NAME}" | wc -l )

  # Check if we found >1
  if [ ${FOUND_CONTAINERS_COUNT} -gt 1 ]; then
    # Yes, we found >1 containers to stop/remove
    for DOCKER_ID in $(docker ps -a | grep "${CONTAINER_NAME}" | awk '{print $1}'); do
      # Make sure DOCKER_ID is not a blank string
      if [ "${DOCKER_ID}" == "" ]; then
        set_state "${FUNCNAME[0]}" 'failed_to_get_docker_id'
        return 1
      fi

      # Try to stop and remove the container
      docker stop "${DOCKER_ID}"
      docker rm "${DOCKER_ID}"

      # Sometimes container can be in the broken state, in this case even after stopping and removing it
      # the DOCKER_ID is still visible in the "docker ps" list. In this cas we need to kill -9 corresponding
      # process on the host level:
      STILL_PRESENT_DOCKER_ID=$( docker ps -a | grep "${DOCKER_ID}" | wc -l )
      if [ "${STILL_PRESENT_DOCKER_ID}" != "" ]; then
        # Yes, we have found "unstoppable" docker. Kill -9 the corresponding process now
        PID_TO_KILL_COUNT=$( sudo ps aux | grep "${DOCKER_ID}" | wc -l )
        PID_TO_KILL=$( sudo ps aux | grep "${DOCKER_ID}" )
        if [ ${PID_TO_KILL_COUNT} -ne 1 ]; then
          # Something went wrong, we supposed to find exactly ONE pid to terminate.
          set_state "${FUNCNAME[0]}" 'failed_to_get_docker_pid'
          return 1
        fi

        # Send "kill -9" signal to the found process
        sudo kill -9 "${PID_TO_KILL}" || { set_state "${FUNCNAME[0]}" 'error_killing_process'; return 1; }

        # The "unstoppable" docker terminated, now we can safely remove the container
        docker rm "${DOCKER_ID}" || { set_state "${FUNCNAME[0]}" 'error_removing_docker'; return 1; }
      fi
    done

  fi

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f docker_stop_and_remove_container_by_name

###############################################################################
# Category: container
# Utility function - Get list of volumes and print list of containers, which use them.
#
# TODO: improve it to also show the size of each volume by combining output from "docker system df --verbose"
#
function docker_volumes_to_containers_list {
  set_state "${FUNCNAME[0]}" 'started'

  # Get list of all docker volumes names
  VOLUMES=$(docker volume ls  --format '{{.Name}}') || { set_state "${FUNCNAME[0]}" 'failed_to_list_docker_volumes'; return 1; }

  # Iterate all volumes and check if i-th volume is used by any container (even if container is stopped)
  for VOLUME in ${VOLUMES}; do
    
    # Simply print volume identifier
    echo "${VOLUME}"

    # Note: the following command will print associated container names prefixed with 2 spaces
    docker ps -a --filter volume="${VOLUME}"  --format '{{.Names}}' | sed 's/^/  /'
  done

  set_state "${FUNCNAME[0]}" 'success'
}
export -f docker_volumes_to_containers_list

### END UTILITY FUNCTIONS: DOCKERS
