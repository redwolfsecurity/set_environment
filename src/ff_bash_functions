#!/usr/bin/env bash

# This file is a collection of useful bash functions, which we want to source for all
# users and other scripts.
#
#
# Note: we "export -f" all the functions
# Or alternatively we could:
# declare -x -f log
# See this discussion for these and other ways to solve bash functions visibility (note also ~/.bashrc and ~/.profile way to inject f-ns for all users)
# https://stackoverflow.com/questions/1885871/exporting-a-function-in-shell
# https://unix.stackexchange.com/questions/22796/can-i-export-functions-in-bash

# Table of contents generated by command:
#    file_toc src/ff_bash_functions
#
## BEGIN USAGE/HELP FUNCTION
#    - ask_for_value 
#    - ask_for_yn 
#    - command_exists 
#    - file_toc 
#    - help 
#    - help_toc 
## END USAGE/HELP FUNCTION
## BEGIN APT WRAPPER FUNCTIONS
#    - apt_dist_upgrade 
#    - apt_install 
#    - apt_list 
#    - apt_reinstall 
#    - apt_remove 
#    - apt_update 
#    - apt_upgrade 
## END APT WRAPPER FUNCTIONS
## BEGIN UTILITY FUNCTIONS: STRINGS
#    - get_version_component 
#    - in_array 
#    - index_of 
#    - parse_github_repository_url 
#    - trim_slash 
## END UTILITY FUNCTIONS: STRINGS
## BEGIN UTILITY FUNCTIONS: FILE
#    - assert_cd 
#    - assert_makedir 
#    - does_file_have_eol_at_the_end 
#    - f 
#    - file_contains_pattern 
#    - find_file_owner_in_all_packages 
#    - find_file_owner_in_installed_packages 
#    - get_by_url 
#    - get_sudo_read_file_prefix 
#    - get_sudo_write_file_prefix 
#    - get_sudo_readwrite_file_prefix 
#    - glob_matches 
#    - inject_into_file 
#    - is_writable 
#    - path_to_absolute_path 
#    - remove_all_lines_by_regexp 
#    - replace_all_lines_by_regexp 
#    - s 
#    - truncate_file 
## END UTILITY FUNCTIONS: FILE
## BEGIN UTILITY FUNCTIONS: LOGGING / PROCESS CONTROl
#    - abort 
#    - assert_clean_exit 
#    - banner 
#    - error 
#    - log 
#    - step 
#    - successful_exit 
#    - warning 
## END UTILITY FUNCTIONS: LOGGING / PROCESS CONTROl
## BEGIN UTILITY FUNCTIONS: TERMINAL / SHELL
#    - set_bash_echo_on 
#    - set_bash_echo_off 
#    - get_bash_echo_setting 
#    - set_bash_echo_setting 
#    - ensure_variable_defined 
#    - ensure_variable_not_empty 
#    - is_shell_attribute_set 
#    - is_shell_option_set 
#    - terminal_initialize 
#    - terminal_is_interactive 
#    - terminal_is_tty 
#    - terminal_reset 
## END UTILITY FUNCTIONS: TERMINAL / SHELL
## BEGIN UTILITY FUNCTIONS: PROCESS
#    - process_is_running_as_me 
#    - retry_command 
## END UTILITY FUNCTIONS: PROCESS
## BEGIN UTILITY FUNCTIONS: STATE/SECRETS
#    - generate_strong_password 
#    - get_state 
#    - secret_get 
#    - secret_set 
#    - set_state 
## END UTILITY FUNCTIONS: STATE/SECRETS
## BEGIN UTILITY FUNCTIONS: USER / GROUPS
#    - can_sudo 
#    - check_group_exists 
#    - create_user 
#    - is_effectively_root 
#    - get_home_directory_for_user 
#    - get_ppid_cmd 
#    - is_user_in_group 
#    - user_exists 
## END UTILITY FUNCTIONS: USER / GROUPS
## BEGIN DISCOVER FUNCTIONS
#    - ff_agent_get_best_ff_agent_uri 
#    - ff_agent_get_best_ff_content_url 
#    - ff_agent_get_best_ff_host 
#    - ff_agent_get_best_ff_port 
#    - ff_agent_get_best_namespace 
#    - ff_agent_get_best_organization 
#    - ff_uuid 
#    - discover_environment 
#    - discover_optional_environment_variable 
#    - discover_os 
#    - discover_required_environment_variable 
#    - get_epoch_ms 
#    - get_hardware_architecture 
#    - get_os_name 
#    - get_lsb_codename 
#    - get_lsb_id 
#    - get_lsb_id_downcase 
#    - get_lsb_release 
## END DISCOVER FUNCTIONS
## BEGIN SET ENVIRONMENT FUNCTIONS
#    - check_environment_variables_are_set 
#    - ff_agent_check_bin_is_in_the_path 
#    - check_nodejs_installation 
#    - check_set_get_secret 
#    - state_check_set_and_get 
#    - get_current_user 
#    - get_best_ff_agent_home 
#    - ff_api_get 
#    - get_expected_nodejs_version 
#    - is_framework_api_defined 
#    - set_environment_is_working 
#    - publish_message 
## END SET ENVIRONMENT FUNCTIONS


### BEGIN USAGE/HELP FUNCTION

###############################################################################
# CATEGORY
#   USAGE/HELP FUNCTION
#
# NAME
#   ask_for_value - Ask for a value and store it in a variable.
#
# SYNOPSIS
#   ask_for_value VARIABLE QUESTION TOOLTIP DEFAULT_VALUE
#
# DESCRIPTION
#   Prompts the user with a QUESTION, using TOOLTIP as the input prompt. If DEFAULT_VALUE
#   is provided, it will be used as the default input when the user presses Enter.
#   The response is stored in the variable name passed as VARIABLE.
#
# EXAMPLE
#   SOME_VAR=""
#   ask_for_value SOME_VAR "Set value for SOME_VAR" "Enter SOME_VAR value: "
#   ask_for_value SOME_VAR "Update value for SOME_VAR" "Enter new SOME_VAR value: " "${SOME_VALUE}"
#
# EXIT STATUS
#   0 - Success, user input was obtained and stored.
#   1 - Failure, unable to store the input in the variable.
#
###############################################################################
function ask_for_value {
    local VALUE=""

    local  __RESULTVAR=${1}
    local QUESTION=${2}
    local TOOLTIP=${3}
    local DEFAULT=${4}

    while [[ -z ${VALUE} ]]
    do
        log "${QUESTION}"
        if [[ -z ${DEFAULT} ]]
        then
            read -p "${TOOLTIP}" VALUE
        else
            read -e -p "${TOOLTIP}" -i "${DEFAULT}" VALUE
        fi
    done

    if [[ "${__RESULTVAR}" ]]; then
        eval ${__RESULTVAR}="'${VALUE}'"
    else
        echo "${VALUE}"
    fi
}
export -f ask_for_value

###############################################################################
# CATEGORY
#   USAGE/HELP FUNCTION
#
# NAME
#   ask_for_yn - Ask a yes/no question and read user input.
#
# SYNOPSIS
#   ask_for_yn QUESTION
#
# DESCRIPTION
#   Presents the user with a QUESTION and expects a 'y' or 'n' in response. The function
#   returns 0 for 'y' and 1 for 'n'.
#
# EXAMPLE
#   if ask_for_yn "Does vim rock the house?"; then
#       echo "User agreed!"
#   else
#       echo "User disagreed."
#   fi
#
# EXIT STATUS
#   0 - User answered 'y'.
#   1 - User answered 'n'.
#
###############################################################################

function ask_for_yn {
    local QUESTION=${1}
    local ANSWER=""

    while [[ ${ANSWER,,} != "y" ]] && [[ ${ANSWER,,} != "n" ]]
    do
        log "${QUESTION}"
        read -p "Answer [Y/n]: " ANSWER
        if [[ -n ${ANSWER} ]] && [[ ${ANSWER,,} == "y" ]]
        then
            return 0
        fi
    done
    return 1
}
export -f ask_for_yn

###############################################################################
# CATEGORY
#   USAGE/HELP FUNCTION
#
# NAME
#   command_exists - Check if a command exists.
#
# SYNOPSIS
#   command_exists COMMAND_NAME
#
# DESCRIPTION
#   Checks if a given command, which could be a function, an alias, or a binary in the path,
#   exists on the system. Unlike 'which', it correctly identifies aliases and functions. The
#   function outputs the resolved path or alias definition of the command if it exists.
#
# EXAMPLE
#   if command_exists tput; then
#       echo "tput command exists."
#   else
#       echo "tput command does not exist."
#   fi
#
# EXIT STATUS
#   0 - Command exists.
#   1 - Command does not exist.
#
###############################################################################
function command_exists {
  local COMMAND=${1}

  # Force bash to un-hash any previously memorized commands. This will require bash to look it up again.
  # This is for cases where it has 'memoried' a command that has actually been deleted.
  hash -d ${COMMAND} >/dev/null 2>/dev/null
  hash -d $(command -v "${COMMAND}" ) >/dev/null 2>/dev/null

  local COMMAND_RESOLVED=$(command -v "${COMMAND}" )
  local STATUS=${?}

  # Command will return non-zero if command not found
  if [ "${STATUS}" != "0" ]; then
    return 1
  fi

  if [ "${COMMAND_RESOLVED}" == "" ]; then
    return 1
  fi

  # Case: Is this an alias?
  if [[ "${COMMAND_RESOLVED}" =~ ^alias ]]; then
     # If it starts with alias ...= ( e.g. grep is often aliased to something else with options )
     # Then we assume it exists and we let you run the alias
     echo "${COMMAND}"
  else
    # Otherwise we return what we resolved, which might be a bash function, or the path to a command
    echo "${COMMAND_RESOLVED}"
  fi
}
export -f command_exists

###############################################################################
# CATEGORY
#   USAGE/HELP FUNCTION
#
# NAME
#   file_toc - Generate a Table of Contents for a bash file.
#
# SYNOPSIS
#   file_toc FILE_PATH
#
# DESCRIPTION
#   Parses a given bash script file at FILE_PATH, identifying sections and functions
#   to create a table of contents. It lists the beginnings and ends of sections along
#   with function names, formatted for readability.
#
# EXAMPLE
#   file_toc /path/to/my_script.sh
#
# EXIT STATUS
#   0 - Successfully generated the table of contents.
#   1 - File does not exist or another error occurred.
#
###############################################################################
function file_toc {

  # Define path to ff_bash_functions file
  local FILEPATH="${1}"
  [ ! -f "${FILEPATH}" ] && {
    error "error_ff_bash_functions_file_missing"
    return 1
  }

  # Parse ff_bash_functions and generate table of contents
  cat "${FILEPATH}" | grep '^### BEGIN\|^### END\|^function' | sed 's/^function /\#    - /g' | sed 's/{//g' | sed 's/###/##/g'
}
export -f file_toc

###############################################################################
# CATEGORY
#   USAGE/HELP FUNCTION
#
# NAME
#   help - List all defined bash functions.
#
# SYNOPSIS
#   help
#
# DESCRIPTION
#   Displays a list of all builtin and custom-defined bash functions available in
#   the current shell environment.
#
# EXAMPLE
#   help
#
# EXIT STATUS
#   0 - Successfully listed functions.
#   Any other exit status is not defined by this function.
#
###############################################################################
function help {
    echo "Builtin functions:"
    typeset -F | cut -d' ' -f3
}
export -f help

###############################################################################
# CATEGORY
#   USAGE/HELP FUNCTION
#
# NAME
#   help_toc - Generate a Table of Contents for the bash functions file.
#
# SYNOPSIS
#   help_toc
#
# DESCRIPTION
#   This function generates a table of contents for the bash functions defined in the
#   'ff_bash_functions' file located at the FF_AGENT_HOME directory. It marks the start
#   and end of sections and lists functions.
#
# EXAMPLE
#   help_toc
#
# EXIT STATUS
#   0 - Successfully generated the table of contents.
#   1 - FF_AGENT_HOME not set or 'ff_bash_functions' file missing.
#
###############################################################################
function help_toc {
  set_state "${FUNCNAME[0]}" 'started'

  # Check FF_AGENT_HOME is set
  ensure_variable_not_empty 'FF_AGENT_HOME' || {
    set_state "${FUNCNAME[0]}" 'error_ensure_variable_not_empty_ff_agent_home'
    return 1
  }

  # Define path to ff_bash_functions file
  TARGET_FILE="${FF_AGENT_HOME}/git/redwolfsecurity/set_environment/src/ff_bash_functions"
  [ ! -f "${TARGET_FILE}" ] && {
    set_state "${FUNCNAME[0]}" "error_ff_bash_functions_file_missing"
    return 1
  }

  # Parse ff_bash_functions and generate table of contents
  cat "${TARGET_FILE}" | grep '^### BEGIN\|^### END\|^function' | sed 's/^function /\#    - /g' | sed 's/{//g' | sed 's/###/##/g'

  set_state "${FUNCNAME[0]}" 'success'
}
export -f help_toc

### END USAGE/HELP FUNCTION

### BEGIN APT WRAPPER FUNCTIONS

###############################################################################
# CATEGORY
#   APT WRAPPER FUNCTIONS
#
# NAME
#   apt_dist_upgrade - Safely perform a dist-upgrade operation in a headless environment.
#
# SYNOPSIS
#   apt_dist_upgrade
#
# DESCRIPTION
#   Executes an 'apt-get dist-upgrade' operation with options configured for non-interactive
#   environments. It ensures the upgrade process is handled without manual intervention, applying
#   options to allow unauthenticated, downgrades, removal of essential packages, and change of held
#   packages. It first runs 'apt_update' and 'apt_upgrade' to ensure the system is up-to-date before
#   proceeding with dist-upgrade.
#
# EXIT STATUS
#   0 - Successful dist-upgrade.
#   1 - Failed to dist-update
#
###############################################################################
function apt_dist_upgrade {
  local APT_COMMAND=dist-upgrade

  #        --force-yes is deprecetaed now.
  #       Force yes; this is a dangerous option that will cause apt to continue without prompting if it is doing something potentially harmful. It should not be used
  #       except in very special situations. Using force-yes can potentially destroy your system! Configuration Item: APT::Get::force-yes. This is deprecated and
  #       replaced by --allow-unauthenticated , --allow-downgrades , --allow-remove-essential , --allow-change-held-packages in 1.1.
  local FORCE_YES="--allow-unauthenticated --allow-downgrades --allow-remove-essential --allow-change-held-packages"

  apt_update  || { error "${FUNCNAME[0]}" "failed_to_apt_update"; return 1; }
  apt_upgrade || { error "${FUNCNAME[0]}" "failed_to_apt_upgrade"; return 1; }
  sudo DEBIAN_FRONTEND=noninteractive \
    apt-get \
      -yq \
      -o Dpkg::Options::="--force-confdef" \
      -o Dpkg::Options::="--force-confold" \
      ${FORCE_YES} ${APT_COMMAND} || { set_state "${FUNCNAME[0]}" "failed_to_apt_dist_upgrade"; return 1; }
}
export -f apt_dist_upgrade

###############################################################################
# CATEGORY
#   APT WRAPPER FUNCTIONS
#
# NAME
#   apt_install - Safely install packages in a headless environment.
#
# SYNOPSIS
#   apt_install PACKAGE [PACKAGE ...]
#
# DESCRIPTION
#   Installs one or more packages using 'apt-get install' with options tailored for non-interactive
#   environments. This function reduces stdout noise by suppressing most output, focusing on error
#   handling. It uses 'DEBIAN_FRONTEND=noninteractive' to avoid user prompts and includes options
#   to force IPv4 and prevent the installation of recommended or suggested packages.
#
# EXIT STATUS
#   0 - Successful installation of all specified packages.
#   1 - Failure in installing one or more packages.
#
###############################################################################
function apt_install {
  PACKAGES=${@}
  APT_COMMAND=install

  for PACKAGE in "${PACKAGES}"
  do
      # Note: we suppress stdout noise (only stderr will still be "visible", but TODO: think of better way to collect evidences insted of just 1 large pile)
      sudo DEBIAN_FRONTEND=noninteractive \
      apt-get \
        -o Dpkg::Options::="--force-confold" \
        -yq \
        --no-install-recommends \
        --no-install-suggests \
        -o Acquire::ForceIPv4=true \
        ${APT_COMMAND} ${PACKAGE} > /dev/null || { error "${FUNCNAME[0]}" "failed_to_apt_install"; return 1; }
  done
}
export -f apt_install

###############################################################################
# CATEGORY
#   APT WRAPPER FUNCTIONS
#
# NAME
#   apt_list - List all files provided by a specified package.
#
# SYNOPSIS
#   apt_list PACKAGE_NAME
#
# DESCRIPTION
#   Uses 'apt-get download --print-uris' to fetch the URIs of package files and lists the files
#   contained within the specified package, even if the package is not currently installed. This
#   is useful for reverse checking which files belong to a given package. It handles errors such
#   as missing package names or failure to retrieve package URIs.
#
# EXAMPLE
#   apt_list libjansson-dev
#
# EXIT STATUS
#   0 - Successfully listed package files.
#   1 - Failure due to missing package name, inability to find package URIs, or failure to list package files.
#
###############################################################################
function apt_list {

  # Check inputs:
  local PACKAGE_NAME="${1}"
  if [ "${PACKAGE_NAME}" == "" ]; then
    error "${FUNCNAME[0]}" "bad_arguments_missing_package_name"
    return 1
  fi

  # Get package URIs by apt-get download --print-uris
  # Official doc: https://help.ubuntu.com/community/AptGet/Offline/PrintUris
  # apt-get --print-uris
  #  --print-uris : instead of fetching the files to install, their URIs (links to download them) are printed.
  PACKAGE_URI=$( apt-get download \
    -o Dir::Cache::archives="./" \
    --print-uris "${PACKAGE_NAME}"
  )

  # Check errors
  if [ ${?} -ne 0 ]; then
    error "${FUNCNAME[0]}" "failed_to_find_package_uris"
    return 1
  fi

  # Try to list files by given package name
  PACKAGE_FILES=$( apt-get download \
    -o Dir::Cache::archives="./" \
    --print-uris "${PACKAGE_NAME}" | awk -F\' '{print $2}' | xargs -I '{}' curl -skL '{}' | dpkg-deb -c /dev/stdin
  )

  # Check we got files list
  if [ "${PACKAGE_FILES}" == "" ]; then
    error "${FUNCNAME[0]}" "failed_to_list_package_files"
    return 1
  fi
}
export -f apt_list

###############################################################################
# CATEGORY
#   APT WRAPPER FUNCTIONS
#
# NAME
#   apt_reinstall - Safely reinstall packages in a headless environment.
#
# SYNOPSIS
#   apt_reinstall PACKAGE [PACKAGE ...]
#
# DESCRIPTION
#   Reinstalls one or more specified packages using 'apt-get reinstall' with non-interactive options.
#   It ensures that configurations are preserved ('--force-confold') and opts for IPv4 connections.
#   The function iterates over each package, attempting to reinstall them individually and handles
#   errors specifically for package reinstallation failures.
#
# EXIT STATUS
#   0 - Successful reinstallation of all specified packages.
#   1 - Failure in reinstalling one or more packages.
#
###############################################################################
function apt_reinstall {
    PACKAGES=${@}
    APT_COMMAND=reinstall

    for PACKAGE in "${PACKAGES}"; do
        sudo DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${APT_COMMAND} ${PACKAGE}
        if [ ${?} -ne 0 ]; then
            error "Error reinstalling packages: ${PACKAGE}"
            return 1
        fi
    done

}
export -f apt_reinstall

###############################################################################
# CATEGORY
#   APT WRAPPER FUNCTIONS
#
# NAME
#   apt_remove - Safely remove packages in a headless environment.
#
# SYNOPSIS
#   apt_remove PACKAGE [PACKAGE ...]
#
# DESCRIPTION
#   Removes one or more specified packages using 'apt-get remove' with options designed for
#   non-interactive environments. Similar to 'apt_install' and 'apt_reinstall', it minimizes
#   stdout output and prioritizes error reporting, using 'DEBIAN_FRONTEND=noninteractive' and
#   other options to ensure smooth operation without manual intervention.
#
# EXIT STATUS
#   0 - Successful removal of all specified packages.
#   1 - Failure in removing one or more packages.
#
###############################################################################
function apt_remove {
    PACKAGES=${@}
    APT_COMMAND=remove

    for PACKAGE in "${PACKAGES}"
    do
        sudo DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${APT_COMMAND} "${PACKAGE}"
        if [ ${?} -ne 0 ]; then
            error "Error removing packages: ${PACKAGE}"
            return 1
        fi
    done
}
export -f apt_remove

###############################################################################
# CATEGORY
#   APT WRAPPER FUNCTIONS
#
# NAME
#   apt_update - Safely update package lists in a headless environment.
#
# SYNOPSIS
#   apt_update
#
# DESCRIPTION
#   Executes an 'apt-get update' operation with options that facilitate a non-interactive
#   update process. It incorporates options to avoid using deprecated 'force-yes' behavior,
#   opting instead for safer alternatives that allow unauthenticated, downgrades, and the
#   removal of
#   essential packages as well as the changing of held packages. Designed to minimize potential
#   harm while updating package lists in a headless or automated setup.
#
# EXIT STATUS
#   0 - Successful update of the package lists.
#   1 - Failure in updating the package lists.
#
###############################################################################
function apt_update {
    local APT_COMMAND=update

    #        --force-yes is deprecetaed now.
    #       Force yes; this is a dangerous option that will cause apt to continue without prompting if it is doing something potentially harmful. It should not be used
    #       except in very special situations. Using force-yes can potentially destroy your system! Configuration Item: APT::Get::force-yes. This is deprecated and
    #       replaced by --allow-unauthenticated , --allow-downgrades , --allow-remove-essential , --allow-change-held-packages in 1.1.
    local FORCE_YES="--allow-unauthenticated --allow-downgrades --allow-remove-essential --allow-change-held-packages"

    sudo DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${FORCE_YES} ${APT_COMMAND}
    if [ ${?} -ne 0 ]; then
       error "updating packages"
       return 1
    fi
}
export -f apt_update

###############################################################################
# CATEGORY
#   APT WRAPPER FUNCTIONS
#
# NAME
#   apt_upgrade - Safely upgrade packages in a headless environment.
#
# SYNOPSIS
#   apt_upgrade
#
# DESCRIPTION
#   Performs an 'apt-get upgrade' to update all installed packages to the newest versions
#   without removing existing packages or installing new ones. It uses options to ensure
#   non-interactive operation, applying the same safety measures as 'apt_update' to mitigate
#   potential issues. The function is tailored to maintain system stability and security by
#   upgrading packages in a controlled, automated fashion.
#
# EXIT STATUS
#   0 - Successful upgrade of installed packages.
#   1 - Failure in upgrading one or more packages.
#
###############################################################################
function apt_upgrade {
    local APT_COMMAND=upgrade

    #        --force-yes is deprecetaed now.
    #       Force yes; this is a dangerous option that will cause apt to continue without prompting if it is doing something potentially harmful. It should not be used
    #       except in very special situations. Using force-yes can potentially destroy your system! Configuration Item: APT::Get::force-yes. This is deprecated and
    #       replaced by --allow-unauthenticated , --allow-downgrades , --allow-remove-essential , --allow-change-held-packages in 1.1.
    local FORCE_YES="--allow-unauthenticated --allow-downgrades --allow-remove-essential --allow-change-held-packages"

    sudo DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${FORCE_YES} ${APT_COMMAND}
    if [ ${?} -ne 0 ]; then
       error "Error upgrading packages"
       return 1
    fi
}
export -f apt_upgrade

### END APT WRAPPER FUNCTIONS

### BEGIN UTILITY FUNCTIONS: STRINGS

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: STRINGS
#
# NAME
#   get_version_component - Extracts version components from a semantic version string.
#
# SYNOPSIS
#   get_version_component COMPONENT VERSION
#
# DESCRIPTION
#   Given a semantic version number MAJOR.MINOR.PATCH, this function extracts and
#   prints one of the three version components (major, minor, patch) to standard output.
#   It validates the input to ensure that a valid component name and version string are provided.
#
# EXAMPLES
#   VERSION="12.34.56"
#   MAJOR=$(get_version_component major "${VERSION}")
#   MINOR=$(get_version_component minor "${VERSION}")
#   PATCH=$(get_version_component patch "${VERSION}")
#   echo "Version components: MAJOR:${MAJOR}, MINOR:${MINOR}, PATCH:${PATCH}"
#
# EXIT STATUS
#   0 - Success, component extracted.
#   1 - Error, due to invalid input or unsupported component name.
#
###############################################################################
function get_version_component {

  # Check we get exactly 2 arguments
  [ $# -eq 2 ] || { error "${FUNCNAME[0]}" 'error_wrong_number_of_arguments'; return 1; }

  # Get arguments
  local VERSION_COMPONENT_NAME="$1"
  local FULL_VERSION="$2"

  # Check we got non-empty arguments
  [ ! -z ${VERSION_COMPONENT_NAME} ] || { error "${FUNCNAME[0]}" 'error_empty_argument_component_name'; return 1; }
  [ ! -z ${FULL_VERSION} ] || { error "${FUNCNAME[0]}" 'error_empty_argument_full_version'; return 1; }

  # Define an array of all supported version component names
  local SUPPORTED_VERSION_COMPONENT_NAMES=("major" "minor" "patch")

  # Check argument: must be 1 of 3 supported: major, minor, patch
  if ! in_array "${VERSION_COMPONENT_NAME}" "${SUPPORTED_VERSION_COMPONENT_NAMES[@]}"; then
    error "${FUNCNAME[0]}" 'error_unsupported_version_component_name'
    return 1
  fi

  # Extract component version into EXTRACTED_COMPONENT_VERSION
  case "${VERSION_COMPONENT_NAME}" in

  major)
    local EXTRACTED_COMPONENT_VERSION=$( echo "${FULL_VERSION}" | cut -d"." -f 1 )
    ;;

  minor)
    local EXTRACTED_COMPONENT_VERSION=$( echo "${FULL_VERSION}" | cut -d"." -f 2 )
    ;;

  patch)
    local EXTRACTED_COMPONENT_VERSION=$( echo "${FULL_VERSION}" | cut -d"." -f 3 )
    ;;

  *)
    # We already checked (the value is in SUPPORTED_VERSION_COMPONENT_NAMES),
    # but what if "case()" was not updated, then we must error out in our "default" case.
    error "${FUNCNAME[0]}" 'error_unsupported_version_component_name_case'
    return 1
    ;;
  esac
  
  # Check extracted EXTRACTED_COMPONENT_VERSION is not blank
  [ ! -z "${EXTRACTED_COMPONENT_VERSION}" ] || { error "${FUNCNAME[0]}" 'error_got_empty_component_version'; return 1; }

  # Print result to standard output
  echo -n "${EXTRACTED_COMPONENT_VERSION}"
}
export -f get_version_component

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: STRINGS
#
# NAME
#   in_array - Checks if a value exists in an array.
#
# SYNOPSIS
#   in_array NEEDLE HAYSTACK
#
# DESCRIPTION
#   Iterates through an array (haystack) to check if a specified value (needle) exists within it.
#   Returns success if the needle is found, and failure otherwise.
#
# EXAMPLE
#   if in_array "search_value" "${array[@]}"; then
#       echo "Value found."
#   else
#       echo "Value not found."
#   fi
#
# EXIT STATUS
#   0 - Success, value exists in the array.
#   1 - Failure, value does not exist in the array.
#
###############################################################################
function in_array {
    local hay needle=${1}
    shift
    for hay; do
        [[ ${hay} == ${needle} ]] && return 0
    done
    return 1
}
export -f in_array

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: STRINGS
#
# NAME
#   index_of - Returns the index of a value in an array, or 255 if not found.
#
# SYNOPSIS
#   index_of NEEDLE HAYSTACK
#
# DESCRIPTION
#   Searches for a value (needle) in an array (haystack) and returns its index.
#   If the value is not found, returns 255. Note that Bash functions can only return
#   values in the range of 0-255, hence 255 is used to indicate not found.
#
# EXAMPLE
#   INDEX=$(index_of "search_value" "${array[@]}")
#   if [ "${INDEX}" -ne 255 ]; then
#       echo "Value found at index: ${INDEX}"
#   else
#       echo "Value not found."
#   fi
#
# EXIT STATUS
#   0-254 - Index of the value if found.
#   255 - Value not found in the array.
#
###############################################################################
function index_of {
    local NEEDLE=${1}
    declare -a HAYSTACK=("${!2}")
    for i in "${!HAYSTACK[@]}"; do
        if [[ "${HAYSTACK[$i]}" == "${NEEDLE}" ]]; then
            return ${i};
        fi
    done
    
    # Not found: return -1 (same as 255)
    return -1;
}
export -f index_of

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: STRINGS
#
# NAME
#   parse_github_repository_url - Parses GitHub repository URLs.
#
# SYNOPSIS
#   parse_github_repository_url URL COMPONENT
#
# DESCRIPTION
#   Extracts and prints specific components (protocol, host, owner, project name)
#   from a GitHub repository URL. Validates input to ensure the URL and component name
#   are provided. Supports various URL formats, including SSH, HTTPS, and Git protocol URLs.
#
# EXAMPLES
#   URL="git://github.com/some-user/my-repo.git"
#   OWNER=$(parse_github_repository_url "${URL}" "OWNER")
#   echo "The owner of the URL '${URL}' is '${OWNER}'."
#
# Another example:
# URLS=(
#  "git://github.com/some-user/my-repo.git"
#  "https://github.com/some-user/my-repo.git"
#  "git@github.com:some-user/my-repo.git"
#  "git://github.com/some-user/my-repo"
#  "https://github.com/some-user/my-repo"
#  "git@github.com:some-user/my-repo"
# )
#
# for URL in "${URLS[@]}"; do
#     echo "${URL}"
#     parse_github_repository_url "${URL}" "OWNER"
# done
#
# EXIT STATUS
#   0 - Success, component extracted.
#   1 - Error, due to failed URL parsing or missing arguments.
#
###############################################################################
function parse_github_repository_url {
  local URL="${1}"
  local KEY="${2}"

  # Check required arguments are not empty
  [ ! -z "${URL}" ] || { return 1; }
  [ ! -z "${KEY}" ] || { return 1; }

  # Define regexp to parse github repository url
  re="^(https|git)(:\/\/|@)([^\/:]+)[\/:]([^\/:]+)\/(.+)(.git)*$"

  # Parse github repository url
  if [[ ${URL} =~ ${re} ]]; then
    PROTOCOL=${BASH_REMATCH[1]}
    # SEPARATOR=${BASH_REMATCH[2]}
    HOST=${BASH_REMATCH[3]}
    OWNER=${BASH_REMATCH[4]}
    PROJECT_NAME=${BASH_REMATCH[5]%.git}
    case "${KEY}" in
      PROTOCOL)
        echo "${PROTOCOL}"
        return 0
        ;;
      HOST)
        echo "${HOST}"
        return 0
        ;;
      OWNER)
        echo "${OWNER}"
        return 0
        ;;
      PROJECT_NAME)
        echo "${PROJECT_NAME}"
        return 0
        ;;
      *)
        # Error: unknown key
        return 1
    esac
  else
    # Failed to find a match.
    return 1
  fi
}
export -f parse_github_repository_url

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: STRINGS
#
# NAME
#   trim_slash - Normalizes slashes in a string.
#
# SYNOPSIS
#   trim_slash STRING...
#
# DESCRIPTION
#   For each input string, replaces consecutive slashes with a single slash,
#   and removes trailing slashes except when the string is a single slash.
#   Useful for cleaning URLs or file paths.
#
# EXAMPLES
#   trim_slash "http://acme.com/a/b/c/" "http://acme.com///" "http://acme.com/" "/" "///" "a/" "b/b/" "c/c////"
#
#   # Outputs:
#   #   http://acme.com/a/b/c
#   #   http://acme.com
#   #   http://acme.com
#   #   /
#   #   /
#   #   a
#   #   b/b
#   #   c/c
#
# EXIT STATUS
#   0 - Always succeeds.
#
###############################################################################

function trim_slash {
  for s; do
    sed -E 's:(^/)?/*$:\1:' <<< "${s}"
  done
}
export -f trim_slash

### END UTILITY FUNCTIONS: STRINGS

### BEGIN UTILITY FUNCTIONS: FILE

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   assert_cd - Changes the current directory to the specified directory or aborts if it fails.
#
# SYNOPSIS
#   assert_cd DIRECTORY
#
# DESCRIPTION
#   Attempts to change the current working directory to the specified DIRECTORY. It first checks
#   if the directory exists and is a directory. If it cannot change to the directory, possibly
#   due to permission issues, it will abort the operation with an error message.
#
# USAGE
#   assert_cd /path/to/directory
#
# EXIT STATUS
#   Exits the script if it fails to change the directory.
#
###############################################################################
function assert_cd {

  # Check first if it is a directory.
  if [ ! -d "${1}" ]; then
     abort "ERROR: Can not enter directory \"${1}\" -- it is not a directory."
  fi

  # Directory exists, now enter it. May fail due to permissions.
  if [ -d "${1}" ]; then
     assert_clean_exit cd "${1}"
  else
     abort "ERROR: Can not enter directory \"${1}\". SUGGEST: check user ID and directory permissions."
  fi
}
export -f assert_cd

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   assert_makedir - Creates a directory if it does not already exist.
#
# SYNOPSIS
#   assert_makedir DIRECTORY
#
# DESCRIPTION
#   Checks if the specified DIRECTORY exists. If not, it attempts to create the directory.
#   If the directory creation fails (for instance, due to lacking permissions), it aborts the operation.
#
# USAGE
#   assert_makedir /path/to/directory
#
# EXIT STATUS
#   Aborts script on failure to create the directory.
#
###############################################################################
function assert_makedir {
  if [ -d "${1}" ]; then
     log "INFO: Directory \"${1}\" exists, skipping creation."
  else
     assert_clean_exit mkdir "${1}"
  fi
}
export -f assert_makedir

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   does_file_have_eol_at_the_end - Checks if a file ends with an End Of Line (EOL) character.
#
# SYNOPSIS
#   does_file_have_eol_at_the_end FILEPATH
#
# DESCRIPTION
#   Verifies if the specified file ends with an EOL character or if the file is empty.
#   It is useful for ensuring that a file is in a good state for appending content.
#
# USAGE EXAMPLE
#   # Call function and preserve its return code
#   does_file_have_eol_at_the_end "${FILEPATH}"
#   does_file_have_eol_at_the_end_code=$?
#
#   # Check if function returned an error
#   if [ ${does_file_have_eol_at_the_end_code} -gt 1 ]; then
#       error "Function does_file_have_eol_at_the_end() returned error code ${does_file_have_eol_at_the_end_code}.""
#       return 1
#   fi
#   
#   # Check if EOL is present
#   if does_file_have_eol_at_the_end_code /path/to/file.txt; then
#       echo "Yes, EOL is present."
#
# EXIT STATUS
#   0 - EOL present or file is empty.
#   1 - EOL missing.
#   2 - Incorrect arguments.
#   3 - File does not exist or cannot be read.
#
###############################################################################
function does_file_have_eol_at_the_end {

  # Define exit codes (both success and errors)
  local EOL_PRESENT_OR_EMPTY_FILE=0
  local EOL_MISSING=1
  local ERROR_BAD_ARGUMENTS=2
  local ERROR_FILE_DOES_NOT_EXIST_OR_CAN_NOT_READ_EVEN_WITH_SUDO=3

  # Take arguments
  FILENAME="${1}"

  # Check required arguments are not empty
  [ ! -z "${FILEPATH}" ] || { error "${FUNCNAME[0]}" "error_target_filepath_is_blank"; return ${ERROR_BAD_ARGUMENTS}; }

  # Get "sudo read / write" prefixes
  local SUDO_READ_FILE_PREFIX
  SUDO_READ_FILE_PREFIX=$(get_sudo_read_file_prefix "${FILEPATH}") || { error "${FUNCNAME[0]}" "failed_to_get_sudo_read_file_prefix"; return ${ERROR_FILE_DOES_NOT_EXIST_OR_CAN_NOT_READ_EVEN_WITH_SUDO}; }

  # Check if file is empty
  if ${SUDO_READ_FILE_PREFIX} [ ! -s "${FILENAME}" ]; then
      # Note: For our needs (to avoid concatination of name/value lines) we consider empty file as having EOL (i.e. safe to append more name/values)
      # The file is empty.
      # Note: function does_file_have_eol_at_the_end() got empty file.
      # For our needs (to avoid concatination of name/value lines)
      # we consider empty file as having EOL (i.e. safe to append more name/values)
      return 0
  # -z - true if the length of string is zero
  # -n - true if the length of string is nonzero
  elif [ -z "$(${SUDO_READ_FILE_PREFIX} tail -c 1 "${FILENAME}" )" ]; then
      # The file ends with a newline or with a null byte,
      return ${EOL_PRESENT_OR_EMPTY_FILE}
  else
      # The file does not end with a newline nor with a null byte.
      return ${EOL_MISSING}
  fi
}
export -f does_file_have_eol_at_the_end

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   f - Finds files or directories starting with a given prefix, recursively, from the current directory.
#
# SYNOPSIS
#   f PREFIX
#
# DESCRIPTION
#   Performs a case-insensitive recursive search from the current directory for files or directories that
#   start with the specified PREFIX. It excludes the 'node_modules' directory from the search.
#
# USAGE EXAMPLE
#   f index
#
# EXIT STATUS
#   Success if files or directories are found; failure otherwise.
#
###############################################################################
function f {
    FILE_PREFIX="${1}"
    if [ "${FILE_PREFIX}" != "" ]; then
        find . -iname "${FILE_PREFIX}*"
        return ${?}
    else
        echo "Find files with prefix, starting from current working directory down recursively." 1>&2
        echo "Usage: f index" 1>&2
        return 1
    fi
}
export -f f

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   file_contains_pattern - Checks if a file contains a given regex pattern.
#
# SYNOPSIS
#   file_contains_pattern FILEPATH PATTERN
#
# DESCRIPTION
#   Searches for a specified regular expression PATTERN within a file at FILEPATH.
#   If necessary, it escalates privileges using sudo to read the file.
#   PATTERN - The pattern is the POSIX regular expression:
#             https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
#             but with platform-specific extensions (which vary in extent and can be incompatible).
#             On Linux platforms (GNU userland), see man grep; on macOS/BSD platforms, see man re_format.#
#
# USAGE EXAMPLE
#   file_contains_pattern /path/to/file.txt "pattern"
#
# EXIT STATUS
#   0 - Pattern found.
#   1 - Pattern not found.
#   2 - File does not exist.
#   3 - Incorrect arguments.
#   4 - Failed to escalate privileges.
#
###############################################################################
function file_contains_pattern {

  # Define exit codes for different outcomes
  local PATTERN_FOUND=0
  local PATTERN_NOT_FOUND=1
  local ERROR_FILE_DOES_NOT_EXIST=2
  local ERROR_BAD_ARGUMENTS=3
  local ERROR_FAILED_TO_GET_SUDO_PREFIX=4

  # Take arguments
  local FILEPATH="${1}"
  local PATTERN="${2}"

  # Define list of required environment variables (must be not empty)
  local ALL_EXPECTED_ENVRIONMENT_VARIABLES=(
    FILEPATH
    PATTERN
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${ALL_EXPECTED_ENVRIONMENT_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      error "${FUNCNAME[0]}" "Argument not set: ${VARIABLE_NAME,,}" # Using ,, for lowercase conversion
      return ${ERROR_BAD_ARGUMENTS}
    }
  done

  # Check if we need to use "sudo" prefix to read / write / readwrite (or check file existence) for a given file
  local SUDO_READ_FILE_PREFIX
  SUDO_READ_FILE_PREFIX=$(get_sudo_read_file_prefix "${FILEPATH}") || { set_state "${FUNCNAME[0]}" "failed_to_get_sudo_read_file_prefix"; return ${ERROR_FAILED_TO_GET_SUDO_PREFIX}; }

  # Check the target file exists
  if ${SUDO_READ_FILE_PREFIX} [ ! -e "${FILEPATH}" ]; then
    return ${ERROR_FILE_DOES_NOT_EXIST}
  fi

  # Search pattern in the file
  ${SUDO_READ_FILE_PREFIX} grep --quiet --text "${PATTERN}" "${FILEPATH}"

  # Analyze search exit code
  if [ $? -eq 0 ]; then
    # Pattern found
    return ${PATTERN_FOUND}
  else
    # Pattern not found
    return ${PATTERN_NOT_FOUND}
  fi
}
export -f file_contains_pattern

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   find_file_owner_in_all_packages - Identifies the package(s) that own a specified file across all available packages.
#
# SYNOPSIS
#   find_file_owner_in_all_packages FILENAME
#
# DESCRIPTION
#   Uses 'apt-file' to search across all packages in the repository to find which one(s) contain
#   the specified FILENAME. Requires 'apt-file' to be installed and updated.
#
# USAGE EXAMPLES
#   find_file_owner_in_all_packages realpath
#   find_file_owner_in_all_packages hping3
#   find_file_owner_in_all_packages netstat
#
# EXIT STATUS
#   Outputs package names and file paths. Returns success if 'apt-file' is available and the search can be performed.
#
###############################################################################
function find_file_owner_in_all_packages {
    # Take filename argument
    FILE="${1}"

    # Make sure arguemnt is not empty
    if [ -z "${FILE}" ]; then
        error "Function find_file_owner_in_all_packages() require one argument: filename."
        return 1
    fi

    # Check if "apt-file" is installed
    if ! command_exists apt-file >/dev/null; then
      error "apt-file is not installed. Please install it first (e.g. sudo install apt-file) and try again."
      return 1
    fi

    # Update packages universe database
    # Note: Running apt-file update updates its database of files available in packages,
    # enabling users to search for a specific file to find out which package it belongs to.
    # This is especially useful for resolving missing file or library dependencies.
    # It is different from "apt-get update", which updates the package lists for upgrades
    # or new package installations by syncing the package index files from their sources specified
    # in /etc/apt/sources.list and /etc/apt/sources.list.d/*.list files.
    sudo apt-file update

    # Try to search given file
    apt-file search "${FILE}"
}
export -f find_file_owner_in_all_packages

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   find_file_owner_in_installed_packages - Finds which installed package owns a specified file.
#
# SYNOPSIS
#   find_file_owner_in_installed_packages FILENAME
#
# DESCRIPTION
#   Searches through installed packages to find which package owns the specified FILENAME. It differs from
#  'find_file_owner_in_all_packages' by only searching among packages that are already installed on the system
#  and by using "dpkg" instead of "apt-file".
#
# USAGE EXAMPLES
#   find_file_owner_in_installed_packages realpath
#   find_file_owner_in_installed_packages hping3
#   find_file_owner_in_installed_packages netstat
#
# EXIT STATUS
#   Outputs package names and file paths. Returns success if the file is owned by an installed package.
#
###############################################################################

function find_file_owner_in_installed_packages {
    # Take filename argument
    FILE="${1}"

    # Make sure arguemnt is not empty
    if [ -z "${FILE}" ]; then
        error "Function find_file_owner_in_installed_packages() require one argument: filename."
        return 1
    fi

    # Try to find the file in the installed packages
    dpkg -S "${FILE}"
}
export -f find_file_owner_in_installed_packages



###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   get_by_url - Downloads a file from a specified URL.
#
# SYNOPSIS
#   get_by_url URL FILEPATH
#
# DESCRIPTION
#   Downloads a file from the given URL to the specified FILEPATH. If FILEPATH is "-",
#   the content is printed to standard output. This function is designed for non-interactive
#   use, handling temporary file creation, download, and cleanup. It sets permissions for
#   downloaded files to be readable and writable by the owner and readable by the group.
#   Function sets state to indicate success or error code.
#   Note: target FILEPATH will be overwritten upon successful completion.
#
#   Possible error codes are:
#      - error_wrong_number_of_arguments
#      - error_bad_argument_blank_url
#      - error_bad_argument_blank_filepath
#      - error_generating_tmp_filepath
#      - error_downloading_file
#      - error_bad_http_code_404
#      - error_bad_http_code_000
#      - error_printing_file
#      - error_moving_file
#      - error_removing_file
#
# USAGE EXAMPLE
#   get_by_url "https://example.com/file.txt" "/path/to/save/file.txt" || { error "${FUNCNAME[0]}" "Failed to download file"; return 1; }
#   CONTENT=$(get_by_url "https://example.com/text.txt" "-") || { error "${FUNCNAME[0]}" "Failed to download file"; return 1; }
#
# EXIT STATUS
#   0 - Success.
#   1 - Error occurred (e.g., bad arguments, download failure, etc.).
#
###############################################################################
function get_by_url {
  # Indicate: function started
  set_state "${FUNCNAME[0]}" 'started'

  # Check number of arguments: it must be exactly 2
  [ $# -ne 2 ] && { set_state "${FUNCNAME[0]}" "error_wrong_number_of_arguments"; return 1; }

  # Get/check inputs: URL
  local URL="$1"
  [ -z "${URL}" ] && { set_state "${FUNCNAME[0]}" "error_bad_argument_blank_url"; return 1; }

  # TODO: discuss if we want to user regexp to check URL is valid:
  # https://stackoverflow.com/questions/3183444/check-for-valid-link-url

  # Get/check inputs: FILEPATH
  local FILEPATH="$2"
  [ -z "${URL}" ] && { set_state "${FUNCNAME[0]}" "error_bad_argument_blank_filepath"; return 1; }

  # Create a temporary file and store it's filepath to TMP_FILEPATH
  # It will be used to download the file.
  # Note: we use "-t" to allow "mktemp" to select temporary folder for us.
  # The "XXX" in the "mktemp" arguments are template - these will be replaced
  # with random characters.

  local TMP_FILEPATH
  TMP_FILEPATH=$(mktemp -t ${FUNCNAME[0]}.XXXXXXX) || { set_state "${FUNCNAME[0]}" "error_generating_tmp_filepath"; return 1; }

  # Chmod file from "-rw-------" to default "-rw-rw-r--" 664
  chmod 664 "${TMP_FILEPATH}" || { set_state "${FUNCNAME[0]}" "error_chmod_tmp_filepath"; return 1; }

  # Start actual download
  local HTTP_CODE
  HTTP_CODE=$(curl \
  --silent    \
  --retry 5    \
  --location    \
  --retry-delay 1 \
  --retry-max-time 55 \
  --max-time 60 \
  --connect-timeout 12 \
  -o "${TMP_FILEPATH}" \
  -w "%{http_code}" \
  ${URL}) \
  || { set_state "${FUNCNAME[0]}" 'error_downloading_file'; return 1; }

  # Note: curl return code 0 does not mean successful file download.
  # We must check the HTTP_CODE has value 200 - that is the only necessary
  # and sufficient condition of successful file download.
  #
  # Example HTTP_CODE values and reasons:
  #    HTTP_CODE: 000 - one of the possible reasons: failed to resolve domain
  #    HTTP_CODE: 404 - file was not found on the server by the given URL
  #
  [ "${HTTP_CODE}" -eq 200 ] || { set_state "${FUNCNAME[0]}" "error_bad_http_code_${HTTP_CODE}"; return 1; }

  # We have file successfully downloaded file into temporary filepath: ${TMP_FILEPATH}
  # Now there are 2 cases:
  #   1) Move that file into ${FILEPATH} provided by user as f-n argument
  #   or
  #   2) Print that file to standard output if provided ${FILEPATH} is "-"
  if [ "${FILEPATH}" == "-" ]; then
      # Print file to standard output
      cat "${TMP_FILEPATH}" || { set_state "${FUNCNAME[0]}" 'error_reading_file'; return 1; }
  else
      # Move file to desired destination
      # We use -f to make mv to overwrite whenever possible without asking for any confirmations
      mv -f "${TMP_FILEPATH}" "${FILEPATH}" || {
        # If failed to move try with sudo
        local CURRENT_USER
        CURRENT_USER="$(get_current_user)" || { set_state "${FUNCNAME[0]}" 'error_getting_current_user'; return 1; }
        if can_sudo "${CURRENT_USER}"; then
          # Have sudo privileges. Try to move using 'sudo'.
          sudo mv -f "${TMP_FILEPATH}" "${FILEPATH}" || { set_state "${FUNCNAME[0]}" 'error_moving_file_as_root'; return 1; }
        else
          # Don't have sudo privileges
          set_state "${FUNCNAME[0]}" 'error_moving_file_and_no_sudo_privileges'
          return 1
        fi 
      }
  fi

  # Clean up: remove temporary file (TODO: in future we might cover "partial download" case if needed)
  if [ -f "${TMP_FILEPATH}" ]; then
      rm "${TMP_FILEPATH}" || { set_state "${FUNCNAME[0]}" 'error_removing_file'; return 1; }
  fi

  # Indicate: function succeed
  set_state "${FUNCNAME[0]}" 'success'
}
export -f get_by_url

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   get_sudo_read_file_prefix - Determines if sudo is needed to read a file.
#
# SYNOPSIS
#   get_sudo_read_file_prefix FILEPATH
#
# DESCRIPTION
#   Checks if the current user has read permissions for the specified FILEPATH. 
#   If not, it checks if sudo can grant read access. If sudo is required, "sudo"
#   is printed to standard output.
#
# USAGE EXAMPLE
#   SUDO_READ_FILE_PREFIX=$(get_sudo_read_file_prefix "/path/to/protected/file.txt") || { error "${FUNCNAME[0]}" "failed to get sudo read file prefix"; return 1; }
#
# EXIT STATUS
#   0 - Success, determined if sudo is needed.
#   1 - Error, file does not exist or other issue preventing access determination.
#
###############################################################################
function get_sudo_read_file_prefix {

  # Take arguments
  local FILEPATH="${1}"

  # Check required arguments are not empty
  [ ! -z "${FILEPATH}" ] || { set_state "${FUNCNAME[0]}" "error_target_filepath_is_blank"; return 1; }

## EVEN THIS CHECK MIGHT NEED "sudo"
## Let us intentionally skip this check, if file does not exist then
## this f-n return an error: error_target_file_is_not_readable
## 
##  # Check file exists
##  [ -f "${FILEPATH}" ] || { set_state "${FUNCNAME[0]}" 'error_target_file_does_not_exist'; return 1; }
  
  # Check if target file is readable by the current user.
  # Also set SUDO_READ_FILE_PREFIX="sudo" if file can be read only by "root"
  local SUDO_READ_FILE_PREFIX=""
  [ -r "${FILEPATH}" ] || {
    # The FILEPATH is not readable by the current user, check if current user can_sudo
    local CURRENT_USER
    CURRENT_USER="$(get_current_user)" || { set_state "${FUNCNAME[0]}" "failed_to_get_current_user"; return 1; }
    if can_sudo "${CURRENT_USER}"; then
      # Yes, current uer can_sudo, try with sudo and if successful, then set SUDO_READ_FILE_PREFIX="sudo"
      sudo [ -r "${FILEPATH}" ] && SUDO_READ_FILE_PREFIX="sudo" || { set_state "${FUNCNAME[0]}" 'error_target_file_is_not_readable'; return 1; }
    else
      set_state "${FUNCNAME[0]}" 'error_target_file_is_not_readable'
      return 1
    fi
  }

  # Print result to standard output
  echo -n "${SUDO_READ_FILE_PREFIX}"

  # Indicate: function succeed
  set_state "${FUNCNAME[0]}" 'success'
}
export -f get_sudo_read_file_prefix

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   get_sudo_write_file_prefix - Determines if sudo is needed to write to a file.
#
# SYNOPSIS
#   get_sudo_write_file_prefix FILEPATH
#
# DESCRIPTION
#   Checks if the current user has write permissions for the specified FILEPATH.
#   If not, it checks if sudo can grant write access. If sudo is required, "sudo"
#   is printed to standard output.
#
# USAGE EXAMPLE
#   PREFIX=$(get_sudo_write_file_prefix "/path/to/protected/file.txt") || { error "${FUNCNAME[0]}" "failed to get sudo write file prefix"; return 1; }
#
# EXIT STATUS
#   0 - Success, determined if sudo is needed.
#   1 - Error, file does not exist or other issue preventing access determination.
#
###############################################################################
function get_sudo_write_file_prefix {

  # Take arguments
  local FILEPATH="${1}"

  # Check required arguments are not empty
  [ ! -z "${FILEPATH}" ] || { set_state "${FUNCNAME[0]}" "error_target_filepath_is_blank"; return 1; }

## EVEN THIS CHECK MIGHT NEED "sudo"
## Let us intentionally skip this check, if file does not exist then
## this f-n return an error: error_target_file_is_not_writeable
## 
##  # Check file exists
##  [ -f "${FILEPATH}" ] || { set_state "${FUNCNAME[0]}" 'error_target_file_does_not_exist'; return 1; }
  
  # Check if target file is writable by the current user
  # Also set SUDO_WRITE_FILE_PREFIX="sudo" if file can be written only by "root"
  local SUDO_WRITE_FILE_PREFIX=""
  [ -w "${FILEPATH}" ] || {
    # The FILEPATH is not writable by the current user, check if current user can_sudo
    local CURRENT_USER
    CURRENT_USER="$(get_current_user)" || { set_state "${FUNCNAME[0]}" "failed_to_get_current_user"; return 1; }
    if can_sudo "${CURRENT_USER}"; then
      # Yes, current uer can_sudo, try with sudo and if successful, then set SUDO_WRITE_FILE_PREFIX="sudo"
      sudo [ -w "${FILEPATH}" ] && SUDO_WRITE_FILE_PREFIX="sudo" || { set_state "${FUNCNAME[0]}" 'error_target_file_is_not_writable'; return 1; }
    else
      set_state "${FUNCNAME[0]}" 'error_target_file_is_not_writable'
      return 1
    fi
  }

  # Print result to standard output
  echo -n "${SUDO_WRITE_FILE_PREFIX}"

  # Indicate: function succeed
  set_state "${FUNCNAME[0]}" 'success'
}
export -f get_sudo_write_file_prefix

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   get_sudo_readwrite_file_prefix - Determines if sudo is needed for read-write access to a file.
#
# SYNOPSIS
#   get_sudo_readwrite_file_prefix FILEPATH
#
# DESCRIPTION
#   Checks if the current user has read and write permissions for the specified FILEPATH.
#   If not, it checks if sudo can grant read-write access. If sudo is required, "sudo"
#   is printed to standard output.
#
# USAGE EXAMPLE
#   PREFIX=$(get_sudo_readwrite_file_prefix "/path/to/protected/file.txt") || { error "${FUNCNAME[0]}" "failed to get sudo read/write file prefix"; return 1; }
#
# EXIT STATUS
#   0 - Success, determined if sudo is needed.
#   1 - Error, file does not exist or other issue preventing access determination.
#
###############################################################################
function get_sudo_readwrite_file_prefix {

  # Take arguments
  local FILEPATH="${1}"

  # Check required arguments are not empty
  [ ! -z "${FILEPATH}" ] || { set_state "${FUNCNAME[0]}" "error_target_filepath_is_blank"; return 1; }

## EVEN THIS CHECK MIGHT NEED "sudo"
## Let us intentionally skip this check, if file does not exist then
## this f-n return an error: ????
## 
##  # Check file exists
##  [ -f "${FILEPATH}" ] || { set_state "${FUNCNAME[0]}" 'error_target_file_does_not_exist'; return 1; }
  
  # Get "sudo read / write" prefixes
  local SUDO_READ_FILE_PREFIX
  SUDO_READ_FILE_PREFIX=$(get_sudo_read_file_prefix "${FILEPATH}") || { set_state "${FUNCNAME[0]}" "failed_to_get_sudo_read_file_prefix"; return 1; }
  
  local SUDO_WRITE_FILE_PREFIX
  SUDO_WRITE_FILE_PREFIX=$(get_sudo_write_file_prefix "${FILEPATH}") || { set_state "${FUNCNAME[0]}" "failed_to_get_sudo_write_file_prefix"; return 1; }
  
  # If we need to use "sudo" for either: read or write, then
  # let's set SUDO_READWRITE_FILE_PREFIX="sudo"
  if [ "${SUDO_READ_FILE_PREFIX}" == "sudo" ] || [ "${SUDO_READ_FILE_PREFIX}" == "sudo" ]; then
    local SUDO_READWRITE_FILE_PREFIX="sudo"
  fi

  # Print result to standard output
  echo -n "${SUDO_READWRITE_FILE_PREFIX}"

  # Indicate: function succeed
  set_state "${FUNCNAME[0]}" 'success'
}
export -f get_sudo_readwrite_file_prefix

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   glob_matches - Checks if a glob pattern matches any files or directories.
#
# SYNOPSIS
#   glob_matches PATTERN
#
# DESCRIPTION
#   Uses bash's globbing feature to check if the specified PATTERN matches any files
#   or directories in the current directory. It is a simple wrapper around bash's
#   built-in globbing capabilities to provide a programmatic check for glob matches.
#
# USAGE EXAMPLE
#   if glob_matches "*.txt"; then
#     echo "Text files exist."
#   else
#     echo "No text files found."
#   fi
#
# EXIT STATUS
#   0 - Pattern matches.
#   1 - No matches found.
#
###############################################################################
function glob_matches {
	compgen -G ${@} >/dev/null
	return ${?}
}
export -f glob_matches


###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   inject_into_file - Injects or appends text into a file based on a pattern.
#
# SYNOPSIS
#   inject_into_file FILEPATH PATTERN INJECT_CONTENT
#
# DESCRIPTION
#   Searches for a given PATTERN within a file. If the pattern is not found,
#   INJECT_CONTENT is appended to the file. If the file ends without an End
#   Of Line (EOL), an EOL is added before appending. It uses sudo if necessary
#   for the file access.
#   PATTERN - The pattern is the POSIX regular expression:
#             https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
#             but with platform-specific extensions (which vary in extent and can be incompatible).
#             On Linux platforms (GNU userland), see man grep; on macOS/BSD platforms, see man re_format.#
#
# USAGE EXAMPLE
#   inject_into_file "/path/to/file.txt" "unique_pattern" "Text to be injected"
#
#   More complex example with regular expression and multiple lines INJECT_CONTENT:
#     PATTERN="^source \"${FF_AGENT_PROFILE_FILE}\""
#     INJECT_CONTENT=$(
#     cat <<EOT
#         # Sourcing ${FF_AGENT_PROFILE_FILE} injected by set_environment ${FUNCNAME[0]}() on $(date --utc).
#         source "${FF_AGENT_PROFILE_FILE}"
#         EOT
#     )
#     inject_into_file "${TARGET_FILE}" "${PATTERN}" "${INJECT_CONTENT}" || { error "${FUNCNAME[0]}" "error_injecting_source_custom_profile"; return 1; }
#
# EXIT STATUS
#   0 - Success, content injected or pattern already present.
#   1 - Error occurred (e.g., permissions issues, file does not exist).
#
###############################################################################
function inject_into_file {

  # Take arguments
  local FILEPATH="${1}"
  local PATTERN="${2}"
  local INJECT_CONTENT="${3}"

  # Check required arguments are not empty
  # Define required variables
  local REQUIRED_VARIABLES=(
    FILEPATH
    PATTERN
    INJECT_CONTENT
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      local ERROR_CODE="$( echo "error_empty_argument_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )"
      error "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Check if we need to use "sudo" prefix to read / write / readwrite (or check file existence) given file
  local SUDO_READ_FILE_PREFIX
  SUDO_READ_FILE_PREFIX=$(get_sudo_read_file_prefix "${FILEPATH}") || { error "${FUNCNAME[0]}" "failed_to_get_sudo_read_file_prefix"; return 4; }
  
  local SUDO_WRITE_FILE_PREFIX
  SUDO_WRITE_FILE_PREFIX=$(get_sudo_write_file_prefix "${FILEPATH}") || { error "${FUNCNAME[0]}" "failed_to_get_sudo_write_file_prefix"; return 5; }
  
  local SUDO_READWRITE_FILE_PREFIX
  SUDO_READWRITE_FILE_PREFIX=$(get_sudo_readwrite_file_prefix "${FILEPATH}") || { error "${FUNCNAME[0]}" "failed_to_get_sudo_write_file_prefix"; return 5; }

  # Check the target file exists
  ${SUDO_READ_FILE_PREFIX} [ -f "${FILEPATH}" ] || { error "${FUNCNAME[0]}" "error_target_file_does_not_exist: '${FILEPATH}'"; return 1; }

  # Check if target file contains the PATTERN.
  # Note: the file_contains_pattern() will take care of "sudo" prefix
  if ! file_contains_pattern "${FILEPATH}" "${PATTERN}"; then
    # Expected pattern is missing. Inject text.

    # Call function and preserve its return code
    does_file_have_eol_at_the_end "${FILEPATH}"
    does_file_have_eol_at_the_end_code=$?

    # Check if function returned an error
    if [ ${does_file_have_eol_at_the_end_code} -gt 1 ]; then
        error "Function does_file_have_eol_at_the_end() returned error code ${does_file_have_eol_at_the_end_code}."
        return 1
    fi

    # Inject extra EOL if last line of the file missing EOL and file is not empty
    if [ ${does_file_have_eol_at_the_end_code} -ne 0 ]; then
      # The ${FILEPATH} file does not have EOL at the end.
      # Add EOL to the end of the file (so our injected line starts from the new line)
      echo "" | ${SUDO_READ_FILE_PREFIX} tee -a "${FILEPATH}" || {
        error "${FUNCNAME[0]}" "Failed to add missing EOL to the end of the file: ${FILEPATH}"
        return 1
      }
    fi

    # Append INJECT_CONTENT to the end of the target file
    echo "${INJECT_CONTENT}" | ${SUDO_READ_FILE_PREFIX} tee -a "${FILEPATH}" >/dev/null || {
      error "${FUNCNAME[0]}" 'error_injecting_sourcing_custom_bashrc_to_home_bashrc'
      return 1
    }

    # Post condition: verify that the expected pattern can be found after injection.
    if ! file_contains_pattern "${FILEPATH}" "${PATTERN}"; then
      # Expected pattern is still missing. Report an error.
      error "${FUNCNAME[0]}" 'postcondition check failed:expected pattern is missing after injection'
      return 1
    fi
  fi
}
export -f inject_into_file

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   is_writable - Checks if the specified file or directory is writable.
#
# SYNOPSIS
#   is_writable TARGET
#
# DESCRIPTION
#   Verifies if the current user has write permissions for the specified TARGET file or directory.
#   It does not escalate privileges or attempt to modify permissions.
#
# USAGE EXAMPLE
#   if is_writable "/path/to/file"; then
#     echo "File is writable."
#   else
#     echo "File is not writable."
#   fi
#
# EXIT STATUS
#   0 - Target is writable.
#   1 - Target is not writable or does not exist.
#
###############################################################################
function is_writable {
  # Get argument
  local TARGET="${1}"

  # Check argument is not blank
  [ ! -z "${TARGET}" ] || { return 1; }
  
  # If file/directory is writable, then return 0
  [ -w "${TARGET}" ] && { return 0; }

  # The target is not writable. Return 1
  return 1
}
export -f is_writable

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   path_to_absolute_path - Converts a relative file path to an absolute path.
#
# SYNOPSIS
#   path_to_absolute_path PATH
#
# DESCRIPTION
#   Uses the 'realpath' command to convert the given PATH to its absolute form,
#   accounting for symbolic links and relative path elements. Requires 'realpath'
#   to be available on the system, which is a part of the coreutils apt package,
#   installed as a set_environment baseline.
#   Note: the '--canonicalize-missing' option is used, so no path components need
#   to exist or be a directory.
#
# USAGE EXAMPLE
#   ABSOLUTE_FILEPATH=$(path_to_absolute_path "../../../../../../../../../some/relative/path") #  result: /some/relative/path
#
# EXIT STATUS
#   The absolute path is output to standard output. Returns exit status of the 'realpath' command.
#
###############################################################################
function path_to_absolute_path {
  local TARGET="$1"
  realpath --canonicalize-missing "${TARGET}"
}
export -f path_to_absolute_path

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   remove_all_lines_by_regexp - Removes all lines from a file that match a given regular expression.
#
# SYNOPSIS
#   remove_all_lines_by_regexp FILEPATH PATTERN
#
# DESCRIPTION
#   Searches a file at FILEPATH for lines matching REGEX and removes them. It supports basic
#   and extended POSIX regular expressions. This function uses sudo if necessary for file access.
#   PATTERN - The pattern is the POSIX regular expression:
#             https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
#             but with platform-specific extensions (which vary in extent and can be incompatible).
#             On Linux platforms (GNU userland), see man grep; on macOS/BSD platforms, see man re_format.#
#
# USAGE EXAMPLES
#   remove_all_lines_by_regexp "/path/to/config.txt" "^#.*"
#   remove_all_lines_by_regexp /some/path/to/the/file.txt "Some line matcher regexp \(.*\)"
#
# EXIT STATUS
#   0 - successfully removed lines
#   1 - missing regular expression
#   2 - missing target filename
#   3 - target file does not exist
#   4 - not enough permissions to read the target file
#   5 - not enough permissions to writ the target file
#   6 - the pattern was not found (in some cases this might be 'success' because some lines were already removed successfully before)
#   7 - failed to search by given pattern (most probably bad regex pattern)
#   8 - editor return an error (most probably bad regex pattern
#   9 - zero lines removed (despite the pattern was found and editor didn't error out and we have all the permissions)
#
###############################################################################
function remove_all_lines_by_regexp {

  # Get regexp argument
  local FILEPATH="${1}"
  local REGEX="${2}"
  
  # Check required arguments are not empty
  # Define required variables
  local REQUIRED_VARIABLES=(
    FILEPATH
    REGEX
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      error "${FUNCNAME[0]}" "Got empty required argument: '${VARIABLE_NAME,,}'"
      return 1
    }
  done

  # Check if we need to use "sudo" prefix to read / write / readwrite (or check file existence) given file
  local SUDO_READ_FILE_PREFIX
  SUDO_READ_FILE_PREFIX=$(get_sudo_read_file_prefix "${FILEPATH}") || { error "${FUNCNAME[0]}" "failed_to_get_sudo_read_file_prefix"; return 4; }
  
  local SUDO_WRITE_FILE_PREFIX
  SUDO_WRITE_FILE_PREFIX=$(get_sudo_write_file_prefix "${FILEPATH}") || { error "${FUNCNAME[0]}" "failed_to_get_sudo_write_file_prefix"; return 5; }
  
  local SUDO_READWRITE_FILE_PREFIX
  SUDO_READWRITE_FILE_PREFIX=$(get_sudo_readwrite_file_prefix "${FILEPATH}") || { error "${FUNCNAME[0]}" "failed_to_get_sudo_write_file_prefix"; return 5; }

  # Check the target file exists
  ${SUDO_READ_FILE_PREFIX} [ -f "${FILEPATH}" ] || { error "${FUNCNAME[0]}" "error_target_file_does_not_exist: '${FILEPATH}'"; return 1; }

  # Check if target file is readable
  if ${SUDO_READ_FILE_PREFIX} [ ! -r "${FILEPATH}" ]; then
    # Error: not enough permissions to read target file
    return 4
  fi

  # Check if target file is writable
  if ${SUDO_WRITE_FILE_PREFIX} [ ! -w "${FILEPATH}" ]; then
    # Error: not enough permissions to write target file
    return 5
  fi

  # Try to find by given regexp
  # Note: we collect grep output even though "-q" is used: to cover all the error cases and
  # not spill output to stderr/stdout. We might enrich return error with more details later
  # (examaple: bad syntax in the used regex).
  local GREP_OUTPUT
  GREP_OUTPUT=$( ${SUDO_READ_FILE_PREFIX} grep --quiet "${REGEX}" "${FILEPATH}" 2>&1 )
  local EXIT_CODE
  EXIT_CODE=${?}

  # Check if the pattern is found
  if [ ${EXIT_CODE} -eq 1 ]; then
    # The pattern match not found
    error "${FUNCNAME[0]}" 'error_pattern_match_not_found'
    return 6
  fi
  if [ ${EXIT_CODE} -gt 1 ]; then
    # Error: 7 - failed to search by given pattern.
    error "${FUNCNAME[0]}" 'failed_to_search_by_given_pattern'
    return 7
  fi

  # Take a note on the current number of lines
  local LINE_COUNT_BEFORE_CHANGE
  LINE_COUNT_BEFORE_CHANGE="$( ${SUDO_READ_FILE_PREFIX} cat "${FILEPATH}" | wc -l )" || { error "${FUNCNAME[0]}" 'failed_to_count_lines_before_edit'; return 1; }

  # Found line in the target file. Edit file:
  local EDITOR_OUTPUT
  EDITOR_OUTPUT=$( ${SUDO_READWRITE_FILE_PREFIX} sed -i "/${REGEX}/d" "${FILEPATH}" 2>&1 )

  # Check if stream editor error out.
  # Example: bad pattern would return code=1 and error message: sed: -e expression #1, char 8: unterminated address regex
  local EDITOR_CODE
  EDITOR_CODE=${?}
  if [ ${EDITOR_CODE} -ne 0 ]; then
    # Error: editor return an error (most probably bad regex pattern)
    error "${FUNCNAME[0]}" 'failed_to_edit_file'
    return 8
  fi

  # Count the number of deleted lines
  # Note: sed always return 0, so it won't let us know how many changes were done
  LINE_COUNT_AFTER_CHANGE="$( ${SUDO_READ_FILE_PREFIX} cat "${FILEPATH}" | wc -l )" || { error "${FUNCNAME[0]}" 'failed_to_count_lines_after_edit'; return 1; }
  local DELETED_LINES_COUNT
  DELETED_LINES_COUNT=$(( LINE_COUNT_BEFORE_CHANGE - LINE_COUNT_AFTER_CHANGE ))

  # Check the number of deleted lines
  if [ ${DELETED_LINES_COUNT} -gt 0 ]; then
    # Success
    error "${FUNCNAME[0]}" 'success'
    return 0
  else
    # Somehow the number of lines did't change even though we found the pattern (obviously an error).
    error "${FUNCNAME[0]}" 'error_number_of_lines_after_edit_did_not_change'
    return 9
  fi
}
export -f remove_all_lines_by_regexp

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   replace_all_lines_by_regexp - Replaces all lines matching a regular expression in a file.
#
# SYNOPSIS
#   replace_all_lines_by_regexp FILE PATTERN INJECT_CONTENT
#
# DESCRIPTION
#   Parses the given FILE and replaces all lines that contain a match for the given
#   regular expression REGEX with the new content INJECT_CONTENT. Utilizes sed for
#   in-place editing and supports using sudo for file access if needed.
#   PATTERN - The pattern is the POSIX regular expression:
#             https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
#             but with platform-specific extensions (which vary in extent and can be incompatible).
#             On Linux platforms (GNU userland), see man grep; on macOS/BSD platforms, see man re_format.#
#
# EXAMPLES
#   replace_all_lines_by_regexp "/path/to/file.txt" "old_content" "new_content"
#   replace_all_lines_by_regexp "/some/path/to/the/file.txt" "Some old content regexp \(.*\)" "New content"
#   if [ $? -eq 0 ]; then
#     echo "Successfully changed ${LINES_CHANGED_COUNT} line(s)"
#
# EXIT STATUS
#   0 - Successfully changed lines (and print number of changed lines to the standard output)
#   1 - Missing inputs: regular expression or replacement string is empty
#   2 - Missing target filename
#   3 - Target file does not exist
#   4 - Not enough permissions to read the target file
#   5 - Not enough permissions to write the target file
#   6 - The pattern was not found (in some cases this might be 'success' because some line was already changed successfully before (example: call same f-n twice))
#   7 - Failed to search by given pattern (most probably bad regex pattern)
#   8 - Editor return an error (most probably bad regex pattern
#   9 - Zero lines changed (despite the pattern was found and editor didn't error out and we have all the permissions)
#  10 - Failed to create temporary file
#  11 - Failed to copy target file to temporary file
#  12 - Failed to remove temporary file
#  13 - Failed to calculate difference after edit
#
###############################################################################
function replace_all_lines_by_regexp {

  # Take arguments
  local FILEPATH="${1}"
  local REGEX="${2}"
  local INJECT_CONTENT="${3}"

  # Check required arguments are not empty (note: ${INJECT_CONTENT} can be empty)
  # Define required variables
  local REQUIRED_VARIABLES=(
    FILEPATH
    REGEX
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      error "${FUNCNAME[0]}" "Got empty required argument: '${VARIABLE_NAME,,}'"
      return 1
    }
  done

  # Check if we need to use "sudo" prefix to read / write / readwrite (or check file existence) given file
  local SUDO_READ_FILE_PREFIX
  SUDO_READ_FILE_PREFIX=$(get_sudo_read_file_prefix "${FILEPATH}") || { error "${FUNCNAME[0]}" "failed_to_get_sudo_read_file_prefix"; return 4; }
  
  # local SUDO_WRITE_FILE_PREFIX
  # SUDO_WRITE_FILE_PREFIX=$(get_sudo_write_file_prefix "${FILEPATH}") || { error "${FUNCNAME[0]}" "failed_to_get_sudo_write_file_prefix"; return 5; }
  
  local SUDO_READWRITE_FILE_PREFIX
  SUDO_READWRITE_FILE_PREFIX=$(get_sudo_readwrite_file_prefix "${FILEPATH}") || { error "${FUNCNAME[0]}" "failed_to_get_sudo_write_file_prefix"; return 5; }

  # Check the target file exists
  ${SUDO_READ_FILE_PREFIX} [ -f "${FILEPATH}" ] || { error "${FUNCNAME[0]}" 'error_target_file_does_not_exist'; return 3; }

  # Try to find by given regexp
  GREP_OUTPUT=$( ${SUDO_READ_FILE_PREFIX} grep --quiet "${REGEX}" "${FILEPATH}" 2>&1 )
  EXIT_CODE=${?}

  # Check if the pattern is found
  if [ ${EXIT_CODE} -eq 1 ]; then
    # The pattern was not found
    error "${FUNCNAME[0]}" 'error_pattern_was_not_found'
    return 6
  fi
  if [ ${EXIT_CODE} -gt 1 ]; then
    # Error: 7 - failed to search by given pattern.
    # Pass grep output through stdout.
    error "${FUNCNAME[0]}" 'failed_to_search_by_given_pattern'
    return 7
  fi

  # Make a temporary copy of the edited file (the only reason: we need to count number of modified lines by the editor)
  ORIGINAL_FILE_COPY="$( mktemp 2>&1 )"
  if [ ${?} -ne 0 ] || [ ! -f "${ORIGINAL_FILE_COPY}" ]; then
    # Failed to create temporary file. Details: ${ORIGINAL_FILE_COPY}
    error "${FUNCNAME[0]}" 'error_failed_to_create_temporary_file'
    return 10
  fi

  # Create a temporary copy of the target file before editing it
  ${SUDO_READ_FILE_PREFIX} cp "${FILEPATH}" "${ORIGINAL_FILE_COPY}"
  if [ ${?} -ne 0 ]; then
    # Failed to copy file ${FILEPATH} to temporary file ${ORIGINAL_FILE_COPY}
    error "${FUNCNAME[0]}" 'failed_to_copy_target_to_temporary_file'
    return 11
  fi

  # We found line(s) in the target file. Edit file:
  EDITOR_OUTPUT=$( ${SUDO_READWRITE_FILE_PREFIX} sed -i "s/${REGEX}/${INJECT_CONTENT}/g" "${FILEPATH}" 2>&1 )

  # Check if stream editor error out.
  # Example: bad pattern would return code=1 and error message: sed: -e expression #1, char 8: unterminated address regex
  EDITOR_CODE=${?}
  if [ ${EDITOR_CODE} -ne 0 ]; then
    # Error: inline editor returned an error (most probably bad regex pattern)
    # Pass editor output (error details) to stdout.
    error "${FUNCNAME[0]}" 'error_inline_editor_returned_bad_code'
    # Remove temporary file
    rm "${ORIGINAL_FILE_COPY}" || { error "${FUNCNAME[0]}" 'error_removing_temporary_file'; return 12; }
    return 8
  fi

  # Count the number of modified lines
  # Note: sed always return 0, so it won't let us know how many changes were done unless we count "before" and "after"
  MODIFIED_LINES_COUNT=$( ${SUDO_READ_FILE_PREFIX} diff "${FILEPATH}" "${ORIGINAL_FILE_COPY}" | grep '^<' | wc -l ) || { error "${FUNCNAME[0]}" 'failed_to_calculate_difference_after_edit'; return 13; }

  # Remove temporary file
  rm "${ORIGINAL_FILE_COPY}" || { error "${FUNCNAME[0]}" 'error_removing_temporary_file'; return 12; }

  # Check the number of modified lines is > 0
  if [ ${MODIFIED_LINES_COUNT} -gt 0 ]; then
    # Success. Pass the number of modified lines through stdout.
    echo "${MODIFIED_LINES_COUNT}"
    # Indicate: function succeed
    error "${FUNCNAME[0]}" 'success'
    return 0
  else
    # Somehow the number of lines did't change even though we found the pattern (obviously an error).
    # Pass editor output (error details) to stdout.
    error "${FUNCNAME[0]}" 'error_zero_lines_changed'
    return 9
  fi
}
export -f replace_all_lines_by_regexp

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   s - Searches files from the current directory down for a given pattern, ignoring node_modules.
#
# SYNOPSIS
#   s PATTERN
#
# DESCRIPTION
#   Performs a recursive search for files containing the specified PATTERN, starting
#   from the current directory. It ignores any files within 'node_modules' directories
#   and is case-insensitive.
#
# EXAMPLES
#   s "search term"
#
# EXIT STATUS
#   Success if the pattern is found in any file; failure otherwise.
###############################################################################
function s {
#!/bin/bash -
    GREP_OPTIONS="--color=always"
    PATTERN="${1}"
    if [ "${PATTERN}" != "" ]; then
        find . -name "*" -type f -not -path "*node_modules*" -exec grep --ignore-case --text --line-number -H "${PATTERN}" {} \;
        return ${?}
    else
        echo "Search files in a subtree for a regex. Case insensitive." 1>&2
        echo "Usage: s pattern" 1>&2
        return 1
    fi
}
export -f s

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   truncate_file - Truncates a specified file to zero length.
#
# SYNOPSIS
#   truncate_file FILEPATH
#
# DESCRIPTION
#   Sets the size of the specified file to zero, effectively erasing its contents. This operation is performed safely, checking for the existence and write permissions of the file.
#
# EXAMPLES
#   truncate_file "/path/to/logfile.log"
#
# EXIT STATUS
#   0 - Success, file truncated to zero length.
#   1 - General error, such as file does not exist or insufficient permissions.
#   2 - Missing target filename argument.
#   3 - Target file does not exist.
#   4 - Insufficient permissions to read the target file.
#   5 - Insufficient permissions to write to the target file.
#   6 - Failed to truncate the target file to zero length.
#       Note: if you truncating the log file, which is actively used by running process(es) there might be the case
#             when right after you truncated the file it was written to before we checked the size, so error code 6 might
#             be not an error in these cases.
#
###############################################################################
function truncate_file {
  # Get filename argument
  local FILEPATH="${1}"

  # Check filename is not blank
  if [ "${FILEPATH}" == "" ]; then
    # Error: missing target filename
    return 2
  fi

  # Check file exists
  if [ ! -f "${FILEPATH}" ]; then
    # Error: file does not exist
    return 3
  fi

  # Check if target file is readable
  if [ ! -r "${FILEPATH}" ]; then
    # Error: not enough permissions to read target file
    return 4
  fi

  # Check if target file is writable
  if [ ! -w "${FILEPATH}" ]; then
    # Error: not enough permissions to write target file
    return 5
  fi

  # Check if file is not empty, then truncate it to zero
  if [ -s "${FILEPATH}" ]; then
    # File is not empty.
    # Warning: don't "sudo" here, for files with permissions like "-rw-rw-r--" truncate won't have access by root user
    truncate --size=0 "${FILEPATH}" || { set_state "${FUNCNAME[0]}" 'error_trancating_file'; return 1; }
  else
    # File is already empty
    return 0
  fi

  # Final check: file must have zero size now
  if [ -s file ]; then
    # Error: File is not empty after truncation
    return 6
  fi
}
export -f truncate_file

### END UTILITY FUNCTIONS: FILE



### BEGIN UTILITY FUNCTIONS: LOGGING / PROCESS CONTROl

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: LOGGING / PROCESS CONTROL
#
# NAME
#   abort
#
# SYNOPSIS
#   abort [custom_message]
#
# DESCRIPTION
#   This function logs a custom error message, if provided, and aborts the
#   execution of the script. If the SERVICE variable is set, it also updates
#   the service's state to 'abort' before exiting.
#
# EXAMPLES
#   do_critical_task || { abort "Critical task XYZ failed!"; }
#
# EXIT STATUS
#   Exits the script with status 1.
###############################################################################
function abort {
    error "abort called - aborting ${@}"

    # Check if the SERVICE is set (not blank string), then also set corresponding state
    if [ ! -z "${SERVICE}" ]; then
        set_state ${SERVICE} abort
    fi
    exit 1
}
export -f abort

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: LOGGING / PROCESS CONTROL
#
# NAME
#   assert_clean_exit
#
# SYNOPSIS
#   assert_clean_exit command [options]
#
# DESCRIPTION
#   Executes a specified command with optional parameters. If the command
#   exits with a status other than 0, indicating failure, this function will
#   log an error and call `abort` to terminate the script execution.
#
# EXAMPLES
#   # Ensure a package update completes successfully:
#   assert_clean_exit apt-get update
#
# EXIT STATUS
#   Does not return if the command fails; otherwise, continues script execution.
###############################################################################
function assert_clean_exit {
  #echo "TRY: ${@}"
  "${@}"
  local STATUS=${?}
  if [ ${STATUS} -ne 0 ]; then
     log "ERROR: Command \"${@}\" did not exit cleanly."
     abort
  # else
  # 	log "SUCCESS: ${@}"
  fi
}
export -f assert_clean_exit

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: LOGGING / PROCESS CONTROL
#
# NAME
#   banner
#
# SYNOPSIS
#   banner [custom_message]
#
# DESCRIPTION
#   Displays a banner at the start of a script or process, providing key
#   information such as the start time, user ID, current working directory,
#   hostname, and operating system. A custom message can also be included.
#   This function is particularly useful for logging and debugging purposes,
#   making it easier to trace the execution context of a script.
#
# EXAMPLE
#   banner "Script XYZ has started"
#
###############################################################################
function banner {
cat <<EOT
    ================================================================================
    BUILD SCRIPT: ${@}
         STARTED: $( date )
              AS: $( id )
             PWD: $( pwd )
            HOST: $( hostname )
              OS: $( uname -a )
    ================================================================================

EOT
}
export -f banner

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: LOGGING / PROCESS CONTROL
#
# NAME
#   error
#
# SYNOPSIS
#   error [message]
#
# DESCRIPTION
#   Logs a given error message, enhancing visibility by optionally prefacing
#   the message with a red font style. It forwards the message to the `log`
#   function, which outputs to both the standard error stream and the system
#   logger.
#
# EXAMPLES
#   error "Failed to download the required dependencies."
#
###############################################################################
function error {
    echo -n "${FONT_STYLE_RED}"
    log error: "${@}"
    echo -n "${FONT_STYLE_NORMAL}"
}
export -f error

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: LOGGING / PROCESS CONTROL
#
# NAME
#   log
#
# SYNOPSIS
#   log message
#
# DESCRIPTION
#   Outputs a given message to both the standard error stream and the system
#   logger. If the `SERVICE` environment variable is defined, it is included
#   as a prefix in the log message and used as a tag for the logger.
#
# EXAMPLES
#   log "Update process started."
#
###############################################################################

function log {

  # Check if optional environment SERVICE is defined, then use it as a tag for logger
  if [ "${SERVICE}" != "" ]; then
    local LOGGER_TAG="--tag '${SERVICE}'"
    local SERVICE_PREFIX="${SERVICE}: "
  else
    local SERVICE_PREFIX=''
  fi

  echo "${SERVICE_PREFIX}${@}" | tee >(logger ${LOGGER_TAG} ) >&2
}
export -f log

###############################################################################
# Category: UTILITY FUNCTIONS: LOGGING / PROCESS CONTROl
# Auxilary function to produce human-readable output in standard output describing
# currently executed "step". Function takes arbitrary number of arguments.
# 
function step {
cat <<EOT

  --------------------------------------------------------------------------------
  STEP: ${@}
  --------------------------------------------------------------------------------

EOT
}
export -f step

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: LOGGING / PROCESS CONTROL
#
# NAME
#   successful_exit
#
# SYNOPSIS
#   successful_exit
#
# DESCRIPTION
#   Marks the last run state as 'success' if a `SERVICE` variable is defined,
#   and then exits the script with status 0. This function is typically called
#   at the end of a script to indicate successful completion.
#
# EXAMPLES
#   successful_exit
#
# EXIT STATUS
#   Exits the script with status 0.
###############################################################################
function successful_exit {

  # Check if SERVICE is defined
  if [ "${SERVICE}" != "" ]; then
    local SERVICE_SUFFIX="${SERVICE}_"
    set_state "${SERVICE_SUFFIX}last_run_state" success
  fi

  exit 0
}
export -f successful_exit

###############################################################################
# Category: UTILITY FUNCTIONS: LOGGING / PROCESS CONTROl
# Utility error logging function
function warning {

    # Check input: not empty
    if [ -z "${@}" ]; then
      return
    fi

    log warning "${@}"
}
export -f warning

### END UTILITY FUNCTIONS: LOGGING / PROCESS CONTROl


### BEGIN UTILITY FUNCTIONS: TERMINAL / SHELL

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Function enables verbose bash echo (all executed lines got printed before execution).
# This is convenient way to debug bash scritps.
#
# Note: we don't use "set_state()" in set_bash_echo_xxx() functions since it can laed to recurrsion.
#
function set_bash_echo_on {
  set -x
}
export -f set_bash_echo_on

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Function disables verbose bash echo (all executed lines got printed before execution).
function set_bash_echo_off {
  set +x
}
export -f set_bash_echo_off

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Function get_bash_echo_setting() allows to preserve current bash echo settings, so
# one can restore it later using set_bash_echo_setting().
#
# Usage Example:
#
# # Preserve current bash echo settings and enable bash echo setting
# BASH_ECHO_SETTINGS=$( get_bash_echo_setting ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_bash_echo_settings'; return 1; }
# set_bash_echo_on
#
# # ...do some work...
#
# # Restore bash echo settings
# set_bash_echo_setting "${BASH_ECHO_SETTINGS}"
#
function get_bash_echo_setting {
  # Preserve current xtrace state
  if is_shell_attribute_set x; then
    echo -n " XTRACE_ENABLED "
  fi
}
export -f get_bash_echo_setting

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Functions set_bash_echo_setting() allows to restore/set bash echo settings according to
# the provided argument -- settings string. The settings string can be obtained using get_bash_echo_setting().
#
# See function get_bash_echo_setting() description for details.
#
function set_bash_echo_setting {
  # Get all provided arguments (it supports multiple arguments)
  local BASH_ECHO_SETTINGS="${@}"

  # Check if arguments have XTRACE_ENABLED
  if [[ "${BASH_ECHO_SETTINGS}" =~ XTRACE_ENABLED ]]; then
    # Enable bash tracing
    set_bash_echo_on
  else
    # Disable bash tracing
    set_bash_echo_off
  fi
}
export -f set_bash_echo_setting


###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Function checks if variable given by name is defined.
# Function takes the only argument: variable name.
# Return:
#    on "success" (variable is defined) - return 0
#    on "error" (variable not devined) - return non zero code and callse error(error_details)
#
function ensure_variable_defined {
  
  # Dependency check: 'tr' is installed
  if ! command_exists tr >/dev/null; then
    error "${FUNCNAME[0]}" 'error_dependency_not_met_tr'
    return 1
  fi

  local NAME="${1}"
  [[ -z "${NAME}" ]] && { error "error_ensure_variable_defined_no_arguments"; return 1; }  # Check: NAME is not blank
  [[ -v "${NAME}" ]] && { return 0; }  # Check: variable by NAME is defined

  # Create meaningful error code, which include lowcase variable name
  local ERROR_CODE="$( echo "error_expected_variable_not_set_${NAME}" | tr '[:upper:]' '[:lower:]' )"

  # Report an error and return nonzero code.
  error "${ERROR_CODE}"
  return 1
}
export -f ensure_variable_defined

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Function ensure_variable_not_empty checks if the variable by given is defined and has non-empty value.
# Function takes the only argument: variable name.
# Return:
#    on "success" (variable is defined and non-empty) - return 0
#    on "error" (variable not defined or has empty value) - return nonzero code and calls error(error_details)
#
# Usage example:
#     ensure_variable_not_empty 'FF_CONTENT_URL' || {
#       set_state "${FUNCNAME[0]}" "error_ensure_variable_not_empty_ff_content_url"
#       return 1
#     }
#
function ensure_variable_not_empty {
  local NAME="${1}"
  [[ -z "${NAME}" ]] && { error "error_ensure_variable_not_empty_no_arguments"; return 1; }  # Check: NAME itself is not blank
  [[ -v "${NAME}" ]] && [[ ! -z "${!NAME}" ]] && { return 0; }  # Check: variable by NAME is defined and isn't empty

  # Create meaningful error code, which include lowcase variable name
  local ERROR_CODE=$( echo "error_ensure_variable_not_empty_${NAME}" | tr '[:upper:]' '[:lower:]' )

  # Report an error and return nonzero code.
  error "${ERROR_CODE}"
  return 1
}
export -f ensure_variable_not_empty

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Utility is_shell_attribute_set function
# See discussion: https://stackoverflow.com/a/34709224/7022062
# Usage example:
#     set -x
#     if is_shell_attribute_set x; then echo "xtrace enabled" ; else echo "xtrace disabled"; fi # xtrace enabled
#
#     set -e
#     if is_shell_attribute_set e; then echo "yes"; else echo "no"; fi # yes
#
#     set +e
#     if is_shell_attribute_set e; then echo "yes"; else echo "no"; fi # no
#
function is_shell_attribute_set {
  case "$-" in
    *"${1}"*)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}
export -f is_shell_attribute_set

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Utility is_shell_attribute_set function
# See discussion: https://stackoverflow.com/a/34709224/7022062
# Usage example:
#     set -o pipefail
#     if is_shell_option_set pipefail; then echo "yes"; else echo "no"; fi # yes
#
#     set +o pipefail
#     if is_shell_option_set pipefail; then echo "yes"; else echo "no"; fi # no
#
function is_shell_option_set {
  case "$(set -o | grep "${1}")" in
    *on) return 0 ;;
    *)   return 1 ;;
  esac
}
export -f is_shell_option_set

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Initialize the terminal
# Ensures that TERM is set
# Ensures we set up colours only if TERM is set, else empty strings
# Works even if we don't have tput command, which we might not
function terminal_initialize {

  # If we do not have a terminal type, set up dumb
  if [ -z "${TERM}" ]; then
    export TERM=dumb
  fi

  export FONT_STYLE_BOLD=""
  export FONT_STYLE_GREEN=""
  export FONT_STYLE_RED=""
  export FONT_STYLE_NORMAL=""

  if terminal_is_tty ; then

    if command_exists tput >/dev/null ; then
        # If this is a TTY, These set of "FONT_STYLE_*" variables allows us to decorate the output with some style (colour, boldness)
        FONT_STYLE_BOLD="$(tput bold)"
        FONT_STYLE_GREEN="$(tput setaf 2)"
        FONT_STYLE_RED="$(tput setaf 1)"
        FONT_STYLE_NORMAL="$(tput sgr0)"
    fi
  fi
}
export -f terminal_initialize

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Check if terminal is interactive
# This is useful in cases where we might wish to ask a question
# If you run this script from ssh, it will return 255 (e.g. ssh hostname "terminal_is_interactive" )
function terminal_is_interactive {
  command_exists tty >/dev/null && tty -s && return 0 || return 1
  return 1 # Default, it isn't.
}
export -f terminal_is_interactive

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Check if this terminal is a TTY
function terminal_is_tty {
    [ -t 0 ] && return 0 || return 1
}
export -f terminal_is_tty

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Reset terminal state - sometimes useful if a command messes up terminal state
function terminal_reset {
  terminal_is_tty && command_exists tput >/dev/null && tput reset && tput sane
}
export -f terminal_reset

### END UTILITY FUNCTIONS: TERMINAL / SHELL


### BEGIN UTILITY FUNCTIONS: PROCESS

###############################################################################
# Category: UTILITY FUNCTIONS: PROCESS
# checks if a process is running as current user or effectively as current user.
# Note we are checking for the pattern at the beginning of the command by default
function process_is_running_as_me {
    set_state "${FUNCNAME[0]}" 'started'
    local COMMAND_PATTERN="${1}"
    [ ! -z "${COMMAND_PATTERN}" ] || { set_state "${FUNCNAME[0]}" 'error_require_pattern_to_search_for'; return 1; }

    # We require PS and GREP commands
    local PS
    PS=$( command_exists ps ) || { set_state "${FUNCNAME[0]}" 'error_dependency_not_met_ps_command'; return 1; }

    local GREP
    GREP=$( command_exists grep ) || { set_state "${FUNCNAME[0]}" 'error_dependency_not_met_grep_command'; return 1; }

    # Get current user. Note: the ${USER} environment is NOT set when running as 'root' in docker, we must use f-n get_current_user() instead.
    local CURRENT_USER
    CURRENT_USER="$(get_current_user)" || { error "Can not get current user"; return 1; }

    ${PS} -u "${CURRENT_USER}" -U "${CURRENT_USER}" o command | ${GREP} --silent -e "^${COMMAND_PATTERN}"
    STATUS=${?}
    set_state "${FUNCNAME[0]}" 'success'
    return ${STATUS}
}
export -f process_is_running_as_me

###############################################################################
# Category: UTILITY FUNCTIONS: PROCESS
#
# Auxiliary method to retry a command several times up to the given number of maximum
# attempts with sleeping given number of seconds between retries.
#
# Return code:
#   0 - command executed successfully
#   non-zero code - command failed after all attempts or bad arguments (check by "get_state retry_command")
#                   Note: the error code will be actual command exit code returned on the last failed attempt.
#
# Synopsis:
#       retry_command retry_attempts_max sleep_between_tries_seconds some_command [command_arguments...]
#
# Usage example:
#       # Retry up to 5 times to install_xyz(), sleep 10 seconds between tries
#       retry_command 5 10 install_xyz || { abort "failed_to_install_xyz"; }
# 
# Note: this function does not have state, i.e. the set_state() is not used
# to indicate start/success (only for errors or failed attempts).
function retry_command {

    # Get number of max attempts
    RETRY_ATTEMPTS_MAX=$1
    # Shift all arguments to the left (original $1 gets lost)
    shift

    # Check argument not empty and >0
    [ "${RETRY_ATTEMPTS_MAX}" != "" ] || { set_state "${FUNCNAME[0]}" 'failed_to_get_retry_attempts_max'; return 1; }
    [ "${RETRY_ATTEMPTS_MAX}" -gt 0 ] || { set_state "${FUNCNAME[0]}" 'error_retry_attempts_max_must_be_positive_number'; return 1; }

    # Get number of seconds to sleep between attempts
    SLEEP_SECONDS=$1
    shift # Shift all arguments to the left (original $1 gets lost)

    # Check argument not empty & >1
    [ "${SLEEP_SECONDS}" != "" ] || { set_state "${FUNCNAME[0]}" 'failed_to_get_sleep_seconds'; return 1; }
    [ "${SLEEP_SECONDS}" -gt 0 ] || { set_state "${FUNCNAME[0]}" 'error_sleep_seconds_must_be_postive_number'; return 1; }

    # Get the rest of the arguments as an array
    local COMMAND_AS_ARRAY=("$@")

    # Check: the command as array must be non-empty
    [ ! -z "${COMMAND_AS_ARRAY}" ] || { set_state "${FUNCNAME[0]}" 'error_got_empty_command'; return 1; }

    # Attempts loop: we will break out of the loop only if command is succeed or 
    local ATTEMPT_COUNT=0
    local FAILED_COMMAND_EXIT_CODE=0
    while [ ${ATTEMPT_COUNT} -lt ${RETRY_ATTEMPTS_MAX} ]
    do
        # Increment attempts counter
        ATTEMPT_COUNT=$((ATTEMPT_COUNT+1)) 

        # Try the command and break the loop (by return 0) if succeed
        "${COMMAND_AS_ARRAY[@]}" && return 0
        
        # Preserve actual exit code returned by failed command (this will be non-zero value)
        FAILED_COMMAND_EXIT_CODE=$?

        # Sleep only if not last attempt
        [ ${ATTEMPT_COUNT} -lt ${RETRY_ATTEMPTS_MAX} ] && sleep ${SLEEP_SECONDS}
    done

    # Command failed on all attempts
    set_state "${FUNCNAME[0]}" "failed_after_all_attempts"

    # Return preserved bad code returned by the command
    return ${FAILED_COMMAND_EXIT_CODE}
}
export -f retry_command

### END UTILITY FUNCTIONS: PROCESS


### BEGIN UTILITY FUNCTIONS: STATE/SECRETS

###############################################################################
# Category: UTILITY FUNCTIONS: PROCESS
# 
# Utility function generates 16 characters long password, which is printed to standard output.
# Depends on: dd, uudecode, sed, cut.
#
# Return code:
#    0 - success
#    any other code - error (for example missing dependency)
#
# Example of generated passwords:
#   /1/JvZ15LwXklSxx
#   Pd/09PmvGhXxMfBz
#   btRaFaOLs9zGLtVn
#   OJVT51iMHaE8nc5d
#   eE75MMQY8oIffoQA
#   mySB9+mic1mTmls7
#   l3JWm41xmzXdzQOq
#   47Fetd0UGs1wk24Q
#   F8Jak2Wc9JM3CiWb
#   jYY5yq6nYjK2TOWn
#
function generate_strong_password {
    # Works on Linux and Mac
    # Makes password 16 characters long
    # XXXX
    local DEPENDENCIES="dd uudecode sed cut"
    for DEPENDENCY in ${DEPENDENCIES}
    do
      if ! command_exists ${DEPENDENCY} >/dev/null; then
          error "${FUNCNAME[0]}" "error_dependency_not_met_command_${DEPENDENCY}_not_found"
          return 1
      fi
    done
      
    dd if=/dev/urandom count=1 2> /dev/null | uuencode -m - | sed -ne 2p | cut -c-16
}
export -f generate_strong_password

###############################################################################
# Category: UTILITY FUNCTIONS: PROCESS
# Function get_state() allows to get state set (by string name).
# Return value:
#   - if state found by given state name, print its value to standard output and return code 0
#   - if state not found, print nothing into standard output and return code 1
#
function get_state {

  # Preserve current bash echo settings and enable bash echo setting
  BASH_ECHO_SETTINGS=$( get_bash_echo_setting ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_bash_echo_settings'; return 1; }

  set_bash_echo_off || { set_state "${FUNCNAME[0]}" 'failed_to_set_bash_echo_off'; return 1; } # Disable xtrace to avoid priting secrets

  # Get 1 argument: state name
  STATE_NAME="${1}"

  # Check state name isn't
  [ ! -z "${STATE_NAME}" ] || { error "get_state(): blank state name argument"; return 1; }

  # Check if state name contains any prohibited symbols, then error out.
  [[ ! "${STATE_NAME}" =~ ([^a-z0-9_]+) ]] || { error "get_state(): illigal characters in the state name argument: '${BASH_REMATCH[1]}'"; return 1; }

  # Make sure "${FF_AGENT_HOME}" is not empty
  if [ -z "${FF_AGENT_HOME}" ]; then
      error "Can not set state. FF_AGENT_HOME variable not defined. State would have been set to ${STATE_NAME}=${VALUE}"
      set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
      return 1
  fi

  # Construct path to the state file
  STATE_DIR="${FF_AGENT_HOME}/state"
  STATE_FILE="${STATE_DIR}/${STATE_NAME}"

  # Check if state file exists
  if [ -f "${STATE_FILE}" ]; then
    # State file found, try to print it's content and preserve result code
    VALUE="$( cat "${STATE_FILE}" )"
    EXIT_CODE=${?}
    # Print value to standard output
    echo -n "${VALUE}"
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    return ${EXIT_CODE}
  else
    # Error: state file not found. Restore xtrace and eturn code 1
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    return 1
  fi
}
export -f get_state

###############################################################################
# Category: UTILITY FUNCTIONS: PROCESS
# Utility function, getting secret value by given secret key name.
# Note: secret_get() require the FF_AGENT_HOME to be set.
function secret_get {
  
  # Dependency check: 'tr' is installed
  if ! command_exists tr >/dev/null; then
    set_state "${FUNCNAME[0]}" 'error_dependency_not_met_tr'
    return 1
  fi

  # Preserve current bash echo settings and enable bash echo setting
  BASH_ECHO_SETTINGS=$( get_bash_echo_setting ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_bash_echo_settings'; return 1; }

  set_state "${FUNCNAME[0]}" 'started'

  set_bash_echo_off || { set_state "${FUNCNAME[0]}" 'failed_to_set_bash_echo_off'; return 1; } # Disable xtrace to avoid priting secrets

  local KEY="${1}"

  # Check KEY is not blank
  [ ! -z "${KEY}" ] || { error "secret_get(): blank KEY argument"; return 1; }

  # Check if KEY contains any prohibited symbols, then error out.
  [[ ! "${STATE_NAME}" =~ ([^a-z0-9_]+) ]] || { 
    set_state "${FUNCNAME[0]}" 'error_bad_argument_illigal_charaacters_in_key'
    return 1
  }

  # Check if FF_AGENT_HOME is not empty
  if [ "${FF_AGENT_HOME}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    set_state "${FUNCNAME[0]}" 'error_ff_agent_home_not_set'
    return 1
  fi

  # Check if key is not empty
  if [ "${KEY}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    set_state "${FUNCNAME[0]}" 'error_empty_key'
    return 1
  fi

  # Due to the previous runs we sometimes end up with secret files having 'null' as a value (4-byte).
  # Let's run cleanup only once (upon 1st call) and set the flag to avoid any futher cleaning ups during this run.
  # Note: -z - true if the length of string is zero
  #       -n - true if the length of string is nonzero
  if [ -z "${GET_SECRET_WIPE_NULLS_RUN_ONCE_FLAG}" ]; then
      # Note: --files-with-matches - Suppress normal output; instead print the  name  of  each  input
      #                              file  from  which  output would normally have been printed.  The
      #                              scanning will stop on the first match.
      grep --files-with-matches null "${FF_AGENT_HOME}/secrets/*" 2>/dev/null | xargs rm 2>/dev/null
      GET_SECRET_WIPE_NULLS_RUN_ONCE_FLAG="any non empty string can be 'a flag'"
  fi

  # Case: requested key already exists in ff_agent "secrets/" folder
  if [ -e "${FF_AGENT_HOME}/secrets/${KEY}" ]; then
      cat "${FF_AGENT_HOME}/secrets/${KEY}"
      set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
      set_state "${FUNCNAME[0]}" 'success'
      return
  fi

  # Case: cloud user-data JSON exists: search value by given KEY in it under "agent/configuration"
  if [ -e /var/lib/cloud/instance ]; then

      # Generic case: get value by given KEY from root level of agent/configuration JSON
      VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq '.[] | select(.mime_type=="agent/configuration")' | jq -r ".${KEY}" | grep -v -e '^null$' )
      # Note: -z - true if the length of string is zero
      #       -n - true if the length of string is nonzero
      if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
          echo ${VALUE}
          set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
          set_state "${FUNCNAME[0]}" 'success'
          return
      fi

      # Special case for "ff_api_username" and "ff_api_password" - these 2 values
      # are nexted few levels deep in "agent/configuration"
      if [ "${KEY}" == "ff_api_username" ] || [ "${KEY}" == "FF_API_USERNAME" ]; then
        # TODO: here we rely on provisioning JSON on agent to have "control_api_user", which is incorrectly named and must be redesigned completely.
        VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq -r '.[] | select(.mime_type == "agent/configuration") | .roles[] | select(.role_name == "AgentRole") | .services[] | select(.service_name == "ActionManager") | .control_api_user' )
        if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
            echo ${VALUE}
            set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
            set_state "${FUNCNAME[0]}" 'success'
            return
        fi
      fi
      if [ "${KEY}" == "ff_api_password" ] || [ "${KEY}" == "FF_API_PASSWORD" ]; then
        # TODO: here we rely on provisioning JSON on agent to have "control_api_password", which is incorrectly named and must be redesigned completely.
        VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq -r '.[] | select(.mime_type == "agent/configuration") | .roles[] | select(.role_name == "AgentRole") | .services[] | select(.service_name == "ActionManager") | .control_api_password' )
        if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
            echo ${VALUE}
            set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
            set_state "${FUNCNAME[0]}" 'success'
            return
        fi
      fi
  fi

  # Case: search in "provisioning/instance"
  if [ -e /var/lib/cloud/instance ]; then
      VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq '.[] | select(.mime_type=="provisioning/instance")' | jq -r ".${KEY}" | grep -v -e '^null$' )
      # Note: -z - true if the length of string is zero
      #       -n - true if the length of string is nonzero
      if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
          echo ${VALUE}
          set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
          set_state "${FUNCNAME[0]}" 'success'
          return
      fi
  fi

  # Case: We are on a local VM agent - let's check user_data.editor_answers.json
  USER_DATA="/etc/ff/configuration/user_data.editor_answers.json"
  if [ -e "${USER_DATA}" ]; then
    VALUE=$( cat "${USER_DATA}" | jq ".${KEY}" | cut -d'"' -f2 )
      if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
          set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
          echo ${VALUE}
          set_state "${FUNCNAME[0]}" 'success'
          return
      fi
  fi

  # Case: We are on a new build (blank cloud box with user_data.json injected as: /etc/ff/configuration/user_data.json )
  if [ -f /etc/ff/configuration/user_data.json ]; then
      VALUE=$( sudo cat /etc/ff/configuration/user_data.json | jq '.[] | select(.mime_type=="agent/configuration")' | jq -r ".${KEY}" | grep -v -e '^null$' )
      if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
          set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
          echo ${VALUE}
          set_state "${FUNCNAME[0]}" 'success'
          return
      fi
  fi

  # Case: We're looking for KEY=="FF_AGENT_URI" and we are on a traffic_generator.
  # In this case FF_AGENT_URI was already generated and stored to /etc/ff/configuration/agent_uri
  # Let's retreive it from there and re-store it by secret_set()
  if [ "${KEY}" == "ff_agent_uri" ] && [ -f /etc/ff/configuration/agent_uri ]; then
    FF_AGENT_URI="$( cat /etc/ff/configuration/agent_uri )"
    # Store "agent" to proper unified place for secrets, so we don't have to look for it in random places again next time.
    if [ ! -z "${FF_AGENT_URI}" ]; then
      secret_set ff_agent_uri "${FF_AGENT_URI}"
      set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
      echo "${FF_AGENT_URI}"
      set_state "${FUNCNAME[0]}" 'success'
      return
    fi
  fi

  # Case: We are on a legacy portal server in Amazon
  for environment in production staging development
  do
      ENVPATH="${HOME}/.control/environment/${environment}"
      if [ -e "${ENVPATH}" ]; then
          VALUE=$( grep -i "^${KEY}=" ${ENVPATH}/* | cut -d= -f2 | head -1 )
          if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
              echo ${VALUE}
              set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
              set_state "${FUNCNAME[0]}" 'success'
              return
          fi
      fi
  done

  set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
  set_state "${FUNCNAME[0]}" 'failed_to_find_secret_value'
  return 1
}
export -f secret_get

###############################################################################
# Category: UTILITY FUNCTIONS: PROCESS
# Utility function to set secret key/value pair.
# Example:
# secret_set readonly_api_password "my-password"
#
function secret_set {

  # Preserve current bash echo settings and enable bash echo setting
  BASH_ECHO_SETTINGS=$( get_bash_echo_setting ) || { error "${FUNCNAME[0]}" 'failed_to_get_bash_echo_settings'; return 1; }

  set_bash_echo_off || { error "${FUNCNAME[0]}" 'failed_to_set_bash_echo_off'; return 1; } # Disable xtrace to avoid priting secrets

  # Get arguments
  local URI="${1}"
  local SECRET="${2}"

  # Check FF_AGENT_HOME is set
  [ ! -z "${FF_AGENT_HOME}" ] || {
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" 'error_envirnment_not_set_ff_agent_home'
    return 1
  }

  # Check URI is not blank
  [ ! -z "${URI}" ] || {
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" 'error_blank_uri_argument'
    return 1
  }

  # Check if URI contains any prohibited symbols, then error out.
  [[ ! "${URI}" =~ ([^a-z0-9_]+) ]] || {
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" 'error_illigal_characters_in_uri_argument'
    return 1
  }

  # Check SECRET is not empty
  if [ -z "${SECRET}" ]; then
      set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
      error "${FUNCNAME[0]}" 'error_bad_argument_secret'
      return 1
  fi

  # Create secrets directory
  local SECRET_DIRECTORY="${FF_AGENT_HOME}/secrets"
  mkdir -p "${SECRET_DIRECTORY}" || {
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" 'failed_to_create_secrets_directory'
    return 1
  }

  # Store secret
  echo "${SECRET}" >"${SECRET_DIRECTORY}/${URI}" || { 
    error "${FUNCNAME[0]}" 'failed_to_write_secret'
    return 1
  }

  set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
}
export -f secret_set

###############################################################################
# Category: UTILITY FUNCTIONS: PROCESS
#
# The set_state() function require "${FF_AGENT_HOME}" to be set to non-empty string.
#
# Note: each call to "set_state()" will also generate a JSON wich will be published
# by calling "publish_message()".
#
function set_state {

  # Get 2 arguments: state and value
  local STATE_NAME="${1}"
  local STATE_VALUE="${2}"

  # Check state name / value aren't blank
  [ ! -z "${STATE_NAME}" ] || { error "set_state(): blank state name argument"; return 1; }
  [ ! -z "${STATE_VALUE}" ] || { error "set_state(): blank state value argument"; return 1; }

  # Check if state name / vaue contains any prohibited symbols, then error out.
  [[ ! "${STATE_NAME}" =~ ([^a-z0-9_]+) ]] || { error "set_state(): illigal characters in the state name argument: '${BASH_REMATCH[1]}'"; return 1; }
  [[ ! "${STATE_VALUE}" =~ ([^a-z0-9_]+) ]] || { error "set_state(): illigal characters in the state value argument: '${BASH_REMATCH[1]}'"; return 1; }
  
  # Make sure "${FF_AGENT_HOME}" is not empty
  if [ -z "${FF_AGENT_HOME}" ]; then
      error "Can not set state. FF_AGENT_HOME variable not set. State would have been set to ${STATE_NAME}=${STATE_VALUE}"
      return 1
  fi

  local STATE_DIR="${FF_AGENT_HOME}/state"

  # Make state directory
  if [ ! -d "${STATE_DIR}" ]; then
    
    mkdir -p "${STATE_DIR}" || {
      error "Can not set state. State directory ${STATE_DIR} can not be created. State would have been set to ${STATE_NAME}=${STATE_VALUE}"
      return 1; 
    }
  fi

  # Define state filename
  local STATE_FILE="${STATE_DIR}/${STATE_NAME}"

  # Write value into the file
  echo "${STATE_VALUE}" >"${STATE_FILE}" || { error "${FUNCNAME[0]}: failed_to_write_state. State would have been set to ${STATE_NAME}=${STATE_VALUE}"; return 1; }

  # ------------------ Build JSON object "state/change" and send to FF_HOST

  # Check if framework API is defined
  if [ "$( is_framework_api_defined )" != "true" ]; then
    # No, the framework API is not defined. Simply return, we're done.
    # Return with success code 0
    return 0
  fi

  # Get current epoch time
  local TIMESTAMP_EPOCH_MS="$( get_epoch_ms )"
  
  # Check if we actually got non-empty string?
  [ ! -z "${TIMESTAMP_EPOCH_MS}" ] || { error "${FUNCNAME[0]}: failed_to_get_epoch_ms"; return 1; }
  
  # If state value contains: success|running, then: "is_success": true
  # else
  #   if state value contains: error|fail|'', then "is_error": true
  # else
  #   don't include neither "is_success" nor "is_error".
  local IS_SUCCESS_OR_IS_ERROR_JSON=''
  local IS_ERROR=false
  if [[ "${STATE_VALUE}" =~ success|running ]]; then
    IS_SUCCESS_OR_IS_ERROR_JSON='"is_success": true,'
  else
    if [[ "${STATE_VALUE}" == '' || "${STATE_VALUE}" =~ error|fail ]]; then
      IS_SUCCESS_OR_IS_ERROR_JSON='"is_error": true,'
      IS_ERROR=true
    fi
  fi

  # Get previous "old" state value
  local PREVIOUS_STATE_JSON=""
  local PREVIOUS_STATE_VALUE="$( cat ${STATE_FILE} )"
  # Only include "old_state" property if it is not-empty string
  if [ "${PREVIOUS_STATE_VALUE}" != "" ]; then
    PREVIOUS_STATE_JSON="\"previous_state\": \"${PREVIOUS_STATE_VALUE}\","
  fi

  # Compose "state/chate" JSON and pipe it to publish_message()
  # Note: we POST "state/change" JSON to ff_host. (from portal to self, from 'traffic generator' to portal, from 'inside docker' to (agent?)).
  local UUID
  UUID="$( ff_uuid )" || { error "${FUNCNAME[0]}" 'failed_generate_uuid'; return 1; }

  # Check: all the environment variables used in JSON are actually set.
  local ALL_EXPECTED_ENVRIONMENT_VARIABLES=(
    FF_AGENT_URI
    FF_AGENT_USERNAME
    FF_HOST
    HOSTNAME
    IS_SUCCESS_OR_IS_ERROR_JSON
    MIME_TYPE
    NAMESPACE
    ORGANIZATION
    STATE_NAME
    STATE_VALUE
    TIMESTAMP_EPOCH_MS
    UUID
  )

  for VARIABLE_NAME in "${ALL_EXPECTED_ENVRIONMENT_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      local ERROR_CODE=$( echo "error_environment_check_required_variables_are_set_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )
      error "${FUNCNAME[0]}: ${ERROR_CODE}"
      return 1
    }
  done

  # Define mime_type
  MIME_TYPE="state/change"

  # Commpose JSON and publish it
  (
    cat <<- EOF
{
  "mime_type": "${MIME_TYPE}",
  "uri_template": "/set_environment/[mime_type]/id/[id]/[uuid]",
  "uri": "${NAMESPACE}::/set_environment/${MIME_TYPE}/id/${STATE_NAME}/${UUID}",
  "uuid": "${UUID}",
  "id": "${STATE_NAME}",
  "state": "${STATE_VALUE}",
  ${PREVIOUS_STATE_JSON}
  ${IS_SUCCESS_OR_IS_ERROR_JSON}
  "timestamp_epoch_ms": ${TIMESTAMP_EPOCH_MS},
  "ff_agent_uri": "${FF_AGENT_URI}",

  "is_event": true,
  "event_type": "set_environment",
  "source": "set_environment",
  "hostname": "${HOSTNAME}",
  "ff_host": "${FF_HOST}",

  "namespace": "${NAMESPACE}",
  "organization": "${ORGANIZATION}",
  "created_by": {
    "mime_type": "identity/statement",
    "user_id": $( id -u ${FF_AGENT_USERNAME} ),
    "username": "${FF_AGENT_USERNAME}"
  },
  "security_object_policy": {
    "mime_type": "security/object_policy",
    "schema_version": "ff20170505",
    "policy_language": "ff",
    "scope": {
      "can_read": "organization",
      "can_write": "system",
      "can_delete": "system"
    }
  }
}
EOF
) | publish_message

  # If we have ff_metric command handy try to sent the metric
  if command_exists ff_metric >/dev/null; then
    # Report metric: start:1    tags: service:ipsec_tunnel  (+public_ip, organization)
    ff_metric --metric-name="${STATE_NAME}" --metric-value=1 --tag=state:"${STATE_VALUE}" --tag=is_error:"${IS_ERROR}"
  fi
}
export -f set_state

### END UTILITY FUNCTIONS: STATE/SECRETS



### BEGIN UTILITY FUNCTIONS: USER / GROUPS

###############################################################################
# Category: UTILITY FUNCTIONS: USER / GROUPS
# Utility function - Can I sudo?
# @param1 user_to_check
function can_sudo {
    local USER_TO_CHECK="${1}"

    local USER_CAN_SUDO=1  # Assume they can't. 1 is an error code meaning we can't.

    # SUDOers can be defined in a few places - /etc/sudoers and /etc/sudoers.d/*
    # Note: /etc/sudoers is old and bad
    if sudo --non-interactive --list --other-user="${USER_TO_CHECK}" &>/dev/null true
    then
        USER_CAN_SUDO=0
    else
        if groups "${USER_TO_CHECK}" 2>/dev/null | grep --text "\<sudo\>" &> /dev/null; then
            USER_CAN_SUDO=0 # I can sudo
        else
            USER_CAN_SUDO=1 # I can't sudo
        fi
    fi

    # TODO: If user can sudo, have that user check if they are in old /etc/sudoers or new form
    # and emit error otherwise.

    return ${USER_CAN_SUDO}
}
export -f can_sudo

###############################################################################
# Category: UTILITY FUNCTIONS: USER / GROUPS
# Utility function check_group_exists takes one argument (group name) and return 0 if such group exists.
# Return:
#  0 - group exists
#  1 - group does not exist or no arguments given
#
# Usage example:
#   if ! check_group_exists 'docker'; then error "Group docker does not exist"; fi
#
function check_group_exists {
  # Take argument
  local GROUP="${1}"

  # Check argument is not empty
  if [ -z "${GROUP}" ]; then
    error "check_group_exists() called with no arguments"
    return 1
  fi

  # Check if the group exist by given groupname
  getent group "${GROUP}" >/dev/null
}
export -f check_group_exists

###############################################################################
# Category: UTILITY FUNCTIONS: USER / GROUPS
# Utility function - Create User, with a disabled password
function create_user {
  local USERNAME="${1}"
	if [ ! -z "${USERNAME}" ]; then
		if can_sudo "${USERNAME}"; then
        	# TODO: Make this multiplatform. Check what happens if we do this in a docker.
        	sudo adduser --disabled-password --gecos "" "${USERNAME}"
			return ${?}
		fi
	fi
	return 1
}
export -f create_user

###############################################################################
# Category: UTILITY FUNCTIONS: USER / GROUPS
# Utility function - Am I root? Return 0 if I am, 1 if not
function is_effectively_root {
    if  [ "${EUID}" -eq 0 ]; then
        return 0 # I have root powers
    else
        return 1 # Don't have root powers
    fi
}
export -f is_effectively_root

###############################################################################
# Category: UTILITY FUNCTIONS: USER / GROUPS
# Utility function - Get home directory for user
function get_home_directory_for_user {
    # TODO: OSX doesn't have getent. Find Equivalent
    HOME_DIR=$( getent passwd "${1}" | cut -d: -f6 )
    if [ -z "${HOME_DIR}" ]; then
        return 1
    else
        echo "${HOME_DIR}"
    fi
}
export -f get_home_directory_for_user

###############################################################################
# Category: UTILITY FUNCTIONS: USER / GROUPS

# Utility function - Get cmdline of parent process ID -- useful to know who is starting us
# E.g. if [ $( get_ppid_cmd | grep --text -c node ) -gt "0" ] -> will let you check if your parent process is nodejs
function get_ppid_cmd {
    local PPID_CMD=$( cat /proc/${PPID}/cmdline )
    echo "${PPID_CMD}"
}
export -f get_ppid_cmd

###############################################################################
# Category: UTILITY FUNCTIONS: USER / GROUPS
# Utility function - check if user is in a group
# Usage: 
# if is_user_in_group "user" "group"; then ...
#
function is_user_in_group {
  local USERNAME="${1}"
  local GROUP="${2}"
  [ -z "${USERNAME}" ] && return 1
  [ -z "${GROUP}" ] && return 1
  if getent group "${GROUP}" | grep --quiet "\b${USERNAME}\b"; then
      return 0
  else
      return 1
  fi
}
export -f is_user_in_group

###############################################################################
# Category: UTILITY FUNCTIONS: USER / GROUPS
# Utility function - Check if User Exists
function user_exists {
    # TODO: OSX doesn't have getent. Find Equivalent
    if [ -z "$(getent passwd ${1})" ]; then
        return 1 # User does not exist
    else
        return 0 # User exists
    fi
}
export -f user_exists

### END UTILITY FUNCTIONS: USER / GROUPS



### BEGIN DISCOVER FUNCTIONS

###############################################################################
# Category: DISCOVERY
# Auxiliary function wraps the logic of choosing the best value for: 'FF_AGENT_URI'
# Note: this function uses get/set secrets and state, thus it can be called only after "choose proper user" step is complete.
#
# Function return:
#   - on success: return code 0 and choosen value printed to standard outout
#   - on failure: return code 1
#
# Usage example:
#    FF_AGENT_URI=$( ff_agent_get_best_ff_agent_uri ) || { set_state "${FUNCNAME[0]}" "failed_to_ff_agent_get_best_ff_agent_uri"; return 1; }
#
function ff_agent_get_best_ff_agent_uri {

  # Try to get FF_AGENT_URI from environment or by secret_get()
  discover_optional_environment_variable "FF_AGENT_URI" || { error "${FUNCNAME[0]}" "failed_to_discover_optional_environment_variable"; return 1; }

  # Check if variable already set. If not set - generate new uuid
  if [ -z "${FF_AGENT_URI}" ]; then
      # Generate new uuid, check errors, export new value
      local UUID
      UUID="$( ff_uuid )" || { error "${FUNCNAME[0]}" "failed_to_generate_new_uuid"; return 1; }
      FF_AGENT_URI="/agent/agent_uuid/${UUID}"
  fi

  # At this point we must have not empty FF_AGENT_URI value.
  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'FF_AGENT_URI' || { error "${FUNCNAME[0]}" "error_ensure_variable_not_empty_ff_agent_uri"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${FF_AGENT_URI}"
}
export -f ff_agent_get_best_ff_agent_uri

###############################################################################
# Category: DISCOVERY
# Auxiliary function wraps the logic of choosing the best value for: 'FF_CONTENT_URL'
# Note: this function uses get/set secrets and state, thus it can be called only after "choose proper user" step is complete.
#
# Function return:
#   - on success: return code 0 and choosen value printed to standard outout
#   - on failure: return code 1
#
# Usage example:
#  FF_CONTENT_URL=$( ff_agent_get_best_ff_content_url )
#  [ ${?} -eq 0 ] || { set_state "${FUNCNAME[0]}" "failed_to_ff_agent_get_best_ff_content_url"; return 1; }
#
function ff_agent_get_best_ff_content_url {

  # Try to get FF_CONTENT_URL from environment or by secret_get()
  discover_optional_environment_variable "FF_CONTENT_URL" || { error "${FUNCNAME[0]}" "failed_to_discover_optional_environment_variable"; return 1; }

  # Remove trailing slash from FF_CONTENT_URL, so it works correctly when we concatenate
  # FF_CONTENT_URL with other path components (e.g.: ${}/subfolder/file.txt)
  # Note: its save to call trim_slash() even if FF_CONTENT_URL is empty at this step.
  FF_CONTENT_URL="$( trim_slash "${FF_CONTENT_URL}" )" || { error "${FUNCNAME[0]}" "error_trim_slash_from_ff_content_url"; return 1; }

  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'FF_CONTENT_URL' || { error "${FUNCNAME[0]}" "error_ensure_variable_not_empty_ff_content_url"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${FF_CONTENT_URL}"
}
export -f ff_agent_get_best_ff_content_url

###############################################################################
# Category: DISCOVERY
# Auxiliary function wraps the logic of choosing the best value for: 'FF_HOST'
# Note: this function uses get/set secrets and state, thus it can be called only after "choose proper user" step is complete.
#
# Function return:
#   - on success: return code 0 and choosen value printed to standard outout
#   - on failure: return code 1
#
# Usage example:
#  UPLOAD_TO=$( ff_agent_get_best_ff_host )
#  [ ${?} -eq 0 ] || { set_state "${FUNCNAME[0]}" "failed_to_ff_agent_get_best_ff_host"; return 1; }
#
function ff_agent_get_best_ff_host {

  # Try to get FF_HOST from environment or by secret_get()
  discover_optional_environment_variable "FF_HOST" || { error "${FUNCNAME[0]}" "failed_to_discover_optional_environment_variable_ff_host"; return 1; } # Note: FF_HOST: FF_HOST will be set to legacy portal hostname if this is a portal.

  # Check if variable already set. If not try to get it's value by command 'hostname'
  [ -z "${FF_HOST}" ] && { FF_HOST="$( hostname )"; }

  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'FF_HOST' || { error "${FUNCNAME[0]}" "error_ensure_variable_not_empty_ff_host"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${FF_HOST}"
}
export -f ff_agent_get_best_ff_host

###############################################################################
# Category: DISCOVERY
# Auxiliary function wraps the logic of choosing the best value for: 'FF_HOST'
# Note: this function uses get/set secrets and state, thus it can be called only after "choose proper user" step is complete.
#
# Function return:
#   - on success: return code 0 and choosen value printed to standard outout
#   - on failure: return code 1
#
function ff_agent_get_best_ff_port {
  FF_PORT_DEFAULT=443

  # Try to get FF_PORT from environment or by secret_get()
  discover_optional_environment_variable "FF_PORT" || { error "${FUNCNAME[0]}" "failed_to_discover_optional_environment_variable_ff_port"; return 1; }

  # Check if variable already set. If not then use default
  [ -z "${FF_PORT}" ] && { FF_PORT="${FF_PORT_DEFAULT}"; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${FF_PORT}"
}
export -f ff_agent_get_best_ff_port

###############################################################################
# Category: DISCOVERY
function ff_agent_get_best_namespace {

  # Try to get value from environment or by secret_get()
  discover_optional_environment_variable "NAMESPACE" || { error "${FUNCNAME[0]}" "failed_to_discover_optional_environment_variable_namespace"; return 1; }

  # Check if variable already set. If not set it to our default "system.local" namespace: '00000000-0000-0000-0000-000000000000'.
  [ -z "${NAMESPACE}" ] && { NAMESPACE='00000000-0000-0000-0000-000000000000'; }

  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'NAMESPACE' || { error "${FUNCNAME[0]}" "error_ensure_variable_not_empty_namespace"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${NAMESPACE}"
}
export -f ff_agent_get_best_namespace

###############################################################################
# Category: DISCOVERY
function ff_agent_get_best_organization {

  # Try to get value from environment or by secret_get()
  discover_optional_environment_variable "ORGANIZATION" || { error "${FUNCNAME[0]}" "failed_to_discover_optional_environment_variable_organization"; return 1; }

  # Check if variable already set. If not set it to our default organization "system.local"
  [ -z "${ORGANIZATION}" ] && { ORGANIZATION='system.local'; }

  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'ORGANIZATION' || { error "${FUNCNAME[0]}" "error_ensure_variable_not_empty_organization"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${ORGANIZATION}"
}
export -f ff_agent_get_best_organization

###############################################################################
# Category: DISCOVERY
# Function ff_uuid() generates UUID and prints it to the standard output.
# Dependency: uuidgen
# Note: function will try to install dependency if missing.
#
# Function return code:
#   0 - success
#   1 - failure
#
# Usage example:
#    NEW_UUID=$( ff_uuid )
#    [ ${?} -eq 0 ] || { set_state "${FUNCNAME[0]}" "failed_to_ff_uuid"; return 1; }
#
function ff_uuid {

  # Check dependency: "uuidgen" we need to make sure it is installed ('uuidgen' is part of 'uuid-runtime' package)
  if ! command_exists uuidgen >/dev/null; then

    # Try to install missing dependency
    apt_update >/dev/null
    [ $? -ne 0 ] || { error "uuidgen is missing and failed to apt_update"; return 1; }

    apt_install uuid-runtime >/dev/null  # Note: we mute output of apt-install otherwise it will be mixed into the ff_uuid() function result!
    [ $? -ne 0 ] || { error "uuidgen is missing and failed to apt_install it"; return 1; }

    # Check again
    if ! command_exists uuidgen >/dev/null; then
      # Still failing to find uuidgen, return error
      return 1
    fi
  fi

  # Generate uuid and return it's exit code as a return code
  uuidgen
}
export -f ff_uuid

###############################################################################
# Category: DISCOVERY
# Figure out environment - where are we?
#
# First the function is trying to choose right FF_AGENT_HOME, then it
# gets the best values for the following environment variables:
#    - FF_CONTENT_URL
#    - FF_AGENT_URI
#    - FF_HOST
#
# Dependencies:
#    - FF_CONTENT_URL variable must be set either by "secret_set()" or in environment variable
#
# Function return code:
#   0 - on success
#   1 - on failure
#
function discover_environment {

  ######################################################################
  # Choose user, agent home and make sure agent home folder exists
  #
  # Choose proper user to run as create "ff_agent" folder (known as ${FF_AGENT_HOME}).
  # The proper user is not root but user with sudo that can install packages.
  # We need to get_best_ff_agent_home before we can set/get secrets.
  # This sets some of environment variables: FF_AGENT_USERNAME, FF_AGENT_HOME.
  # Also creates FF_AGENT_HOME directory.
  # Baseline installer must set the following environment variables:
  #  [x] FF_AGENT_USERNAME  (see get_best_ff_agent_home())
  #  [x] FF_AGENT_USER_HOME (see get_best_ff_agent_home())
  #  [x] FF_AGENT_HOME      (see get_best_ff_agent_home())
  #  [x] FF_AGENT_URI (see ff_agent_get_best_ff_agent_uri())
  #  [x] FF_HOST (see ff_agent_get_best_ff_host())
  #  [x] FF_CONTENT_URL (see ff_agent_get_best_ff_content_url())
  #  [x] NAMESPACE (see ff_agent_get_best_namespace())
  #  [x] N_PREFIX (see install_n())
  #  [x] ORGANIZATION (see ff_agent_get_best_organization())
  #  [x] TERM  (see terminal_initialize())
  #
  # Preserving a set of other discussed environment values to add in future:
  #  FF_PROTOCOL
  #  FF_API_TOKEN
  #  FF_PROXY_HOST
  #  FF_PROXY_PORT
  #  FF_PROXY_PROTOCOL
  #  FF_PROXY_USERNAME
  #  FF_PROXY_PASSWORD
  #
  get_best_ff_agent_home || { abort "failed_to_get_best_ff_agent_home"; }
  assert_ff_agent_home_exists || { abort "failed_to_assert_ff_agent_home_exists"; }

  # Get best values, check errors, export and secret_set().
  FF_CONTENT_URL=$( ff_agent_get_best_ff_content_url ) || { abort "failed_to_ff_agent_get_best_ff_content_url"; }
  secret_set ff_content_url "${FF_CONTENT_URL}"
  export FF_CONTENT_URL

  # Similarly for best NAMESPACE
  NAMESPACE=$( ff_agent_get_best_namespace ) || { abort "failed_to_ff_agent_get_best_namespace"; }
  secret_set namespace "${NAMESPACE}"
  export NAMESPACE

  # Similarly for best ORGANIZATION
  ORGANIZATION=$( ff_agent_get_best_organization ) || { abort "failed_to_ff_agent_get_best_organization"; }
  secret_set organization "${ORGANIZATION}"
  export ORGANIZATION

  # Similarly for FF_AGENT_URI
  FF_AGENT_URI=$( ff_agent_get_best_ff_agent_uri )     || { abort "failed_to_ff_agent_get_best_ff_agent_uri"; }
  secret_set ff_agent_uri "${FF_AGENT_URI}"
  export FF_AGENT_URI

  FF_HOST=$( ff_agent_get_best_ff_host )               || { abort "failed_to_ff_agent_get_best_ff_host"; }
  secret_set ff_host "${FF_HOST}"
  export FF_HOST

  FF_PORT=$( ff_agent_get_best_ff_port )               || { abort "failed_to_ff_agent_get_best_ff_port"; }
  secret_set ff_port "${FF_PORT}"
  export FF_PORT

  # ######################################################################
  # # Discover set of "ff environment" variables
  # discover_ff_environment || { set_state "${FUNCNAME[0]}" "failed_to_discover_ff_environment"; return 1; }

}
export -f discover_environment

# ###############################################################################
# # Category: DISCOVERY
# function discover_ff_environment {

#     # Define 2 lists of variable names and default values: required and optional.
#     # It creates a local variable (only seen in scope of current f-n)
#     declare -A REQUIRED_VARIABLES
#     # REQUIRED_VARIABLES[FF_HOST]=''
#     # REQUIRED_VARIABLES[FF_PORT]='443'
#     # REQUIRED_VARIABLES[FF_PROTOCOL]='https'

#     declare -A OPTIONAL_VARIABLES
#     OPTIONAL_VARIABLES[FF_HOST]=''
#     OPTIONAL_VARIABLES[FF_PORT]='443'
#     OPTIONAL_VARIABLES[FF_PROTOCOL]='https'
#     OPTIONAL_VARIABLES[FF_API_USERNAME]=''
#     OPTIONAL_VARIABLES[FF_API_PASSWORD]=''
#     OPTIONAL_VARIABLES[FF_API_TOKEN]=''
#     OPTIONAL_VARIABLES[FF_PROXY_HOST]=''
#     OPTIONAL_VARIABLES[FF_PROXY_PORT]=''
#     OPTIONAL_VARIABLES[FF_PROXY_PROTOCOL]=''
#     OPTIONAL_VARIABLES[FF_PROXY_USERNAME]=''
#     OPTIONAL_VARIABLES[FF_PROXY_PASSWORD]=''

#     # Discover required variables
#     for NAME in "${!REQUIRED_VARIABLES[@]}"; do
#         # Check NAME is not empty
#         [ -z "${NAME}" ] && { continue; }
#         # Get default value and call discovery f-n
#         local DEFAULT_VALUE="${REQUIRED_VARIABLES[${NAME}]}"
#         discover_required_environment_variable "${NAME}" "${DEFAULT_VALUE}" || { return 1; }
#     done

#     # Discover optional variables
#     for NAME in "${!OPTIONAL_VARIABLES[@]}"; do
#         # Check NAME is not empty
#         [ -z "${NAME}" ] && { continue; }
#         # Get default value and call discovery f-n
#         local DEFAULT_VALUE="${OPTIONAL_VARIABLES[${NAME}]}"
#         discover_optional_environment_variable "${NAME}" "${DEFAULT_VALUE}" || { return 1; }
#     done
# }
# export -f discover_ff_environment

###############################################################################
# Category: DISCOVERY
# F-n takes 2 arguments:
#    - environment variable name (must be not empty)
#    - default value (can be blank if no default value set)
#
# F-n checks:
#    - if such variable already exists function export that variable and exits with no changes to the existing value
#    - if no such variable exists f-n tries to get previously stored value by calling "secret_get ${NAME}" and export this value (if found)
#    - if no value found on previous steps, then f-n exports this variable with ${DEFAULT_VALUE} (only if default value is not blank)
#
# Return code:
#   0 - on success
#   1 - on error
#
# Dependency: tr
#
function discover_optional_environment_variable {
  local NAME="${1}"
  local DEFAULT_VALUE="${2}"

  # Check inputs: NAME can be empty
  [ -z "${NAME}" ] && { return 1; }

  # Check if such environment already defined
  if [[ -v "${NAME}" ]]; then
      # Variable '${NAME}' is already defined (has value: '${!NAME}').
      # Make sure to export it, so if it was just "shell variable"
      # it becomes "environment variable", thus available even for child processes.
      export "${NAME}"="${!NAME}"
      return 0
  fi

  # Dependency check: 'tr' is installed
  if ! command_exists tr >/dev/null; then
    error "${FUNCNAME[0]}" 'error_dependency_not_met_tr'
    return 1
  fi
  
  # Try to get value by "secret_get()"
  local NAME_LOWERCASE="$( echo "${NAME}" | tr '[:upper:]' '[:lower:]' )"
  local RESTORED_VALUE=$( secret_get "${NAME_LOWERCASE}" )
  if [ ! -z "${RESTORED_VALUE}" ]; then
      # Got non-empty value, use it to export variable
      export "${NAME}"="${RESTORED_VALUE}"
      return 0
  fi

  # Variable not yet defined, define it using default value
  if [ ! -z "${DEFAULT_VALUE}" ]; then
      export "${NAME}"="${DEFAULT_VALUE}"
      return 0
  fi

  # Case: can't find variable value neither from "secret_get()" nor from "DEFAULT_VALUE". Not an error.
  return 0
}
export -f discover_optional_environment_variable

###############################################################################
# Category: DISCOVERY
# discover_os() tries to identify operating system type/version and return it as a string.
# In case of error it will return string: "unknown"
#
function discover_os {

    local OS_FAMILY="unknown"

    # Detect the platform based on "OSTYPE" variable
    case "${OSTYPE}" in
    darwin*)  OS_FAMILY="macos" ;;
    linux*)   OS_FAMILY="linux" ;;
    linux-gnu*)   OS_FAMILY="linux" ;;
    bsd*)     OS_FAMILY="bsd" ;;
    msys*)    OS_FAMILY="windows" ;;
    cygwin*)  OS_FAMILY="windows" ;;
    *)        OS_FAMILY="unknown" ;;  # Failed to id OS, this is not an error yet, we have 2nd attpempt (see below).
    esac

    # If OS_FAMILY still not set, try to detect the platform based on "uname" output
    if [ "${OS_FAMILY}" == "unknown" ]; then
        OS="`uname`"
        case ${OS} in
        'Linux') OS_FAMILY='linux' ;;
        'FreeBSD') OS_FAMILY='bsd' ;;
        'WindowsNT') OS_FAMILY='windows' ;;
        'Darwin')  OS_FAMILY='macos' ;;
        #'AIX') OS_FAMILY='aix' ;;
        *) ;;
        esac
    fi

    echo "${OS_FAMILY}"
}
export -f discover_os

###############################################################################
# Category: DISCOVERY
# F-n discover_required_environment_variable is similar to discover_optional_environment_variable, but after an attempt
# to discover variable it checks if the value was actually found/set and if not, then error out.
#
function discover_required_environment_variable {
  local NAME="${1}"
  local DEFAULT_VALUE="${2}"

  # Check inputs: NAME can be empty
  [ -z "${NAME}" ] && { return 1; }

  # Try to discover
  discover_optional_environment_variable "${NAME}" "${DEFAULT_VALUE}"

  # Check: must be discovered, otherwise error out
  if [[ ! -v "${NAME}" ]]; then
      # Variable '${NAME}' is not defined, but required. Return an error.
      return 1
  fi
}
export -f discover_required_environment_variable

###############################################################################
# Category: DISCOVERY
# Utility function to get Unix epoch time in milliseconds
# Usage example:
#   "current epoch_ms value is: $( get_epoch_ms )"
function get_epoch_ms {
    # TODO - Make this compatible with Darwin (MACOS) where date works differently.
    # For details on "date" command on Linux vs Darwin see discussion:
    # https://stackoverflow.com/questions/9804966/date-command-does-not-follow-linux-specifications-mac-os-x-lion
    echo "$( date +%s%N | cut -b1-13 )"  # https://serverfault.com/a/151112/413686>
}
export -f get_epoch_ms

###############################################################################
# Category: DISCOVERY
# Utility function - Get hardware architecture (e.g. arm64, amd64)
function get_hardware_architecture {
    dpkg --print-architecture
}
export -f get_hardware_architecture

###############################################################################
# Category: DISCOVERY
# Utility function - Get os name - e.g. linux
function get_os_name {
  local OS_NAME="$( basename $( uname --operating-system ) | tr '[:upper:]' '[:lower:]' )"
  if [ -z "${OS_NAME}" ]; then
    # Error, got empty string
    return 1
  fi

  echo "${OS_NAME}"
}
export -f get_os_name

###############################################################################
# Category: DISCOVERY
# Utility function - Get codename - e.g. breezy, focal, ..
function get_lsb_codename {
    lsb_release --short --codename
}
export -f get_lsb_codename

###############################################################################
# Category: DISCOVERY
# Utility function - Get LSB ID - e.g. Ubuntu
function get_lsb_id {
    lsb_release --short --id
}
export -f get_lsb_id

###############################################################################
# Category: DISCOVERY
# Utility function - Get LSB ID - e.g. ubuntu
function get_lsb_id_downcase {
  # Dependency check: 'tr' is installed
  if ! command_exists tr >/dev/null; then
    set_state "${FUNCNAME[0]}" 'error_dependency_not_met_tr'
    return 1
  fi

  lsb_release --short --id | tr '[:upper:]' '[:lower:]'
}
export -f get_lsb_id_downcase

###############################################################################
# Category: DISCOVERY
# Utility function - Get release - e.g. 16.04, 18.04, 20.04
function get_lsb_release {
    lsb_release --short --release
}
export -f get_lsb_release

### END DISCOVER FUNCTIONS


### BEGIN SET ENVIRONMENT FUNCTIONS

###############################################################################
# Category: SET ENVIRONMENT
# Utility function check_environment_variables_are_set() checks if all the expected environment variables are set
#
# On success: reuturn 0
# On failure: return 1
#
function check_environment_variables_are_set {

  # Dependency check: 'tr' is installed
  if ! command_exists tr >/dev/null; then
    error "${FUNCNAME[0]}" 'error_dependency_not_met_tr'
    return 1
  fi

  # Define list of required environment variables (must be not empty)
  local ALL_EXPECTED_ENVRIONMENT_VARIABLES=(
    FF_AGENT_USERNAME
    FF_AGENT_HOME
    FF_AGENT_URI
    FF_HOST
    FF_CONTENT_URL
    N_PREFIX
    TERM
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${ALL_EXPECTED_ENVRIONMENT_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      error "${FUNCNAME[0]}" "Expected variable is not set: '${VARIABLE_NAME}'"
      return 1
    }
  done
}
export -f check_environment_variables_are_set

###############################################################################
# Category: SET ENVIRONMENT
# Utility function ff_agent_check_bin_is_in_the_path()
# On success: reuturn 0
# On failure: 1
#
function ff_agent_check_bin_is_in_the_path {

  local FF_AGENT_BIN="${FF_AGENT_HOME}/bin"
  printenv PATH | grep --quiet "${FF_AGENT_BIN}"
  [ ${?} -ne 0 ] && {
    # Error
    return 1
  }
}
export -f ff_agent_check_bin_is_in_the_path

###############################################################################
# Category: SET ENVIRONMENT
# Utility function check_nodejs_installation() checks if nodejs is installed
# under right path and expected version
#
# On success: reuturn 0
# On failure: 1
#
function check_nodejs_installation {
  set_state "${FUNCNAME[0]}" 'started'

  local ERRORS_COUNT=0
  # Check nodejs is installed
  local WHICH_NODE="$( command_exists node )"
  if [ "${WHICH_NODE}" == "" ]; then
    # 'node' does not exist
    ERROR_CODE="error_check_nodejs_installation_nodejs_not_installed"
    set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
    (( ERRORS_COUNT++ ))
  else
    # 'node' exists: run few more node-related checks
    # Check nodejs is not installed under /usr
    [[ "${WHICH_NODE}" =~ ^/usr/ ]] && {
      ERROR_CODE="error_check_nodejs_installation_wrong_installation_dir"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      (( ERRORS_COUNT++ ))
    }

    # Get expected nodejs version
    local EXPECTED_VERSION="$( get_expected_nodejs_version )"
    [ -z "${EXPECTED_VERSION}" ] && {
      ERROR_CODE="failed_to_get_expected_nodejs_version"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      (( ERRORS_COUNT++ ))
    }

    # Get actual nodejs version
    local ACTUAL_VERSION="$( node --version )"
    [ -z "${ACTUAL_VERSION}" ] && {
      ERROR_CODE="failed_to_get_actual_nodejs_version"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      (( ERRORS_COUNT++ ))
    }

    # Compare expected vs actual nodejs versions
    if [ "${EXPECTED_VERSION}" != "${ACTUAL_VERSION}" ]; then
      # Version mismatch
      ERROR_CODE="error_mismatching_nodejs_versions"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      (( ERRORS_COUNT++ ))
    fi
  fi

  # Check npm is installed
  WHICH_NPM=$( command_exists npm )
  [ "${WHICH_NPM}" != "" ] || {
    ERROR_CODE="error_check_npm_installation_nodejs_not_installed"
    set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
    (( ERRORS_COUNT++ ))
  }

  # Check npm is not installed under /usr
  [[ "${WHICH_NPM}" =~ ^/usr/ ]] && {
    ERROR_CODE="error_check_npm_installation_wrong_installation_dir"
    set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
    (( ERRORS_COUNT++ ))
  }

  # List of all the checks done with their statuses
  if [ ${ERRORS_COUNT} -gt 0 ]; then
    # We found errors
    set_state "${FUNCNAME[0]}" 'failed'
    return 1
  fi

  set_state "${FUNCNAME[0]}" 'success'
}
export -f check_nodejs_installation

###############################################################################
# Category: SET ENVIRONMENT
# Utility function check_set_get_secret() checks if set_secret() and get_secret()
# work as expected.
#
# On success: reuturn 0
# On failure: return 1 and prints error to standard error stream
#
function check_set_get_secret {
  
  SECRET_NAME="check_set_get_secret"
  SECRET_VALUE=$( ff_uuid ) || { error "${FUNCNAME[0]}" 'failed_generate_uuid'; return 1; }

  set_secret "${SECRET_NAME}" "${SECRET_VALUE}" || { error "${FUNCNAME[0]}" 'failed_set_secret'; return 1; }

  local RETRIEVED_VALUE
  RETRIEVED_VALUE=$( get_secret "${SECRET_NAME}" ) || {
    error "${FUNCNAME[0]}" 'failed_retrieve_secret'
    return 1
  }

  # Compare retrieved state with expected
  if [ "${RETRIEVED_VALUE}" != "${SECRET_VALUE}" ]; then
    # Mismatch (error)
    error "${FUNCNAME[0]}" 'error_retrieved_value_mismatch'
    return 1
  fi
}
export -f secret_check_set_and_get

###############################################################################
# Category: SET ENVIRONMENT
# Utility function state_check_set_and_get() checks if set_state() and get_state()
# work as expected.
#
# On success: reuturn 0
# On failure: return 1 and prints error to standard error stream
#
# Depend on: uuidgen, tr.
#
function state_check_set_and_get {

  # Check tr is installed
  if ! command_exists tr >/dev/null; then
    error "${FUNCNAME[0]}" 'error_dependency_not_met_tr'
    return 1
  fi

  STATE_NAME="state_check_set_and_get"
  STATE_VALUE=$( ff_uuid | tr -d '-' )

  # Check generated STATE_VALUE is not empty
  [ ! -z "${STATE_VALUE}" ] || { error "${FUNCNAME[0]}" 'failed_generate_random_state_value'; return 1; }

  # Set state and try to retrieve value
  error "${STATE_NAME}" "${STATE_VALUE}" || { return 1; }

  local RETRIEVED_VALUE
  RETRIEVED_VALUE=$( get_state "${STATE_NAME}" ) || { error "${FUNCNAME[0]}" 'failed_retrieve_state'; return 1; }

  # Compare retrieved and expected values
  if [ "${RETRIEVED_VALUE}" != "${STATE_VALUE}" ]; then
    # Mismatch (error)
    error "${FUNCNAME[0]}" 'error_retrieved_value_mismatch'
    return 1
  fi
}
export -f state_check_set_and_get

###############################################################################
# Category: SET ENVIRONMENT
# Function get_current_user is a smarter alternative to ${USER} environment variable,
# which might not be set when running inside docker.
#
# Function sets state and return following:
#   On success function prints current user to standard output and return code 0.
#   On error/failure function return code 1.
#
# Usage example:
#     CURRENT_USER="$(get_current_user)" || { error "Can not get current user"; return 1; }
#
# For more details see discussion:
# https://stackoverflow.com/questions/54411218/docker-why-isnt-user-environment-variable-set
#
# Tested in Ubuntu 20.04: docker run -it --rm ubuntu:20.04 bash  => echo "${USER}"  => blank
#
function get_current_user {
  # set_state "${FUNCNAME[0]}" 'started'

  # Check if environment variable USER is set, then use it.
  if [ -z "${USER}" ]; then
    # The USER environment variable is blank.
    # Use command_exists to check if 'whoami' is available
    if ! command_exists whoami >/dev/null; then
      # set_state "${FUNCNAME[0]}" 'error_whoami_not_installed'
      return 1
    fi

    # Try to get current username by 'whoami'
    USER="$( whoami )" || { error "ERROR whoami command failed"; return 1; }
    [ ! -z "${USER}" ] || { error "failed_to_get_current_user"; return 1; }
  fi

  # Print username to standard output
  echo "${USER}"
}
export -f get_current_user

###############################################################################
# Category: SET ENVIRONMENT
# Function get_best_ff_agent_home:
#
# Sets the following environment variables:
#   FF_AGENT_USERNAME - example: ubuntu
#   FF_AGENT_HOME          - example: /home/ubuntu/ff_agent
#
# Return:
#  on success - export environment variables and return 0
#  on error - return nonzero code
#
# Baseline installer must choose the "best user" (not root, able to sudo).
#
# Reason why we must avoid using root user: if program started by root user and a security
# flaw is exploited, the attacker has access to all the data and can directly control the system.
# For example, it might install a trojan or key-logger into your kernel. We only escalate user
# privileges when required and allowed/agreed to install dependency packages.
#
# Failure to choose the right user would end up in the terminal installation error:
# "terminal_error_failed_to_discover_environment".
#
function get_best_ff_agent_home {

    # These exports are our "return values"
    # Note: we should not get value from subprocess and call 'export' on the same 1-line like this: "export SOMEVAR=$( some_function_call ) || { error "error details"; return 1; } "
    #       because export would hide actual exit call of the "some_function_call" and thus we'll miss an error!
    FF_AGENT_USERNAME="$(get_current_user)" || { error "terminal_error_failed_to_get_current_user"; return 1; }
    export FF_AGENT_USERNAME

    # Even if this function run by some other/not-chosen" user, the FF_AGENT_USER_HOME would point to the "right/choosen" home. Example: /home/ubuntu
    # Only when we run as ritgh/choosen user the FF_AGENT_USER_HOME and HOME have the same values.
    FF_AGENT_USER_HOME=$( get_home_directory_for_user "${FF_AGENT_USERNAME}" ) || { error "terminal_error_failed_to_get_agent_user_home"; return 1; }
    export FF_AGENT_USER_HOME
          
    local AGENT_DIR_NAME="ff_agent"
    export FF_AGENT_HOME="${FF_AGENT_USER_HOME}/${AGENT_DIR_NAME}"
}
export -f get_best_ff_agent_home

###############################################################################
# Category: SET ENVIRONMENT
# Function takes the only parameter: REST-API "call" and makes https GET request: https://${FF_HOST}${CALL}
#
# Usage example:  ff_api_get "/admin/organizations"
#
function ff_api_get {
    CALL="${1}"

    [ ! -z "${CALL}" ] || { return 1; }
    [ ! -z "${FF_API_USERNAME}" ] || { return 1; }
    [ ! -z "${FF_API_PASSWORD}" ] || { return 1; }
    [ ! -z "${FF_HOST}" ] || { return 1; }

    # Run command, capture server response as ${RESULT} and curl exit code as ${STATUS}
    RESULT=$( curl -s --retry 5 -u "${FF_API_USERNAME}:${FF_API_PASSWORD}" https://${FF_HOST}${CALL} )
    STATUS=${?}

    if [ "${STATUS}" != "0" ]; then
        return ${STATUS}
    fi

    if [[ ${RESULT} =~ (^Cannot GET) ]]; then
        return 1
    fi

    if [[ ${RESULT} =~ (^.*"mime_type".+"rest/error") ]]; then
        return 1
    fi

    echo ${RESULT}
}
export -f ff_api_get

###############################################################################
# Category: SET ENVIRONMENT
# Function prints into standard output the expected version of nodejs.
# We use it during installation and to check installed "set environment" project.
function get_expected_nodejs_version {
  echo 'v18.4.0'
}
export -f get_expected_nodejs_version

###############################################################################
# Category: SET ENVIRONMENT
# Function checks if we have framework API defined by checking if all of the following is set:
#    - FF_HOST
#    - ( FF_API_USERNAME and FF_API_PASSWORDS ) OR ( FF_API_TOKEN )
#
# As a result: functions prints "true" or "false" into std output stream.
# Usage example:
#    if [ "$( is_framework_api_defined )" == "true" ]; then
#       : # yes, the framework API is defined
#    fi
#
function is_framework_api_defined {
  # Print 'false' and return 1if FF_HOST not set
  [ -z "${FF_HOST}" ] && { echo 'false'; return 1; }

  # Print 'true' if both FF_API_USERNAME and FF_API_PASSWORDS are set
  [ ! -z "${FF_API_USERNAME}" ] && [ ! -z "${FF_API_PASSWORDS}" ] && { echo 'true'; return 0; }

  # Print 'true' if FF_API_TOKEN is set
  [ ! -z "${FF_API_TOKEN}" ] && { echo 'true'; return 0; }

  # Print 'false' in all other cases
  echo 'false'
  return 1
}
export -f is_framework_api_defined

###############################################################################
# Category: SET ENVIRONMENT
# Utility function set_environment_is_working() checks if all the aspects of "set_environment"
# are in place and functioning as expected
#
function set_environment_is_working {

  local HAS_ERRORS=false
  local VERBOSE=false

  [ "${1}" == "--verbose" ] && VERBOSE=true

  # Verify expected commands exist
  COMMANDS=(
    command_exists
    environment_check_required_variables_are_set
    state_check_set_and_get
    secret_check_set_and_get
    ff_agent_check_bin_is_in_the_path
  )

  local ASSERTION='command_exists'
  for COMMAND in ${COMMANDS[@]}
  do
    if command_exists ${COMMAND} >/dev/null ; then
      [ "${VERBOSE}" == 'true' ] && log "SUCCESS assertion='${ASSERTION}' command='${COMMAND}'"
    else
      HAS_ERRORS=true
      [ "${VERBOSE}" == 'true' ] && error "assertion='${ASSERTION}'  command='${COMMAND}'"
      error "${FUNCNAME[0]}" "error_assertion_failed_${ASSERTION}_command_${COMMAND}"
    fi
  done

  # Loop through array of f-nested f-ns, on error set flag HAS_ERRORS (don't exit)
  # MaKE SURE THESE COMMANDS BELOW ARE TESTED ABOVE
  CHECKS=(
    # Check expected environments are in place
    environment_check_required_variables_are_set

    # Check nodejs installation
    nodejs_check_installation

    # Check set_state() / get_state() by setting random value to some test state and then retrieving it back
    state_check_set_and_get

    # Check secret_set() / secret_get() by setting random value to some test secret and then retrieving it back
    secret_check_set_and_get

    # Check ff_agent/bin is in the path
    ff_agent_check_bin_is_in_the_path
  )

  local COMMAND  # Declare variable local, so it does not polute our scope outside this f-n
  for COMMAND in "${CHECKS[@]}"; do
    # Run the command. It must return 0 on success
    if ${COMMAND}; then
      # Command returns 0, which we take as successfull assertion
      if [ "${COMMAND}" ]; then
            [ "${VERBOSE}" == 'true' ] && log "SUCCESS assertion='${COMMAND}'"
      else 
      HAS_ERRORS=true
        [ "${VERBOSE}" == 'true' ] && error "failed assertion='${COMMAND}'"
        error "error_assertion_failed_${COMMAND}"
      fi
    fi
  done

  # TODO: check if list of required basic packages is installed

  # TODO: instead of "cherry-picking" what to check we should have 1:1 "doer/instaler" and corresponding "checker" functions defined, which we'll call here by list.

  # Check if we have any errors
  if [ "${HAS_ERRORS}" == "true" ]; then
    # We have errors
    #set_state "${FUNCNAME[0]}" 'failed'  # commented since set_state was already called by concrete check with better (more precise) error code
    return 1
  fi
}
export -f set_environment_is_working

###############################################################################
# Category: SET ENVIRONMENT
# Function publish_message() takes JSON payload, wraps it into the message and posts JSON to the FF_HOST.
#
# Function returns 0 upon successfully sending POST to FF_HOST, any other code otherwise.
#
# Usage example:
#   echo '{"a": 1, "b": true}' | publish_message
#   cat  "/path/to/file.json"  | publish_message
#
function publish_message {

  # Preserve current bash echo settings and enable bash echo setting
  BASH_ECHO_SETTINGS=$( get_bash_echo_setting ) || { return 1; } # Note: can't use set_state here otherwize will fall into recursive loop

  set_bash_echo_off || { return 1; } # Disable xtrace to avoid priting secrets. Note: can't use set_state here otherwize will fall into recursive loop

  # Read piped json
  INPUT_JSON=`cat`

  # Check inputs
  local FF_API_USERNAME=$( secret_get ff_api_username )
  if [ "${FF_API_USERNAME}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    # error: FF_API_USERNAME is missing
    # can't use set_state here otherwize will fall into recursive loop
    return 1
  fi

  local FF_API_PASSWORD=$( secret_get ff_api_password )
  if [ "${FF_API_PASSWORD}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    # error: FF_API_PASSWORD is missing
    # can't use set_state here otherwize will fall into recursive loop
    return 1
  fi

  if [ "${INPUT_JSON}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    # error: INPUT_JSON is missing
    return 1
  fi

  if [ "${FF_HOST}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    # error: FF_HOST is missing
    return 1
  fi

  local UUID="$( ff_uuid )"
  if [ "${UUID}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    # error: failed to generate UUID
    return 1
  fi

  local TRANSACTION_ID="$( ff_uuid )"
  if [ "${TRANSACTION_ID}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    # error: failed to generate TRANSACTION_ID
    return 1
  fi

  if ! command_exists curl >/dev/null; then
    log "WARNING: curl is not yet isntalled. Skppping publishing JSON: ${INPUT_JSON}"
    return 0
  fi

  # Wrap input JSON into the MESSAGE
  local MESSAGE=$(
    # Part 1/3: headers and start of payload
    cat <<- EOF
    {
      "uri": "/organization/${ORGANIZATION}/delivery/message/${UUID}",
      "mime_type": "delivery/message",
      "header": {
        "mime_type": "delivery/request_header",
        "transaction_id": "${TRANSACTION_ID}",

        ${HAS_ERRORS_ELEMENT}

        "from": "/service/set_environment/instance/${UUID}",
        "to":"/service/storage"
      },
      "payload": [
EOF
    # Part 2/3: payload
    echo "${INPUT_JSON}"

    # Part 3/3: footer: closing payload array and message envelop
    cat <<- EOF
      ]
    }
EOF
  )

  # Run command, capture server response as ${RESULT} and curl exit code as ${STATUS}

  local RESULT
  RESULT=$(
    curl \
      --silent   \
      --retry 5    \
      --request POST \
      --header "Content-Type: application/json" \
      --data "${MESSAGE}" \
      --user "${FF_API_USERNAME}:${FF_API_PASSWORD}" \
      https://${FF_HOST}/
  ) || {
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    return 1
  }

  # Even if curl succeed, check some edge cases, when server replied with some JSON error
  if [[ ${RESULT} =~ (^Cannot GET) ]]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    return 1
  fi

  # Check if resut has error mime_type (TODO: improve it to rely on actual response http_code, see implemented in get_by_url())
  if [[ ${RESULT} =~ (^.*"mime_type".+"rest/error") ]]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    return 1
  fi

  # Return success
  set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
}
export -f publish_message

### END SET ENVIRONMENT FUNCTIONS

terminal_initialize
