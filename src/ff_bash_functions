#!/usr/bin/env bash

# This file is a collection of useful bash functions, which we want to source for all
# users and other scripts.
#
#
# Note: we "export -f" all the functions
# Or alternatively we could:
# declare -x -f log
# See this discussion for these and other ways to solve bash functions visibility (note also ~/.bashrc and ~/.profile way to inject f-ns for all users)
# https://stackoverflow.com/questions/1885871/exporting-a-function-in-shell
# https://unix.stackexchange.com/questions/22796/can-i-export-functions-in-bash

# Table of contents generated by command:
#    file_toc src/ff_bash_functions
#
## BEGIN USAGE/HELP FUNCTION
#    - ask_for_value
#    - ask_for_yn
#    - command_exists
#    - file_toc
#    - help
#    - help_toc
## END USAGE/HELP FUNCTION
## BEGIN APT WRAPPER FUNCTIONS
#    - apt_dist_upgrade
#    - apt_install
#    - apt_list
#    - apt_reinstall
#    - apt_remove
#    - apt_update
#    - apt_upgrade
## END APT WRAPPER FUNCTIONS
## BEGIN UTILITY FUNCTIONS: STRINGS
#    - in_array
#    - github_repository_url_parse
#    - semantic_version_parse
#    - trim_slash
## END UTILITY FUNCTIONS: STRINGS
## BEGIN UTILITY FUNCTIONS: FILE
#    - assert_cd
#    - assert_makedir
#    - does_file_have_eol_at_the_end
#    - f
#    - file_contains_pattern
#    - file_truncate
#    - find_file_owner_in_all_packages
#    - find_file_owner_in_installed_packages
#    - glob_matches
#    - inject_into_file
#    - is_writable
#    - path_to_absolute_path
#    - remove_all_lines_by_regexp
#    - replace_all_lines_by_regexp
#    - s
#    - url_get
## END UTILITY FUNCTIONS: FILE
## BEGIN UTILITY FUNCTIONS: LOGGING / PROCESS CONTROl
#    - abort
#    - assert_clean_exit
#    - banner
#    - error
#    - log
#    - step
#    - successful_exit
#    - warning
## END UTILITY FUNCTIONS: LOGGING / PROCESS CONTROl
## BEGIN UTILITY FUNCTIONS: TERMINAL / SHELL
#    - bash_echo_off_set
#    - bash_echo_on_set
#    - bash_echo_setting_get
#    - bash_echo_setting_set
#    - ensure_variable_defined
#    - ensure_variable_not_empty
#    - is_shell_attribute_set
#    - is_shell_option_set
#    - terminal_initialize
#    - terminal_is_interactive
#    - terminal_is_tty
#    - terminal_reset
## END UTILITY FUNCTIONS: TERMINAL / SHELL
## BEGIN UTILITY FUNCTIONS: PROCESS
#    - check_dependencies
#    - process_is_running_as_me
#    - retry_command
## END UTILITY FUNCTIONS: PROCESS
## BEGIN UTILITY FUNCTIONS: STATE/SECRETS
#    - generate_strong_password
#    - secret_get
#    - secret_set
#    - state_get
#    - state_set
## END UTILITY FUNCTIONS: STATE/SECRETS
## BEGIN UTILITY FUNCTIONS: USER / GROUPS
#    - can_sudo
#    - check_group_exists
#    - create_user
#    - home_directory_for_user_get
#    - is_effectively_root
#    - is_user_in_group
#    - ppid_command_get
#    - user_exists
## END UTILITY FUNCTIONS: USER / GROUPS
## BEGIN DISCOVER FUNCTIONS
#    - discover_environment
#    - discover_optional_environment_variable
#    - discover_os
#    - discover_required_environment_variable
#    - epoch_ms_get
#    - ff_agent_get_best_ff_agent_uri
#    - ff_agent_get_best_ff_agent_uuid
#    - ff_agent_get_best_ff_content_url
#    - ff_agent_get_best_ff_agent_fqdn
#    - ff_agent_get_best_namespace
#    - ff_agent_get_best_organization
#    - ff_uuid
#    - hardware_architecture_get
#    - lsb_codename_get
#    - lsb_id_get
#    - lsb_id_get_downcase
#    - lsb_release_get
#    - os_name_get
## END DISCOVER FUNCTIONS
## BEGIN SET ENVIRONMENT FUNCTIONS
#    - check_environment_variables_are_set
#    - check_nodejs_installation
#    - secret_check_set_and_get
#    - current_user_get
#    - ff_agent_check_bin_is_in_the_path
#    - ff_agent_home_get_best
#    - ff_api_get
#    - is_framework_api_defined
#    - nodejs_desired_version_get
#    - publish_message
#    - set_environment_is_working
#    - state_check_set_and_get
## END SET ENVIRONMENT FUNCTIONS

### BEGIN USAGE/HELP FUNCTION

###############################################################################
# CATEGORY
#   USAGE/HELP FUNCTION
#
# NAME
#   ask_for_value - Ask for a value and store it in a variable.
#
# SYNOPSIS
#   ask_for_value VARIABLE QUESTION TOOLTIP DEFAULT_VALUE
#
# DESCRIPTION
#   Prompts the user with a QUESTION, using TOOLTIP as the input prompt. If DEFAULT_VALUE
#   is provided, it will be used as the default input when the user presses Enter.
#   The response is stored in the variable name passed as VARIABLE.
#
# USAGE EXAMPLE
#   SOME_VAR=""
#   ask_for_value SOME_VAR "Set value for SOME_VAR" "Enter SOME_VAR value: "
#   ask_for_value SOME_VAR "Update value for SOME_VAR" "Enter new SOME_VAR value: " "${SOME_VALUE}"
#
# EXIT STATUS
#   0 - Success, user input was obtained and stored.
#   1 - Failure, unable to store the input in the variable.
#
###############################################################################
function ask_for_value {
    # Check dependencies
    local DEPENDENCIES="log read eval"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    local VALUE=""

    local  __RESULTVAR=${1}
    local QUESTION=${2}
    local TOOLTIP=${3}
    local DEFAULT=${4}

    while [[ -z ${VALUE} ]]
    do
        log "${QUESTION}"
        if [[ -z ${DEFAULT} ]]
        then
            read -p "${TOOLTIP}" VALUE
        else
            read -e -p "${TOOLTIP}" -i "${DEFAULT}" VALUE
        fi
    done

    if [[ "${__RESULTVAR}" ]]; then
        eval ${__RESULTVAR}="'${VALUE}'"
    else
        echo "${VALUE}"
    fi
}
export -f ask_for_value

###############################################################################
# CATEGORY
#   USAGE/HELP FUNCTION
#
# NAME
#   ask_for_yn - Ask a yes/no question and read user input.
#
# SYNOPSIS
#   ask_for_yn QUESTION
#
# DESCRIPTION
#   Presents the user with a QUESTION and expects a 'y' or 'n' in response. The function
#   returns 0 for 'y' and 1 for 'n'.
#
# USAGE EXAMPLE
#   if ask_for_yn "Does vim rock the house?"; then
#       echo "User agreed!"
#   else
#       echo "User disagreed."
#   fi
#
# EXIT STATUS
#   0 - User answered 'y'.
#   1 - User answered 'n'.
#
###############################################################################
function ask_for_yn {

    # Check dependencies
    local DEPENDENCIES="log"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    local QUESTION=${1}
    local ANSWER=""

    while [[ ${ANSWER,,} != "y" ]] && [[ ${ANSWER,,} != "n" ]]
    do
        log "${QUESTION}"
        read -p "Answer [Y/n]: " ANSWER
        if [[ -n ${ANSWER} ]] && [[ ${ANSWER,,} == "y" ]]
        then
            return 0
        fi
    done
    return 1
}
export -f ask_for_yn

###############################################################################
# CATEGORY
#   USAGE/HELP FUNCTION
#
# NAME
#   command_exists - Check if a command exists.
#
# SYNOPSIS
#   command_exists COMMAND_NAME
#
# DESCRIPTION
#   Checks if a given command, which could be a function, an alias, or a binary in the path,
#   exists on the system. Unlike 'which', it correctly identifies aliases and functions. The
#   function outputs the resolved path or alias definition of the command if it exists.
#
# USAGE EXAMPLE
#   if command_exists tput; then
#       echo "tput command exists."
#   else
#       echo "tput command does not exist."
#   fi
#
# EXIT STATUS
#   0 - Command exists.
#   1 - Command does not exist.
#
###############################################################################
function command_exists {
  # Check dependencies
  # Note: do not use check_dependencies here to avoid recursion
  #local DEPENDENCIES="hash"
  #check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # -n - true if the length of string is nonzero
  [ -n "$(command -v hash )" ] || { error "${FUNCNAME[0]}: error_no_hash_command"; return 1; }

  local COMMAND=${1}

  # Force bash to un-hash any previously memorized commands. This will require bash to look it up again.
  # This is for cases where it has 'memoried' a command that has actually been deleted.
  hash -d "${COMMAND}" >/dev/null 2>/dev/null
  hash -d $(command -v "${COMMAND}" ) >/dev/null 2>/dev/null

  local COMMAND_RESOLVED
  COMMAND_RESOLVED=$(command -v "${COMMAND}" )
  local STATUS=${?}

  # Command will return non-zero if command not found
  if [ "${STATUS}" != "0" ]; then
    return 1
  fi

  if [ "${COMMAND_RESOLVED}" == "" ]; then
    return 1
  fi

  # Case: Is this an alias?
  if [[ "${COMMAND_RESOLVED}" =~ ^alias ]]; then
     # If it starts with alias ...= ( e.g. grep is often aliased to something else with options )
     # Then we assume it exists and we let you run the alias
     echo "${COMMAND}"
  else
    # Otherwise we return what we resolved, which might be a bash function, or the path to a command
    echo "${COMMAND_RESOLVED}"
  fi
}
export -f command_exists

###############################################################################
# CATEGORY
#   USAGE/HELP FUNCTION
#
# NAME
#   file_toc - Generate a Table of Contents for a bash file.
#
# SYNOPSIS
#   file_toc FILE_PATH
#
# DESCRIPTION
#   Parses a given bash script file at FILE_PATH, identifying sections and functions
#   to create a table of contents. It lists the beginnings and ends of sections along
#   with function names, formatted for readability.
#
# USAGE EXAMPLE
#   file_toc /path/to/my_script.sh
#
# EXIT STATUS
#   0 - Successfully generated the table of contents.
#   1 - File does not exist or another error occurred.
#
###############################################################################
function file_toc {

  # Check dependencies
  local DEPENDENCIES="cat grep sed error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Define path to ff_bash_functions file
  local FILEPATH="${1}"
  [ ! -f "${FILEPATH}" ] && {
    error "error_ff_bash_functions_file_missing"
    return 1
  }

  # Parse ff_bash_functions and generate table of contents
  cat "${FILEPATH}" | grep '^### BEGIN\|^### END\|^function' | sed 's/^function /\#    - /g' | sed 's/{//g' | sed 's/###/##/g'
}
export -f file_toc

###############################################################################
# CATEGORY
#   USAGE/HELP FUNCTION
#
# NAME
#   help - List all defined bash functions.
#
# SYNOPSIS
#   help
#
# DESCRIPTION
#   Displays a list of all builtin and custom-defined bash functions available in
#   the current shell environment.
#
# USAGE EXAMPLE
#   help
#
# EXIT STATUS
#   0 - Successfully listed functions.
#   Any other non-zero code - on error.
#
###############################################################################
function help {

    # Check dependencies
    local DEPENDENCIES="cut typeset"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    echo "Builtin functions:"
    typeset -F | cut -d' ' -f3
}
export -f help

###############################################################################
# CATEGORY
#   USAGE/HELP FUNCTION
#
# NAME
#   help_toc - Generate a Table of Contents for the bash functions file.
#
# SYNOPSIS
#   help_toc
#
# DESCRIPTION
#   This function generates a table of contents for the bash functions defined in the
#   'ff_bash_functions' file located at the FF_AGENT_HOME directory. It marks the start
#   and end of sections and lists functions.
#
# USAGE EXAMPLE
#   help_toc
#
# EXIT STATUS
#   0 - Successfully generated the table of contents.
#   1 - FF_AGENT_HOME not set or 'ff_bash_functions' file missing.
#
###############################################################################
function help_toc {

  # Check dependencies
  local DEPENDENCIES="cat grep sed error ensure_variable_not_empty"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check FF_AGENT_HOME is set
  ensure_variable_not_empty 'FF_AGENT_HOME' || {
    error "${FUNCNAME[0]}" 'Required variable is not set: FF_AGENT_HOME'
    return 1
  }

  # Define path to ff_bash_functions file
  TARGET_FILE="${FF_AGENT_HOME}/git/redwolfsecurity/set_environment/src/ff_bash_functions"
  [ ! -f "${TARGET_FILE}" ] && {
    error "${FUNCNAME[0]}" "ff_bash_functions is missing"
    return 1
  }

  # Parse ff_bash_functions and generate table of contents
  cat "${TARGET_FILE}" | grep '^### BEGIN\|^### END\|^function' | sed 's/^function /\#    - /g' | sed 's/{//g' | sed 's/###/##/g'
}
export -f help_toc

### END USAGE/HELP FUNCTION

### BEGIN APT WRAPPER FUNCTIONS

###############################################################################
# CATEGORY
#   APT WRAPPER FUNCTIONS
#
# NAME
#   apt_dist_upgrade - Safely perform a dist-upgrade operation in a headless environment.
#
# SYNOPSIS
#   apt_dist_upgrade
#
# DESCRIPTION
#   Executes an 'apt-get dist-upgrade' operation with options configured for non-interactive
#   environments. It ensures the upgrade process is handled without manual intervention, applying
#   options to allow unauthenticated, downgrades, removal of essential packages, and change of held
#   packages. It first runs 'apt_update' and 'apt_upgrade' to ensure the system is up-to-date before
#   proceeding with dist-upgrade.
#
# EXIT STATUS
#   0 - Successful dist-upgrade.
#   1 - Failed to dist-update
#
###############################################################################
function apt_dist_upgrade {

  # Check dependencies
  local DEPENDENCIES="apt_update apt_upgrade error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  local APT_COMMAND=dist-upgrade

  #        --force-yes is deprecetaed now.
  #       Force yes; this is a dangerous option that will cause apt to continue without prompting if it is doing something potentially harmful. It should not be used
  #       except in very special situations. Using force-yes can potentially destroy your system! Configuration Item: APT::Get::force-yes. This is deprecated and
  #       replaced by --allow-unauthenticated , --allow-downgrades , --allow-remove-essential , --allow-change-held-packages in 1.1.
  local FORCE_YES="--allow-unauthenticated --allow-downgrades --allow-remove-essential --allow-change-held-packages"

  apt_update  || { error "${FUNCNAME[0]}" "Failed to apt_update"; return 1; }
  apt_upgrade || { error "${FUNCNAME[0]}" "Failed to apt_upgrade"; return 1; }
  sudo DEBIAN_FRONTEND=noninteractive \
    apt-get \
      -yq \
      -o Dpkg::Options::="--force-confdef" \
      -o Dpkg::Options::="--force-confold" \
      ${FORCE_YES} ${APT_COMMAND} || { error "${FUNCNAME[0]}" "Failed to apt_dist_upgrade"; return 1; }
}
export -f apt_dist_upgrade

###############################################################################
# CATEGORY
#   APT WRAPPER FUNCTIONS
#
# NAME
#   apt_install - Safely install packages in a headless environment.
#
# SYNOPSIS
#   apt_install PACKAGE [PACKAGE ...]
#
# DESCRIPTION
#   Installs one or more packages using 'apt-get install' with options tailored for non-interactive
#   environments. This function reduces stdout noise by suppressing most output, focusing on error
#   handling. It uses 'DEBIAN_FRONTEND=noninteractive' to avoid user prompts and includes options
#   to force IPv4 and prevent the installation of recommended or suggested packages.
#
# EXIT STATUS
#   0 - Successful installation of all specified packages.
#   1 - Failure in installing one or more packages.
#
###############################################################################
function apt_install {

  # Check dependencies
  local DEPENDENCIES="error sudo apt-get"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  local PACKAGES=${@}
  local APT_COMMAND=install

  # Note: don't wrap ${PACKAGES} in quotes, otherwise it will not word split, and the loop will only run once.
  for PACKAGE in ${PACKAGES}; do
      # Note: we suppress stdout noise (only stderr will still be "visible", but TODO: think of better way to collect evidences insted of just 1 large pile)
      sudo DEBIAN_FRONTEND=noninteractive \
      apt-get \
        -o Dpkg::Options::="--force-confold" \
        -yq \
        --no-install-recommends \
        --no-install-suggests \
        -o Acquire::ForceIPv4=true \
        "${APT_COMMAND}" "${PACKAGE}" > /dev/null || { error "${FUNCNAME[0]}" "Failed to apt_install"; return 1; }
  done
}
export -f apt_install

###############################################################################
# CATEGORY
#   APT WRAPPER FUNCTIONS
#
# NAME
#   apt_list - List all files provided by a specified package.
#
# SYNOPSIS
#   apt_list PACKAGE_NAME
#
# DESCRIPTION
#   Uses 'apt-get download --print-uris' to fetch the URIs of package files and lists the files
#   contained within the specified package, even if the package is not currently installed. This
#   is useful for reverse checking which files belong to a given package. It handles errors such
#   as missing package names or failure to retrieve package URIs.
#
# USAGE EXAMPLE
#   apt_list libjansson-dev
#
# EXIT STATUS
#   0 - Successfully listed package files.
#   1 - Failure due to missing package name, inability to find package URIs, or failure to list package files.
#
###############################################################################
function apt_list {

  # Check dependencies
  local DEPENDENCIES="apt-get error awk xargs grep dpkg-deb"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check inputs:
  local PACKAGE_NAME="${1}"
  if [ "${PACKAGE_NAME}" == "" ]; then
    error "${FUNCNAME[0]}" "bad_arguments_missing_package_name"
    return 1
  fi

  # Get package URIs by apt-get download --print-uris
  # Official doc: https://help.ubuntu.com/community/AptGet/Offline/PrintUris
  # apt-get --print-uris
  #  --print-uris : instead of fetching the files to install, their URIs (links to download them) are printed.
  PACKAGE_URI=$( apt-get download \
    -o Dir::Cache::archives="./" \
    --print-uris "${PACKAGE_NAME}"
  )

  # Check errors
  if [ ${?} -ne 0 ]; then
    error "${FUNCNAME[0]}" "Failed to find_package_uris"
    return 1
  fi

  # Try to list files by given package name
  PACKAGE_FILES=$( apt-get download \
    -o Dir::Cache::archives="./" \
    --print-uris "${PACKAGE_NAME}" | awk -F\' '{print $2}' | xargs -I '{}' curl -skL '{}' | dpkg-deb -c /dev/stdin
  )

  # Check we got files list
  if [ "${PACKAGE_FILES}" == "" ]; then
    error "${FUNCNAME[0]}" "Failed to list_package_files"
    return 1
  fi
}
export -f apt_list

###############################################################################
# CATEGORY
#   APT WRAPPER FUNCTIONS
#
# NAME
#   apt_reinstall - Safely reinstall packages in a headless environment.
#
# SYNOPSIS
#   apt_reinstall PACKAGE [PACKAGE ...]
#
# DESCRIPTION
#   Reinstalls one or more specified packages using 'apt-get reinstall' with non-interactive options.
#   It ensures that configurations are preserved ('--force-confold') and opts for IPv4 connections.
#   The function iterates over each package, attempting to reinstall them individually and handles
#   errors specifically for package reinstallation failures.
#
# EXIT STATUS
#   0 - Successful reinstallation of all specified packages.
#   1 - Failure in reinstalling one or more packages.
#
###############################################################################
function apt_reinstall {

    # Check dependencies
    local DEPENDENCIES="sudo apt-get error"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    PACKAGES=${@}
    APT_COMMAND=reinstall

    # Note: don't wrap ${PACKAGES} in quotes, otherwise it will not word split, and the loop will only run once.
    for PACKAGE in ${PACKAGES}; do
        sudo DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${APT_COMMAND} ${PACKAGE}
        if [ ${?} -ne 0 ]; then
            error "Error reinstalling packages: ${PACKAGE}"
            return 1
        fi
    done

}
export -f apt_reinstall

###############################################################################
# CATEGORY
#   APT WRAPPER FUNCTIONS
#
# NAME
#   apt_remove - Safely remove packages in a headless environment.
#
# SYNOPSIS
#   apt_remove PACKAGE [PACKAGE ...]
#
# DESCRIPTION
#   Removes one or more specified packages using 'apt-get remove' with options designed for
#   non-interactive environments. Similar to 'apt_install' and 'apt_reinstall', it minimizes
#   stdout output and prioritizes error reporting, using 'DEBIAN_FRONTEND=noninteractive' and
#   other options to ensure smooth operation without manual intervention.
#
# EXIT STATUS
#   0 - Successful removal of all specified packages.
#   1 - Failure in removing one or more packages.
#
###############################################################################
function apt_remove {

    # Check dependencies
    local DEPENDENCIES="sudo apt-get error"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    PACKAGES=${@}
    APT_COMMAND=remove

    # Note: don't wrap ${PACKAGES} in quotes, otherwise it will not word split, and the loop will only run once.
    for PACKAGE in ${PACKAGES}
    do
        sudo DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${APT_COMMAND} "${PACKAGE}"
        if [ ${?} -ne 0 ]; then
            error "Error removing packages: ${PACKAGE}"
            return 1
        fi
    done
}
export -f apt_remove

###############################################################################
# CATEGORY
#   APT WRAPPER FUNCTIONS
#
# NAME
#   apt_update - Safely update package lists in a headless environment.
#
# SYNOPSIS
#   apt_update
#
# DESCRIPTION
#   Executes an 'apt-get update' operation with options that facilitate a non-interactive
#   update process. It incorporates options to avoid using deprecated 'force-yes' behavior,
#   opting instead for safer alternatives that allow unauthenticated, downgrades, and the
#   removal of
#   essential packages as well as the changing of held packages. Designed to minimize potential
#   harm while updating package lists in a headless or automated setup.
#
# EXIT STATUS
#   0 - Successful update of the package lists.
#   1 - Failure in updating the package lists.
#
###############################################################################
function apt_update {

    # Check dependencies
    local DEPENDENCIES="sudo apt-get error"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    local APT_COMMAND=update

    #        --force-yes is deprecetaed now.
    #       Force yes; this is a dangerous option that will cause apt to continue without prompting if it is doing something potentially harmful. It should not be used
    #       except in very special situations. Using force-yes can potentially destroy your system! Configuration Item: APT::Get::force-yes. This is deprecated and
    #       replaced by --allow-unauthenticated , --allow-downgrades , --allow-remove-essential , --allow-change-held-packages in 1.1.
    local FORCE_YES="--allow-unauthenticated --allow-downgrades --allow-remove-essential --allow-change-held-packages"

    sudo DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${FORCE_YES} ${APT_COMMAND}
    if [ ${?} -ne 0 ]; then
       error "updating packages"
       return 1
    fi
}
export -f apt_update

###############################################################################
# CATEGORY
#   APT WRAPPER FUNCTIONS
#
# NAME
#   apt_upgrade - Safely upgrade packages in a headless environment.
#
# SYNOPSIS
#   apt_upgrade
#
# DESCRIPTION
#   Performs an 'apt-get upgrade' to update all installed packages to the newest versions
#   without removing existing packages or installing new ones. It uses options to ensure
#   non-interactive operation, applying the same safety measures as 'apt_update' to mitigate
#   potential issues. The function is tailored to maintain system stability and security by
#   upgrading packages in a controlled, automated fashion.
#
# EXIT STATUS
#   0 - Successful upgrade of installed packages.
#   1 - Failure in upgrading one or more packages.
#
###############################################################################
function apt_upgrade {

    # Check dependencies
    local DEPENDENCIES="sudo apt-get error"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    local APT_COMMAND=upgrade

    #        --force-yes is deprecetaed now.
    #       Force yes; this is a dangerous option that will cause apt to continue without prompting if it is doing something potentially harmful. It should not be used
    #       except in very special situations. Using force-yes can potentially destroy your system! Configuration Item: APT::Get::force-yes. This is deprecated and
    #       replaced by --allow-unauthenticated , --allow-downgrades , --allow-remove-essential , --allow-change-held-packages in 1.1.
    local FORCE_YES="--allow-unauthenticated --allow-downgrades --allow-remove-essential --allow-change-held-packages"

    sudo DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${FORCE_YES} ${APT_COMMAND}
    if [ ${?} -ne 0 ]; then
       error "Error upgrading packages"
       return 1
    fi
}
export -f apt_upgrade

### END APT WRAPPER FUNCTIONS

### BEGIN UTILITY FUNCTIONS: STRINGS

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: STRINGS
#
# NAME
#   in_array - Checks if a value exists in an array.
#
# SYNOPSIS
#   in_array NEEDLE HAYSTACK
#
# DESCRIPTION
#   Iterates through an array (haystack) to check if a specified value (needle) exists within it.
#   Returns success if the needle is found, and failure otherwise.
#
# USAGE EXAMPLE
#   ARRAY=("foo" "bar" "baz")
#   SEARCH_ITEM="baz"
#   [ in_array "${SEARCH_ITEM}" "${ARRAY[@]}" ] || { error "Value ${SEARCH_ITEM} not found."; return 1; }
#
# EXIT STATUS
#   0 - Success, value exists in the array.
#   1 - Failure, value does not exist in the array.
#
###############################################################################
function in_array {
    local hay needle=${1}
    shift
    for hay; do
        [[ "${hay}" == "${needle}" ]] && return 0
    done
    return 1
}
export -f in_array

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: STRINGS
#
# NAME
#   github_repository_url_parse - Parses GitHub repository URLs.
#
# SYNOPSIS
#   github_repository_url_parse URL COMPONENT
#
# DESCRIPTION
#   Extracts and prints specific components (--protocol, --host, --owner, --project-name)
#   from a GitHub repository URL. Validates input to ensure the URL and component name
#   are provided. Supports various URL formats, including SSH, HTTPS, and Git protocol URLs.
#
# USAGE EXAMPLE
#   URL="git://github.com/some-user/my-repo.git"
#   OWNER=$(github_repository_url_parse "${URL}" --owner)
#   echo "The owner of the URL '${URL}' is '${OWNER}'."
#
# Another example:
# URLS=(
#  "git://github.com/some-user/my-repo.git"
#  "https://github.com/some-user/my-repo.git"
#  "git@github.com:some-user/my-repo.git"
#  "git://github.com/some-user/my-repo"
#  "https://github.com/some-user/my-repo"
#  "git@github.com:some-user/my-repo"
# )

# for URL in "${URLS[@]}"; do
#     PROTOCOL=$(github_repository_url_parse "${URL}" --protocol) || { error "Failed to extract protocol from URL: ${URL}"; }
#     HOST=$(github_repository_url_parse "${URL}" --host) || { error "Failed to extract host from URL: ${URL}"; }
#     OWNER=$(github_repository_url_parse "${URL}" --owner) || { error "Failed to extract owner from URL: ${URL}"; }
#     PROJECT_NAME=$(github_repository_url_parse "${URL}" --project-name) || { error "Failed to extract project name from URL: ${URL}"; }
#     echo -e "${URL}:"
#     echo -e "\tPROTOCOL=${PROTOCOL}"
#     echo -e "\tHOST=${HOST}"
#     echo -e "\tOWNER=${OWNER}"
#     echo -e "\tPROJECT_NAME=${PROJECT_NAME}"
#     echo
# done
#
# Example output:
# git://github.com/some-user/my-repo.git:
# 	PROTOCOL=git
# 	HOST=github.com
# 	OWNER=some-user
# 	PROJECT_NAME=my-repo

# https://github.com/some-user/my-repo.git:
# 	PROTOCOL=https
# 	HOST=github.com
# 	OWNER=some-user
# 	PROJECT_NAME=my-repo

# git@github.com:some-user/my-repo.git:
# 	PROTOCOL=git
# 	HOST=github.com
# 	OWNER=some-user
# 	PROJECT_NAME=my-repo

# git://github.com/some-user/my-repo:
# 	PROTOCOL=git
# 	HOST=github.com
# 	OWNER=some-user
# 	PROJECT_NAME=my-repo

# https://github.com/some-user/my-repo:
# 	PROTOCOL=https
# 	HOST=github.com
# 	OWNER=some-user
# 	PROJECT_NAME=my-repo

# git@github.com:some-user/my-repo:
# 	PROTOCOL=git
# 	HOST=github.com
# 	OWNER=some-user
# 	PROJECT_NAME=my-repo
#
# EXIT STATUS
#   0 - Success, component extracted.
#   1 - Error, due to failed URL parsing or missing arguments.
#
###############################################################################
function github_repository_url_parse {

  # Get arguments
  local URL="${1}"
  local KEY="${2}"

  # Check required arguments are not empty
  [ -n "${URL}" ] || { error "${FUNCNAME[0]}" "called with no URL argument"; return 1; }
  [ -n "${KEY}" ] || { error "${FUNCNAME[0]}" "called with no KEY argument"; return 1; }

  # Lowercase key
  KEY="${KEY,,}"

  # Define regexp to parse the github repository url
  re="^(https|git)(:\/\/|@)([^\/:]+)[\/:]([^\/:]+)\/(.+)(.git)*$"

  # Parse github repository url
  if [[ ${URL} =~ ${re} ]]; then
    PROTOCOL=${BASH_REMATCH[1]}
    # SEPARATOR=${BASH_REMATCH[2]}
    HOST=${BASH_REMATCH[3]}
    OWNER=${BASH_REMATCH[4]}
    PROJECT_NAME=${BASH_REMATCH[5]%.git}
    case "${KEY}" in
      --protocol)
        echo "${PROTOCOL}"
        return 0
        ;;
      --host)
        echo "${HOST}"
        return 0
        ;;
      --owner)
        echo "${OWNER}"
        return 0
        ;;
      --project-name)
        echo "${PROJECT_NAME}"
        return 0
        ;;
      *)
        # Error: unknown key
        return 1
    esac
  else
    # Failed to find a match.
    return 1
  fi
}
export -f github_repository_url_parse

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: STRINGS
#
# NAME
#   semantic_version_parse - Extracts version components from a semantic version string.
#
# SYNOPSIS
#   semantic_version_parse COMPONENT VERSION
#
# DESCRIPTION
#   Given a semantic version number MAJOR.MINOR.PATCH, this function extracts and
#   prints one of the three version components (major, minor, patch) to standard output.
#   It validates the input to ensure that a valid component name and version string are provided.
#
# USAGE EXAMPLE
#   VERSION="12.34.56"
#   MAJOR=$(semantic_version_parse --major "${VERSION}")
#   MINOR=$(semantic_version_parse --minor "${VERSION}")
#   PATCH=$(semantic_version_parse --patch "${VERSION}")
#   echo "Version components: MAJOR:${MAJOR}, MINOR:${MINOR}, PATCH:${PATCH}"
#
# EXIT STATUS
#   0 - Success, component extracted.
#   1 - Error, due to invalid input or unsupported component name.
#
###############################################################################
function semantic_version_parse {

  # Check dependencies
  local DEPENDENCIES="error cut in_array"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check we get exactly 2 arguments
  [ $# -eq 2 ] || { error "${FUNCNAME[0]}" 'error_wrong_number_of_arguments'; return 1; }

  # Get arguments
  local VERSION_COMPONENT_NAME="$1"
  local FULL_VERSION="$2"

  # Check we got non-empty arguments
  [ -n "${VERSION_COMPONENT_NAME}" ] || { error "${FUNCNAME[0]}" 'error_empty_argument_component_name'; return 1; }
  [ -n "${FULL_VERSION}" ] || { error "${FUNCNAME[0]}" 'error_empty_argument_full_version'; return 1; }

  # Define an array of all supported version component names
  local SUPPORTED_VERSION_COMPONENT_NAMES=("--major" "--minor" "--patch")

  # Lowercase argument, so it will work for both "--major" and "--MAJOR"
  VERSION_COMPONENT_NAME="${VERSION_COMPONENT_NAME,,}"

  # Check argument: must be 1 of 3 supported: major, minor, patch
  if ! in_array "${VERSION_COMPONENT_NAME}" "${SUPPORTED_VERSION_COMPONENT_NAMES[@]}"; then
    error "${FUNCNAME[0]}" 'error_unsupported_version_component_name'
    return 1
  fi

  # Extract component version into EXTRACTED_COMPONENT_VERSION
  case "${VERSION_COMPONENT_NAME}" in

  --major)
    local EXTRACTED_COMPONENT_VERSION=$( echo "${FULL_VERSION}" | cut -d"." -f 1 )
    ;;

  --minor)
    local EXTRACTED_COMPONENT_VERSION=$( echo "${FULL_VERSION}" | cut -d"." -f 2 )
    ;;

  --patch)
    local EXTRACTED_COMPONENT_VERSION=$( echo "${FULL_VERSION}" | cut -d"." -f 3 )
    ;;

  *)
    # We already checked (the value is in SUPPORTED_VERSION_COMPONENT_NAMES),
    # but what if "case()" was not updated, then we must error out in our "default" case.
    error "${FUNCNAME[0]}" 'error_unsupported_version_component_name_case'
    return 1
    ;;
  esac

  # Check extracted EXTRACTED_COMPONENT_VERSION is not blank
  [ -n "${EXTRACTED_COMPONENT_VERSION}" ] || { error "${FUNCNAME[0]}" 'error_got_empty_component_version'; return 1; }

  # Print result to standard output
  echo -n "${EXTRACTED_COMPONENT_VERSION}"
}
export -f semantic_version_parse

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: STRINGS
#
# NAME
#   trim_slash - Normalizes slashes in a string.
#
# SYNOPSIS
#   trim_slash STRING...
#
# DESCRIPTION
#   For each input string, replaces consecutive slashes with a single slash,
#   and removes trailing slashes except when the string is a single slash.
#   Useful for cleaning URLs or file paths.
#
# USAGE EXAMPLE
#   trim_slash "http://acme.com/a/b/c/" "http:///acme.com///" "http://acme.com/" "/" "///" "a/" "b/b/" "c/c////"
#
#   # Outputs:
#   #   http://acme.com/a/b/c
#   #   http://acme.com
#   #   http://acme.com
#   #   /
#   #   /
#   #   a
#   #   b/b
#   #   c/c
#
# EXIT STATUS
#   0 - Always succeeds.
#
###############################################################################
function trim_slash {

  # Check dependencies
  local DEPENDENCIES="sed"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  for s; do
    # Replace consecutive slashes with a single slash
    # Remove trailing slashes.
    # Leave "://" intact (i.e. http://, https:// or sftp://, etc.)
    #
    # The ":a; s:([^:])\:/:\1COLONSLASH9cf757d443f2:; ta;" - is a loop that replaces ":/"
    # with a unique placeholder (COLONSLASH9cf757d443f2). It looks for a colon followed by slash
    # The :a and ta commands create a loop to apply this substitution throughout the line, necessary
    # if your input contains multiple URLs.
    sed -E ':a; s:([^:])\:/:\1COLONSLASH9cf757d443f2:; ta; s://+:/:g; s:^/$:SINGLESLASH533b06b2b0a7:; s:/*$::; s:SINGLESLASH533b06b2b0a7:/:g; s:COLONSLASH9cf757d443f2:\:/:g' <<< "${s}"
  done
}
export -f trim_slash

### END UTILITY FUNCTIONS: STRINGS

### BEGIN UTILITY FUNCTIONS: FILE

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   assert_cd - Changes the current directory to the specified directory or aborts if it fails.
#
# SYNOPSIS
#   assert_cd DIRECTORY
#
# DESCRIPTION
#   Attempts to change the current working directory to the specified DIRECTORY. It first checks
#   if the directory exists and is a directory. If it cannot change to the directory, possibly
#   due to permission issues, it will abort the operation with an error message.
#
# USAGE
#   assert_cd /path/to/directory
#
# EXIT STATUS
#   Exits the script if it fails to change the directory.
#
###############################################################################
function assert_cd {

  # Check dependencies
  local DEPENDENCIES="abort assert_clean_exit"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check first if it is a directory.
  if [ ! -d "${1}" ]; then
     abort "ERROR: Can not enter directory \"${1}\" -- it is not a directory."
  fi

  # Directory exists, now enter it. May fail due to permissions.
  if [ -d "${1}" ]; then
     assert_clean_exit cd "${1}"
  else
     abort "ERROR: Can not enter directory \"${1}\". SUGGEST: check user ID and directory permissions."
  fi
}
export -f assert_cd

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   assert_makedir - Creates a directory if it does not already exist.
#
# SYNOPSIS
#   assert_makedir DIRECTORY
#
# DESCRIPTION
#   Checks if the specified DIRECTORY exists. If not, it attempts to create the directory.
#   If the directory creation fails (for instance, due to lacking permissions), it aborts the operation.
#
# USAGE
#   assert_makedir /path/to/directory
#
# EXIT STATUS
#   Aborts script on failure to create the directory.
#
###############################################################################
function assert_makedir {

  # Check dependencies
  local DEPENDENCIES="log assert_clean_exit"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  if [ -d "${1}" ]; then
     log "INFO: Directory \"${1}\" exists, skipping creation."
  else
     assert_clean_exit mkdir "${1}"
  fi
}
export -f assert_makedir

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   does_file_have_eol_at_the_end - Checks if a file ends with an End Of Line (EOL) character.
#
# SYNOPSIS
#   does_file_have_eol_at_the_end FILEPATH
#
# DESCRIPTION
#   Verifies if the specified file ends with an EOL character or if the file is empty.
#   It is useful for ensuring that a file is in a good state for appending content.
#
# USAGE EXAMPLE
#   # Call function and preserve its return code
#   does_file_have_eol_at_the_end "${FILEPATH}"
#   does_file_have_eol_at_the_end_code=$?
#
#   # Check if function returned an error
#   if [ ${does_file_have_eol_at_the_end_code} -gt 1 ]; then
#       error "Function does_file_have_eol_at_the_end() returned error code ${does_file_have_eol_at_the_end_code}.""
#       return 1
#   fi
#
#   # Check if EOL is present
#   if does_file_have_eol_at_the_end_code /path/to/file.txt; then
#       echo "Yes, EOL is present."
#
# EXIT STATUS
#   0 - EOL present or file is empty.
#   1 - EOL missing.
#   2 - Incorrect arguments.
#   3 - File does not exist or cannot be read.
#
###############################################################################
function does_file_have_eol_at_the_end {

  # Check dependencies
  local DEPENDENCIES="tail error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Define exit codes (both success and errors)
  local EOL_PRESENT_OR_EMPTY_FILE=0
  local EOL_MISSING=1
  local ERROR_BAD_ARGUMENTS=2
  local ERROR_FILE_DOES_NOT_EXIST_OR_CAN_NOT_READ_EVEN_WITH_SUDO=3

  # Take arguments
  FILENAME="${1}"

  # Check required arguments are not empty
  [ -n "${FILEPATH}" ] || { error "${FUNCNAME[0]}" "error_target_filepath_is_blank"; return ${ERROR_BAD_ARGUMENTS}; }

  # Check if file is empty
  if [ ! -s "${FILENAME}" ]; then
      # Note: For our needs (to avoid concatination of name/value lines) we consider empty file as having EOL (i.e. safe to append more name/values)
      # The file is empty.
      # Note: function does_file_have_eol_at_the_end() got empty file.
      # For our needs (to avoid concatination of name/value lines)
      # we consider empty file as having EOL (i.e. safe to append more name/values)
      return 0
  # -z - true if the length of string is zero
  # -n - true if the length of string is nonzero
  elif [ -z "$( tail -c 1 "${FILENAME}" )" ]; then
      # The file ends with a newline or with a null byte,
      return ${EOL_PRESENT_OR_EMPTY_FILE}
  else
      # The file does not end with a newline nor with a null byte.
      return ${EOL_MISSING}
  fi
}
export -f does_file_have_eol_at_the_end

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   f - Finds files or directories starting with a given prefix, recursively, from the current directory.
#
# SYNOPSIS
#   f PREFIX
#
# DESCRIPTION
#   Performs a case-insensitive recursive search from the current directory for files or directories that
#   start with the specified PREFIX. It excludes the 'node_modules' directory from the search.
#
# USAGE EXAMPLE
#   f index
#
# EXIT STATUS
#   Success if files or directories are found; failure otherwise.
#
###############################################################################
function f {

    # Check dependencies
    local DEPENDENCIES="find"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    FILE_PREFIX="${1}"
    if [ "${FILE_PREFIX}" != "" ]; then
        find . -iname "${FILE_PREFIX}*"
        return ${?}
    else
        # Note: we use echo to stderr, not error() because error() will print misleading "Error: " prefix
        echo "Find files with prefix, starting from current working directory down recursively." 1>&2
        echo "Usage: f index" 1>&2
        return 1
    fi
}
export -f f

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   file_contains_pattern - Checks if a file contains a given regex pattern.
#
# SYNOPSIS
#   file_contains_pattern FILEPATH PATTERN
#
# DESCRIPTION
#   Searches for a specified regular expression PATTERN within a file at FILEPATH.
#   PATTERN - The pattern is the POSIX regular expression:
#             https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
#             but with platform-specific extensions (which vary in extent and can be incompatible).
#             On Linux platforms (GNU userland), see man grep; on macOS/BSD platforms, see man re_format.#
#
# USAGE EXAMPLE
#   file_contains_pattern /path/to/file.txt "pattern"
#
# EXIT STATUS
#   0 - Pattern found.
#   1 - Pattern not found.
#
###############################################################################
function file_contains_pattern {

    # Check dependencies
    local DEPENDENCIES="grep"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    FILE="${1}"
    PATTERN="${2}"

    if [ ! -e "${FILE}" ]; then
        return 1
    fi
    if [  -z "${PATTERN}" ]; then
        return 1
    fi
    grep --quiet --text "${PATTERN}" "${FILE}"
}
export -f file_contains_pattern

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   file_truncate - Truncates a specified file to zero length.
#
# SYNOPSIS
#   file_truncate FILEPATH
#
# DESCRIPTION
#   Sets the size of the specified file to zero, effectively erasing its contents. This operation is performed safely, checking for the existence and write permissions of the file.
#
# USAGE EXAMPLE
#   file_truncate "/path/to/logfile.log"
#
# EXIT STATUS
#   0 - Success, file truncated to zero length.
#   1 - General error, such as file does not exist or insufficient permissions.
#   2 - Missing target filename argument.
#   3 - Target file does not exist.
#   4 - Insufficient permissions to read the target file.
#   5 - Insufficient permissions to write to the target file.
#   6 - Failed to truncate the target file to zero length.
#       Note: if you truncating the log file, which is actively used by running process(es) there might be the case
#             when right after you truncated the file it was written to before we checked the size, so error code 6 might
#             be not an error in these cases.
#
###############################################################################
function file_truncate {

  # Check dependencies
  local DEPENDENCIES="truncate error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Get filename argument
  local FILEPATH="${1}"

  # Check filename is not blank
  if [ "${FILEPATH}" == "" ]; then
    # Error: missing target filename
    error "${FUNCNAME[0]}" 'Missing filename argument'
    return 2
  fi

  # Check file exists
  if [ ! -f "${FILEPATH}" ]; then
    # Error: file does not exist
    error "${FUNCNAME[0]}" "File does not exist: '${FILEPATH}'"
    return 3
  fi

  # Check if target file is readable
  if [ ! -r "${FILEPATH}" ]; then
    # Error: not enough permissions to read target file
    error "${FUNCNAME[0]}" "Insufficient permissions to read file: '${FILEPATH}'"
    return 4
  fi

  # Check if target file is writable
  if [ ! -w "${FILEPATH}" ]; then
    # Error: not enough permissions to write target file
    error "${FUNCNAME[0]}" "Insufficient permissions to write file: '${FILEPATH}'"
    return 5
  fi

  # Check if file is not empty, then truncate it to zero
  if [ -s "${FILEPATH}" ]; then
    # File is not empty.
    # Warning: don't "sudo" here, for files with permissions like "-rw-rw-r--" truncate won't have access by root user
    truncate --size=0 "${FILEPATH}" || { error "${FUNCNAME[0]}" "Failed to truncate file: '${FILEPATH}'"; return 1; }
  else
    # File is already empty
    return 0
  fi

  # Final check: file must have zero size now
  if [ -s file ]; then
    # Error: File is not empty after truncation
    error "${FUNCNAME[0]}" "File is not empty after truncation: '${FILEPATH}'"
    return 6
  fi
}
export -f file_truncate

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   find_file_owner_in_all_packages - Identifies the package(s) that own a specified file across all available packages.
#
# SYNOPSIS
#   find_file_owner_in_all_packages FILENAME
#
# DESCRIPTION
#   Uses 'apt-file' to search across all packages in the repository to find which one(s) contain
#   the specified FILENAME. Requires 'apt-file' to be installed and updated.
#
# USAGE EXAMPLE
#   find_file_owner_in_all_packages realpath
#   find_file_owner_in_all_packages hping3
#   find_file_owner_in_all_packages netstat
#
# EXIT STATUS
#   Outputs package names and file paths. Returns success if 'apt-file' is available and the search can be performed.
#
###############################################################################
function find_file_owner_in_all_packages {

    # Check dependencies
    local DEPENDENCIES="error apt-file command_exists sudo"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    # Take filename argument
    FILE="${1}"

    # Make sure arguemnt is not empty
    if [ -z "${FILE}" ]; then
        error "Function find_file_owner_in_all_packages() require one argument: filename."
        return 1
    fi

    # Update packages universe database
    # Note: Running apt-file update updates its database of files available in packages,
    # enabling users to search for a specific file to find out which package it belongs to.
    # This is especially useful for resolving missing file or library dependencies.
    # It is different from "apt-get update", which updates the package lists for upgrades
    # or new package installations by syncing the package index files from their sources specified
    # in /etc/apt/sources.list and /etc/apt/sources.list.d/*.list files.
    sudo apt-file update

    # Try to search given file
    apt-file search "${FILE}"
}
export -f find_file_owner_in_all_packages

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   find_file_owner_in_installed_packages - Finds which installed package owns a specified file.
#
# SYNOPSIS
#   find_file_owner_in_installed_packages FILENAME
#
# DESCRIPTION
#   Searches through installed packages to find which package owns the specified FILENAME. It differs from
#  'find_file_owner_in_all_packages' by only searching among packages that are already installed on the system
#  and by using "dpkg" instead of "apt-file".
#
# USAGE EXAMPLE
#   find_file_owner_in_installed_packages realpath
#   find_file_owner_in_installed_packages hping3
#   find_file_owner_in_installed_packages netstat
#
# EXIT STATUS
#   Outputs package names and file paths. Returns success if the file is owned by an installed package.
#
###############################################################################

function find_file_owner_in_installed_packages {
    # Check dependencies
    local DEPENDENCIES="error dpkg"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    # Take filename argument
    FILE="${1}"

    # Make sure arguemnt is not empty
    if [ -z "${FILE}" ]; then
        error "Function find_file_owner_in_installed_packages() require one argument: filename."
        return 1
    fi

    # Try to find the file in the installed packages
    dpkg -S "${FILE}"
}
export -f find_file_owner_in_installed_packages

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   glob_matches - Checks if a glob pattern matches any files or directories.
#
# SYNOPSIS
#   glob_matches PATTERN
#
# DESCRIPTION
#   Uses bash's globbing feature to check if the specified PATTERN matches any files
#   or directories in the current directory. It is a simple wrapper around bash's
#   built-in globbing capabilities to provide a programmatic check for glob matches.
#
# USAGE EXAMPLE
#   if glob_matches "*.txt"; then
#     echo "Text files exist."
#   else
#     echo "No text files found."
#   fi
#
# EXIT STATUS
#   0 - Pattern matches.
#   1 - No matches found.
#
###############################################################################
function glob_matches {

  # Check dependencies
  local DEPENDENCIES="compgen"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

	compgen -G "${@}" >/dev/null
	return ${?}
}
export -f glob_matches


###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   inject_into_file - Injects or appends text into a file based on a pattern.
#
# SYNOPSIS
#   inject_into_file FILEPATH PATTERN INJECT_CONTENT
#
# DESCRIPTION
#   Searches for a given PATTERN within a file. If the pattern is not found,
#   INJECT_CONTENT is appended to the file. If the file ends without an End
#   Of Line (EOL), an EOL is added before appending. It uses sudo if necessary
#   for the file access.
#   PATTERN - The pattern is the POSIX regular expression:
#             https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
#             but with platform-specific extensions (which vary in extent and can be incompatible).
#             On Linux platforms (GNU userland), see man grep; on macOS/BSD platforms, see man re_format.#
#
# USAGE EXAMPLE
#   inject_into_file "/path/to/file.txt" "unique_pattern" "Text to be injected"
#
#   More complex example with regular expression and multiple lines INJECT_CONTENT:
#     PATTERN="^source \"${FF_AGENT_PROFILE_FILE}\""
#     INJECT_CONTENT=$(
#     cat <<EOT
#         # Sourcing ${FF_AGENT_PROFILE_FILE} injected by set_environment ${FUNCNAME[0]}() on $(date --utc).
#         source "${FF_AGENT_PROFILE_FILE}"
#         EOT
#     )
#     inject_into_file "${TARGET_FILE}" "${PATTERN}" "${INJECT_CONTENT}" || { error "${FUNCNAME[0]}" "error_injecting_source_custom_profile"; return 1; }
#
# EXIT STATUS
#   0 - Success, content injected or pattern already present.
#   1 - Error occurred (e.g., permissions issues, file does not exist).
#
###############################################################################
function inject_into_file {

  # Check dependencies
  local DEPENDENCIES="ensure_variable_not_empty file_contains_pattern error tee"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Take arguments
  local FILEPATH="${1}"
  local PATTERN="${2}"
  local INJECT_CONTENT="${3}"

  # Check required arguments are not empty
  # Define required variables
  local REQUIRED_VARIABLES=(
    FILEPATH
    PATTERN
    INJECT_CONTENT
  )
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      local ERROR_DETAILS="Failed to ensure required environment variable is not empty: '${VARIABLE_NAME,,}'"
      error "${FUNCNAME[0]}" "${ERROR_DETAILS}"
      return 1
    }
  done

  # Check the target file exists
  [ -f "${FILEPATH}" ] || { error "${FUNCNAME[0]}" "error_target_file_does_not_exist: '${FILEPATH}'"; return 1; }

  # Check if target file contains the PATTERN.
  if ! file_contains_pattern "${FILEPATH}" "${PATTERN}"; then
    # Expected pattern is missing. Append text.

    # Call function and preserve its return code
    does_file_have_eol_at_the_end "${FILEPATH}"
    does_file_have_eol_at_the_end_code=$?

    # Check if function returned an error
    if [ ${does_file_have_eol_at_the_end_code} -gt 1 ]; then
        error "Function does_file_have_eol_at_the_end() returned error code ${does_file_have_eol_at_the_end_code}."
        return 1
    fi

    # Inject extra EOL if last line of the file missing EOL and file is not empty
    if [ ${does_file_have_eol_at_the_end_code} -ne 0 ]; then
      # The ${FILEPATH} file does not have EOL at the end.
      # Add EOL to the end of the file (so our injected line starts from the new line)
      echo "" | tee -a "${FILEPATH}" || {
        error "${FUNCNAME[0]}" "Failed to add missing EOL to the end of the file: ${FILEPATH}"
        return 1
      }
    fi

    # Append INJECT_CONTENT to the end of the target file
    echo "${INJECT_CONTENT}" | tee -a "${FILEPATH}" >/dev/null || {
      error "${FUNCNAME[0]}" 'error_injecting_sourcing_custom_bashrc_to_home_bashrc'
      return 1
    }

    # Post condition: verify that the expected pattern can be found after injection.
    if ! file_contains_pattern "${FILEPATH}" "${PATTERN}"; then
      # Expected pattern is still missing. Report an error.
      error "${FUNCNAME[0]}" 'postcondition check failed:expected pattern is missing after injection'
      return 1
    fi
  fi
}
export -f inject_into_file

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   is_writable - Checks if the specified file or directory is writable.
#
# SYNOPSIS
#   is_writable TARGET
#
# DESCRIPTION
#   Verifies if the current user has write permissions for the specified TARGET file or directory.
#   It does not escalate privileges or attempt to modify permissions.
#
# USAGE EXAMPLE
#   if is_writable "/path/to/file"; then
#     echo "File is writable."
#   else
#     echo "File is not writable."
#   fi
#
# EXIT STATUS
#   0 - Target is writable.
#   1 - Target is not writable or does not exist.
#
###############################################################################
function is_writable {

  # Get argument
  local TARGET="${1}"

  # Check argument is not blank
  [ -n "${TARGET}" ] || { return 1; }

  # If file/directory is writable, then return 0
  [ -w "${TARGET}" ] && { return 0; }

  # The target is not writable. Return 1
  return 1
}
export -f is_writable

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   path_to_absolute_path - Converts a relative file path to an absolute path.
#
# SYNOPSIS
#   path_to_absolute_path PATH
#
# DESCRIPTION
#   Uses the 'realpath' command to convert the given PATH to its absolute form,
#   accounting for symbolic links and relative path elements. Requires 'realpath'
#   to be available on the system, which is a part of the coreutils apt package,
#   installed as a set_environment baseline.
#   Note: the '--canonicalize-missing' option is used, so no path components need
#   to exist or be a directory.
#
# USAGE EXAMPLE
#   ABSOLUTE_FILEPATH=$(path_to_absolute_path "../../../../../../../../../some/relative/path") #  result: /some/relative/path
#
# EXIT STATUS
#   The absolute path is output to standard output. Returns exit status of the 'realpath' command.
#
###############################################################################
function path_to_absolute_path {

  # Check dependencies
  local DEPENDENCIES="realpath"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  local TARGET="$1"
  realpath --canonicalize-missing "${TARGET}"
}
export -f path_to_absolute_path

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   remove_all_lines_by_regexp - Removes all lines from a file that match a given regular expression.
#
# SYNOPSIS
#   remove_all_lines_by_regexp FILEPATH PATTERN
#
# DESCRIPTION
#   Searches a file at FILEPATH for lines matching REGEX and removes them. It supports basic
#   and extended POSIX regular expressions. This function uses sudo if necessary for file access.
#   PATTERN - The pattern is the POSIX regular expression:
#             https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
#             but with platform-specific extensions (which vary in extent and can be incompatible).
#             On Linux platforms (GNU userland), see man grep; on macOS/BSD platforms, see man re_format.#
#
# USAGE EXAMPLE
#   remove_all_lines_by_regexp "/path/to/config.txt" "^#.*"
#   remove_all_lines_by_regexp /some/path/to/the/file.txt "Some line matcher regexp \(.*\)"
#
# EXIT STATUS
#   0 - successfully removed lines
#   1 - missing regular expression
#   2 - missing target filename
#   3 - target file does not exist
#   4 - not enough permissions to read the target file
#   5 - not enough permissions to writ the target file
#   6 - the pattern was not found (in some cases this might be 'success' because some lines were already removed successfully before)
#   7 - failed to search by given pattern (most probably bad regex pattern)
#   8 - editor return an error (most probably bad regex pattern
#   9 - zero lines removed (despite the pattern was found and editor didn't error out and we have all the permissions)
#
###############################################################################
function remove_all_lines_by_regexp {

  # Check dependencies
  local DEPENDENCIES="error grep cat wc sed"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Get regexp argument
  local FILEPATH="${1}"
  local REGEX="${2}"

  # Check required arguments are not empty
  # Define required variables
  local REQUIRED_VARIABLES=(
    FILEPATH
    REGEX
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      error "${FUNCNAME[0]}" "Failed to ensure required environment variable is not empty: '${VARIABLE_NAME,,}'"
      return 1
    }
  done

  # Check the target file exists
  [ -f "${FILEPATH}" ] || { error "${FUNCNAME[0]}" "error_target_file_does_not_exist: '${FILEPATH}'"; return 1; }

  # Check if target file is readable
  if [ ! -r "${FILEPATH}" ]; then
    # Error: not enough permissions to read target file
    return 4
  fi

  # Check if target file is writable
  if [ ! -w "${FILEPATH}" ]; then
    # Error: not enough permissions to write target file
    return 5
  fi

  # Try to find by given regexp
  # Note: we collect grep output even though "-q" is used: to cover all the error cases and
  # not spill output to stderr/stdout. We might enrich return error with more details later
  # (examaple: bad syntax in the used regex).
  local GREP_OUTPUT
  GREP_OUTPUT=$( grep --quiet "${REGEX}" "${FILEPATH}" 2>&1 )
  local EXIT_CODE=${?}

  # Check if the pattern is found
  if [ ${EXIT_CODE} -eq 1 ]; then
    # The pattern match not found
    error "${FUNCNAME[0]}" 'Pattern not found'
    return 6
  fi
  if [ ${EXIT_CODE} -gt 1 ]; then
    # Error: 7 - failed to search by given pattern.
    error "${FUNCNAME[0]}" 'Failed to search by given pattern'
    return 7
  fi

  # Take a note on the current number of lines
  local LINE_COUNT_BEFORE_CHANGE
  LINE_COUNT_BEFORE_CHANGE="$( cat "${FILEPATH}" | wc -l )" || { error "${FUNCNAME[0]}" 'failed_to_count_lines_before_edit'; return 1; }

  # Found line in the target file. Edit file:
  local EDITOR_OUTPUT
  EDITOR_OUTPUT=$( sed -i "/${REGEX}/d" "${FILEPATH}" 2>&1 )

  # Check if stream editor error out.
  # Example: bad pattern would return code=1 and error message: sed: -e expression #1, char 8: unterminated address regex
  local EDITOR_CODE=${?}
  if [ ${EDITOR_CODE} -ne 0 ]; then
    # Error: editor return an error (most probably bad regex pattern)
    error "${FUNCNAME[0]}" 'failed_to_edit_file'
    return 8
  fi

  # Count the number of deleted lines
  # Note: sed always return 0, so it won't let us know how many changes were done
  LINE_COUNT_AFTER_CHANGE="$( cat "${FILEPATH}" | wc -l )" || { error "${FUNCNAME[0]}" 'failed_to_count_lines_after_edit'; return 1; }
  local DELETED_LINES_COUNT
  DELETED_LINES_COUNT=$(( LINE_COUNT_BEFORE_CHANGE - LINE_COUNT_AFTER_CHANGE ))

  # Check the number of deleted lines
  if [ ${DELETED_LINES_COUNT} -gt 0 ]; then
    # Success
    error "${FUNCNAME[0]}" 'success'
    return 0
  else
    # Somehow the number of lines did't change even though we found the pattern (obviously an error).
    error "${FUNCNAME[0]}" 'error_number_of_lines_after_edit_did_not_change'
    return 9
  fi
}
export -f remove_all_lines_by_regexp

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   replace_all_lines_by_regexp - Replaces all lines matching a regular expression in a file.
#
# SYNOPSIS
#   replace_all_lines_by_regexp FILE PATTERN INJECT_CONTENT
#
# DESCRIPTION
#   Parses the given FILE and replaces all lines that contain a match for the given
#   regular expression REGEX with the new content INJECT_CONTENT. Utilizes sed for
#   in-place editing and supports using sudo for file access if needed.
#   PATTERN - The pattern is the POSIX regular expression:
#             https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
#             but with platform-specific extensions (which vary in extent and can be incompatible).
#             On Linux platforms (GNU userland), see man grep; on macOS/BSD platforms, see man re_format.#
#
# USAGE EXAMPLE
#   replace_all_lines_by_regexp "/path/to/file.txt" "old_content" "new_content"
#   replace_all_lines_by_regexp "/some/path/to/the/file.txt" "Some old content regexp \(.*\)" "New content"
#   if [ $? -eq 0 ]; then
#     echo "Successfully changed ${LINES_CHANGED_COUNT} line(s)"
#
# EXIT STATUS
#   0 - Successfully changed lines (and print number of changed lines to the standard output)
#   1 - Missing inputs: regular expression or replacement string is empty
#   2 - Missing target filename
#   3 - Target file does not exist
#   4 - Not enough permissions to read the target file
#   5 - Not enough permissions to write the target file
#   6 - The pattern was not found (in some cases this might be 'success' because some line was already changed successfully before (example: call same f-n twice))
#   7 - Failed to search by given pattern (most probably bad regex pattern)
#   8 - Editor return an error (most probably bad regex pattern
#   9 - Zero lines changed (despite the pattern was found and editor didn't error out and we have all the permissions)
#  10 - Failed to create temporary file
#  11 - Failed to copy target file to temporary file
#  12 - Failed to remove temporary file
#  13 - Failed to calculate difference after edit
#
###############################################################################
function replace_all_lines_by_regexp {

  # Check dependencies
  local DEPENDENCIES="error grep sed ensure_variable_not_empty diff"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Take arguments
  local FILEPATH="${1}"
  local REGEX="${2}"
  local INJECT_CONTENT="${3}"

  # Check required arguments are not empty (note: ${INJECT_CONTENT} can be empty)
  # Define required variables
  local REQUIRED_VARIABLES=(
    FILEPATH
    REGEX
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      error "${FUNCNAME[0]}" "Failed to ensure required environment variable is not empty: '${VARIABLE_NAME,,}'"
      return 1
    }
  done

  # Check the target file exists
  [ -f "${FILEPATH}" ] || { error "${FUNCNAME[0]}" 'error_target_file_does_not_exist'; return 3; }

  # Try to find by given regexp
  local GREP_OUTPUT
  GREP_OUTPUT=$( grep --quiet "${REGEX}" "${FILEPATH}" 2>&1 )
  local EXIT_CODE=${?}

  # Check if the pattern is found
  if [ ${EXIT_CODE} -eq 1 ]; then
    # The pattern was not found
    error "${FUNCNAME[0]}" 'error_pattern_was_not_found'
    return 6
  fi
  if [ ${EXIT_CODE} -gt 1 ]; then
    # Error: 7 - failed to search by given pattern.
    # Pass grep output through stdout.
    error "${FUNCNAME[0]}" 'failed_to_search_by_given_pattern'
    return 7
  fi

  # Make a temporary copy of the edited file (the only reason: we need to count number of modified lines by the editor)
  ORIGINAL_FILE_COPY="$( mktemp 2>&1 )"
  if [ ${?} -ne 0 ] || [ ! -f "${ORIGINAL_FILE_COPY}" ]; then
    # Failed to create temporary file. Details: ${ORIGINAL_FILE_COPY}
    error "${FUNCNAME[0]}" 'error_failed_to_create_temporary_file'
    return 10
  fi

  # Create a temporary copy of the target file before editing it
  cp "${FILEPATH}" "${ORIGINAL_FILE_COPY}"
  if [ ${?} -ne 0 ]; then
    # Failed to copy file ${FILEPATH} to temporary file ${ORIGINAL_FILE_COPY}
    error "${FUNCNAME[0]}" 'failed_to_copy_target_to_temporary_file'
    return 11
  fi

  # We found line(s) in the target file. Edit file:
  local EDITOR_OUTPUT
  EDITOR_OUTPUT=$( sed -i "s/${REGEX}/${INJECT_CONTENT}/g" "${FILEPATH}" 2>&1 )

  # Check if stream editor error out.
  # Example: bad pattern would return code=1 and error message: sed: -e expression #1, char 8: unterminated address regex
  local EDITOR_CODE=${?}
  if [ ${EDITOR_CODE} -ne 0 ]; then
    # Error: inline editor returned an error (most probably bad regex pattern)
    # Pass editor output (error details) to stdout.
    error "${FUNCNAME[0]}" 'error_inline_editor_returned_bad_code'
    # Remove temporary file
    rm "${ORIGINAL_FILE_COPY}" || { error "${FUNCNAME[0]}" 'error_removing_temporary_file'; return 12; }
    return 8
  fi

  # Count the number of modified lines
  # Note: sed always return 0, so it won't let us know how many changes were done unless we count "before" and "after"
  MODIFIED_LINES_COUNT=$( diff "${FILEPATH}" "${ORIGINAL_FILE_COPY}" | grep '^<' | wc -l ) || { error "${FUNCNAME[0]}" 'failed_to_calculate_difference_after_edit'; return 13; }

  # Remove temporary file
  rm "${ORIGINAL_FILE_COPY}" || { error "${FUNCNAME[0]}" 'error_removing_temporary_file'; return 12; }

  # Check the number of modified lines is > 0
  if [ ${MODIFIED_LINES_COUNT} -gt 0 ]; then
    # Success. Pass the number of modified lines through stdout.
    echo "${MODIFIED_LINES_COUNT}"
    # Indicate: function succeed
    error "${FUNCNAME[0]}" 'success'
    return 0
  else
    # Somehow the number of lines did't change even though we found the pattern (obviously an error).
    # Pass editor output (error details) to stdout.
    error "${FUNCNAME[0]}" 'error_zero_lines_changed'
    return 9
  fi
}
export -f replace_all_lines_by_regexp

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   s - Searches files from the current directory down for a given pattern, ignoring node_modules.
#
# SYNOPSIS
#   s PATTERN
#
# DESCRIPTION
#   Performs a recursive search for files containing the specified PATTERN, starting
#   from the current directory. It ignores any files within 'node_modules' directories
#   and is case-insensitive.
#
# USAGE EXAMPLE
#   s "search term"
#
# EXIT STATUS
#   Success if the pattern is found in any file; failure otherwise.
#
###############################################################################
function s {
#!/bin/bash -

    # Check dependencies
    local DEPENDENCIES="find grep"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    GREP_OPTIONS="--color=always"
    PATTERN="${1}"
    if [ "${PATTERN}" != "" ]; then
        find . -name "*" -type f -not -path "*node_modules*" -exec grep --ignore-case --text --line-number -H "${PATTERN}" {} \;
        return ${?}
    else
        echo "Search files in a subtree for a regex. Case insensitive." 1>&2
        echo "Usage: s pattern" 1>&2
        return 1
    fi
}
export -f s

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: FILE
#
# NAME
#   url_get - Downloads a file from a specified URL.
#
# SYNOPSIS
#   url_get URL FILEPATH
#
# DESCRIPTION
#   Downloads a file from the given URL to the specified FILEPATH. If FILEPATH is "-",
#   the content is printed to standard output. This function is designed for non-interactive
#   use, handling temporary file creation, download, and cleanup. It sets permissions for
#   downloaded files to be readable and writable by the owner and readable by the group.
#   Function sets state to indicate success or error code (because it is a complex multi-step function).
#   Note: target file FILEPATH will be overwritten upon successful completion.
#
#   Possible error codes are:
#      - error_wrong_number_of_arguments
#      - error_bad_argument_blank_url
#      - error_bad_argument_blank_filepath
#      - error_generating_tmp_filepath
#      - error_downloading_file
#      - error_bad_http_code_404
#      - error_bad_http_code_000
#      - error_printing_file
#      - error_moving_file
#      - error_removing_file
#
# USAGE EXAMPLE
#   url_get "https://example.com/file.txt" "/path/to/save/file.txt" || { error "${FUNCNAME[0]}" "Failed to download file"; return 1; }
#   CONTENT=$(url_get "https://example.com/text.txt" "-") || { error "${FUNCNAME[0]}" "Failed to download file"; return 1; }
#
# EXIT STATUS
#   0 - Success.
#   1 - Error occurred (e.g., bad arguments, download failure, etc.).
#
###############################################################################
function url_get {

  # Check dependencies
  local DEPENDENCIES="curl sudo state_set error mktemp"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Indicate: function started
  state_set "${FUNCNAME[0]}" 'started'

  # Check number of arguments: it must be exactly 2
  [ $# -ne 2 ] && { state_set "${FUNCNAME[0]}" "error_wrong_number_of_arguments"; return 1; }

  # Get/check inputs: URL
  local URL="$1"
  [ -z "${URL}" ] && { state_set "${FUNCNAME[0]}" "error_bad_argument_blank_url"; return 1; }

  # TODO: discuss if we want to user regexp to check URL is valid:
  # https://stackoverflow.com/questions/3183444/check-for-valid-link-url

  # Get/check inputs: FILEPATH
  local FILEPATH="$2"
  [ -z "${URL}" ] && { state_set "${FUNCNAME[0]}" "error_bad_argument_blank_filepath"; return 1; }

  # Create a temporary file and store it's filepath to TMP_FILEPATH
  # It will be used to download the file.
  # Note: we use "-t" to allow "mktemp" to select temporary folder for us.
  # The "XXX" in the "mktemp" arguments are template - these will be replaced
  # with random characters.

  local TMP_FILEPATH
  TMP_FILEPATH=$(mktemp -t ${FUNCNAME[0]}.XXXXXXX) || { state_set "${FUNCNAME[0]}" "error_generating_tmp_filepath"; return 1; }

  # Chmod file from "-rw-------" to default "-rw-rw-r--" 664
  chmod 664 "${TMP_FILEPATH}" || { state_set "${FUNCNAME[0]}" "error_chmod_tmp_filepath"; return 1; }

  # Start actual download
  local HTTP_CODE
  HTTP_CODE=$(curl \
  --silent    \
  --retry 5    \
  --location    \
  --retry-delay 1 \
  --retry-max-time 55 \
  --max-time 60 \
  --connect-timeout 12 \
  -o "${TMP_FILEPATH}" \
  -w "%{http_code}" \
  ${URL}) \
  || { state_set "${FUNCNAME[0]}" 'error_downloading_file'; return 1; }

  # Note: curl return code 0 does not mean successful file download.
  # We must check the HTTP_CODE has value 200 - that is the only necessary
  # and sufficient condition of successful file download.
  #
  # Example HTTP_CODE values and reasons:
  #    HTTP_CODE: 000 - one of the possible reasons: failed to resolve domain
  #    HTTP_CODE: 404 - file was not found on the server by the given URL
  #
  [ "${HTTP_CODE}" -eq 200 ] || { state_set "${FUNCNAME[0]}" "error_bad_http_code_${HTTP_CODE}"; return 1; }

  # We have file successfully downloaded file into temporary filepath: ${TMP_FILEPATH}
  # Now there are 2 cases:
  #   1) Move that file into ${FILEPATH} provided by user as f-n argument
  #   or
  #   2) Print that file to standard output if provided ${FILEPATH} is "-"
  if [ "${FILEPATH}" == "-" ]; then
      # Print file to standard output
      cat "${TMP_FILEPATH}" || { state_set "${FUNCNAME[0]}" 'error_reading_file'; return 1; }
  else
      # Move file to desired destination
      # We use -f to make mv to overwrite whenever possible without asking for any confirmations
      mv -f "${TMP_FILEPATH}" "${FILEPATH}" || {
        # If failed to move try with sudo
        local CURRENT_USER
        CURRENT_USER="$(current_user_get)" || { state_set "${FUNCNAME[0]}" 'error_getting_current_user'; return 1; }
        if can_sudo "${CURRENT_USER}"; then
          # Have sudo privileges. Try to move using 'sudo'.
          sudo mv -f "${TMP_FILEPATH}" "${FILEPATH}" || { state_set "${FUNCNAME[0]}" 'error_moving_file_as_root'; return 1; }
        else
          # Don't have sudo privileges
          state_set "${FUNCNAME[0]}" 'error_moving_file_and_no_sudo_privileges'
          return 1
        fi
      }
  fi

  # Clean up: remove temporary file (TODO: in future we might cover "partial download" case if needed)
  if [ -f "${TMP_FILEPATH}" ]; then
      rm "${TMP_FILEPATH}" || { state_set "${FUNCNAME[0]}" 'error_removing_file'; return 1; }
  fi

  # Indicate: function succeed
  state_set "${FUNCNAME[0]}" 'success'
}
export -f url_get

### END UTILITY FUNCTIONS: FILE



### BEGIN UTILITY FUNCTIONS: LOGGING / PROCESS CONTROl

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: LOGGING / PROCESS CONTROL
#
# NAME
#   abort
#
# SYNOPSIS
#   abort [custom_message]
#
# DESCRIPTION
#   This function logs a custom error message, if provided, and aborts the
#   execution of the script. If the SERVICE variable is set, it also updates
#   the service's state to 'abort' before exiting.
#
# USAGE EXAMPLE
#   do_critical_task || { abort "Critical task XYZ failed!"; }
#
# EXIT STATUS
#   Exits the script with status 1.
#
###############################################################################
function abort {

    # Check dependencies
    local DEPENDENCIES="error state_set"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    error "abort called - aborting ${*}"

    # Check if the SERVICE is set (not blank string), then also set corresponding state
    if [ -n "${SERVICE}" ]; then
        state_set ${SERVICE} abort
    fi
    exit 1
}
export -f abort

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: LOGGING / PROCESS CONTROL
#
# NAME
#   assert_clean_exit
#
# SYNOPSIS
#   assert_clean_exit command [options]
#
# DESCRIPTION
#   Executes a specified command with optional parameters. If the command
#   exits with a status other than 0, indicating failure, this function will
#   log an error and call `abort` to terminate the script execution.
#
# USAGE EXAMPLE
#   # Ensure a package update completes successfully:
#   assert_clean_exit apt-get update
#
# EXIT STATUS
#   Does not return if the command fails; otherwise, continues script execution.
#
###############################################################################
function assert_clean_exit {

  # Check dependencies
  local DEPENDENCIES="log abort"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  "${@}"
  local STATUS=${?}
  if [ ${STATUS} -ne 0 ]; then
     log "ERROR: Command \"${*}\" did not exit cleanly."
     abort
  # else
  # 	log "SUCCESS: ${@}"
  fi
}
export -f assert_clean_exit

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: LOGGING / PROCESS CONTROL
#
# NAME
#   banner
#
# SYNOPSIS
#   banner [custom_message]
#
# DESCRIPTION
#   Displays a banner at the start of a script or process, providing key
#   information such as the start time, user ID, current working directory,
#   hostname, and operating system. A custom message can also be included.
#   This function is particularly useful for logging and debugging purposes,
#   making it easier to trace the execution context of a script.
#
# USAGE EXAMPLE
#   banner "Script XYZ has started"
#
###############################################################################
function banner {
cat <<EOT
    ================================================================================
    BUILD SCRIPT: ${@}
         STARTED: $( date )
              AS: $( id )
             PWD: $( pwd )
            HOST: $( hostname )
              OS: $( uname -a )
    ================================================================================

EOT
}
export -f banner

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: LOGGING / PROCESS CONTROL
#
# NAME
#   error
#
# SYNOPSIS
#   error [message]
#
# DESCRIPTION
#   Logs a given error message, enhancing visibility by optionally prefacing
#   the message with a red font style. It forwards the message to the `log`
#   function, which outputs to both the standard error stream and the system
#   logger.
#
# USAGE EXAMPLE
#   error "Failed to download the required dependencies."
#
###############################################################################
function error {

    # Check dependencies
    local DEPENDENCIES="log"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    echo -n "${FONT_STYLE_RED}" >&2
    log error: "${@}"
    echo -n "${FONT_STYLE_NORMAL}" >&2
}
export -f error

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: LOGGING / PROCESS CONTROL
#
# NAME
#   log
#
# SYNOPSIS
#   log message
#
# DESCRIPTION
#   Outputs a given message to both the standard error stream and the system
#   logger. If the `SERVICE` environment variable is defined, it is included
#   as a prefix in the log message and used as a tag for the logger.
#
# USAGE EXAMPLE
#   log "Update process started."
#
###############################################################################
function log {

  # Check dependencies
  local DEPENDENCIES="tee"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check if optional environment SERVICE is defined, then use it as a tag for logger
  if [ "${SERVICE}" != "" ]; then
    local LOGGER_TAG="--tag '${SERVICE}'"
    local SERVICE_PREFIX="${SERVICE}: "
  else
    local SERVICE_PREFIX=''
  fi

  echo "${SERVICE_PREFIX}${*}" | tee >(logger ${LOGGER_TAG} ) >&2
}
export -f log

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: LOGGING / PROCESS CONTROL
#
# NAME
#   step
#
# SYNOPSIS
#   step [message]
#
# DESCRIPTION
#   Outputs a formatted message to standard output, visually highlighting the
#   current step of a process. The function takes an arbitrary number of arguments,
#   which are concatenated into a single message. This message is then framed
#   with lines to distinguish it as a significant step in the terminal output,
#   enhancing readability during script execution or debugging.
#
# USAGE EXAMPLE
#   step "Initializing database migration..."
#
###############################################################################
function step {
cat <<EOT

  --------------------------------------------------------------------------------
  STEP: ${@}
  --------------------------------------------------------------------------------

EOT
}
export -f step

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: LOGGING / PROCESS CONTROL
#
# NAME
#   successful_exit
#
# SYNOPSIS
#   successful_exit
#
# DESCRIPTION
#   Marks the last run state as 'success' if a `SERVICE` variable is defined,
#   and then exits the script with status 0. This function is typically called
#   at the end of a script to indicate successful completion.
#
# USAGE EXAMPLE
#   successful_exit
#
# EXIT STATUS
#   Exits the script with status 0.
#
###############################################################################
function successful_exit {

  # Check dependencies
  local DEPENDENCIES="state_set"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check if SERVICE is defined
  if [ "${SERVICE}" != "" ]; then
    local SERVICE_SUFFIX="${SERVICE}_"
    state_set "${SERVICE_SUFFIX}last_run_state" success
  fi

  exit 0
}
export -f successful_exit

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: LOGGING / PROCESS CONTROL
#
# NAME
#   warning
#
# SYNOPSIS
#   warning [message]
#
# DESCRIPTION
#   If a message is provided, it logs the message with a 'warning' level
#   through the `log` function. This function is useful for highlighting
#   non-critical issues that do not warrant script termination.
#
# USAGE EXAMPLE
#   warning "Disk space is running low."
#
###############################################################################
function warning {

    # Check dependencies
    local DEPENDENCIES="log"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    # Check input: not empty
    if [ -z "${@}" ]; then
      return
    fi

    log warning: "${@}"
}
export -f warning

### END UTILITY FUNCTIONS: LOGGING / PROCESS CONTROl


### BEGIN UTILITY FUNCTIONS: TERMINAL / SHELL

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: TERMINAL / SHELL
#
# NAME
#   bash_echo_off_set - Disables verbose bash echo.
#
# SYNOPSIS
#   bash_echo_off_set
#
# DESCRIPTION
#   Deactivates the bash 'set +x' option, stopping the printing of executed
#   commands before their execution.
#
# USAGE EXAMPLE
#   bash_echo_off_set
#
###############################################################################
function bash_echo_off_set {
  set +x
}
export -f bash_echo_off_set

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: TERMINAL / SHELL
#
# NAME
#   bash_echo_on_set - Enables verbose bash echo.
#
# SYNOPSIS
#   bash_echo_on_set
#
# DESCRIPTION
#   Activates the bash 'set -x' option, which prints all executed commands
#   before their execution. This function is a convenient way to debug bash
#   scripts.
#
# USAGE EXAMPLE
#   bash_echo_on_set
#
###############################################################################
function bash_echo_on_set {
  set -x
}
export -f bash_echo_on_set

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: TERMINAL / SHELL
#
# NAME
#   bash_echo_setting_get - Preserves current bash echo settings.
#
# SYNOPSIS
#   bash_echo_setting_get
#
# DESCRIPTION
#   Returns a string indicating whether bash xtrace (verbose echo) is
#   enabled, allowing the current setting to be restored later using
#   bash_echo_setting_set.
#
# USAGE EXAMPLE
#   BASH_ECHO_SETTINGS=$(bash_echo_setting_get)
#   bash_echo_on_set
#   # ...some operations...
#   bash_echo_setting_set "${BASH_ECHO_SETTINGS}"
#
###############################################################################
function bash_echo_setting_get {

  # Check dependencies
  local DEPENDENCIES="is_shell_attribute_set"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Preserve current xtrace state
  if is_shell_attribute_set x; then
    echo -n " XTRACE_ENABLED "
  fi
}
export -f bash_echo_setting_get

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: TERMINAL / SHELL
#
# NAME
#   bash_echo_setting_set - Restores or sets bash echo settings.
#
# SYNOPSIS
#   bash_echo_setting_set [XTRACE_ENABLED]
#
# DESCRIPTION
#   Restores bash echo settings based on the provided argument. The settings
#   string, potentially obtained from bash_echo_setting_get, dictates whether
#   to enable or disable bash xtrace.
#
# USAGE EXAMPLE
#   BASH_ECHO_SETTINGS=$(bash_echo_setting_get)
#   bash_echo_on_set
#   # ...some operations...
#   bash_echo_setting_set "${BASH_ECHO_SETTINGS}"
#
###############################################################################
function bash_echo_setting_set {

  # Check dependencies
  local DEPENDENCIES="bash_echo_off_set bash_echo_on_set"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Get all provided arguments (it supports multiple arguments)
  local BASH_ECHO_SETTINGS="${@}"

  # Check if arguments have XTRACE_ENABLED
  if [[ "${BASH_ECHO_SETTINGS}" =~ XTRACE_ENABLED ]]; then
    # Enable bash tracing
    bash_echo_on_set
  else
    # Disable bash tracing
    bash_echo_off_set
  fi
}
export -f bash_echo_setting_set


###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: TERMINAL / SHELL
#
# NAME
#   ensure_variable_defined - Checks if a given variable is defined.
#
# SYNOPSIS
#   ensure_variable_defined variable_name
#
# DESCRIPTION
#   Verifies if the specified variable is defined. If not, it logs an error
#   message with the variable name and returns a non-zero exit code.
#
# USAGE EXAMPLE
#   ensure_variable_defined "CONFIG_PATH"
#
# EXIT STATUS
#   0 - Variable is defined.
#   1 - Variable is not defined or function encountered an error.
#
###############################################################################
function ensure_variable_defined {

  # Check dependencies
  local DEPENDENCIES="tr error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  local NAME="${1}"
  [[ -z "${NAME}" ]] && { error "error_ensure_variable_defined_no_arguments"; return 1; }  # Check: NAME is not blank
  [[ -v "${NAME}" ]] && { return 0; }  # Check: variable by NAME is defined

  # Create meaningful error code, which include lowcase variable name
  local ERROR_DETAILS="Error: expected variable not set: ${NAME}"

  # Report an error and return nonzero code.
  error "${FUNCNAME[0]}" "${ERROR_DETAILS}"
  return 1
}
export -f ensure_variable_defined

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: TERMINAL / SHELL
#
# NAME
#   ensure_variable_not_empty - Checks if a variable is defined and not empty.
#
# SYNOPSIS
#   ensure_variable_not_empty variable_name
#
# DESCRIPTION
#   Verifies if the specified variable is both defined and contains a non-empty
#   value. If the variable does not meet these criteria, it logs an error and
#   returns a non-zero exit code.
#
# USAGE EXAMPLE
#   ensure_variable_not_empty "API_KEY"
#
# EXIT STATUS
#   0 - Variable is defined and not empty.
#   1 - Variable is undefined or empty, or function encountered an error.
#
###############################################################################
function ensure_variable_not_empty {

  # Check dependencies
  local DEPENDENCIES="error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  local NAME="${1}"
  [[ -z "${NAME}" ]] && { error "error_ensure_variable_not_empty_no_arguments"; return 1; }  # Check: NAME itself is not blank
  [[ -v "${NAME}" ]] && [[ -n "${!NAME}" ]] && { return 0; }  # Check: variable by NAME is defined and isn't empty

  # Create meaningful error code, which include lowcase variable name
  local ERROR_DETAILS=$( echo "error_ensure_variable_not_empty_${NAME}" | tr '[:upper:]' '[:lower:]' )

  # Report an error and return nonzero code.
  error "${ERROR_DETAILS}"
  return 1
}
export -f ensure_variable_not_empty

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: TERMINAL / SHELL
#
# NAME
#   is_shell_attribute_set - Checks if a bash shell attribute is set.
#
# SYNOPSIS
#   is_shell_attribute_set attribute
#
# DESCRIPTION
#   Determines if the specified bash shell attribute is currently set. Useful
#   for checking the state of shell options like 'x' for xtrace or 'e' for
#   error exit. See also discussion: https://stackoverflow.com/a/34709224/7022062
#
# USAGE EXAMPLE
#     set -x
#     if is_shell_attribute_set x; then echo "xtrace enabled" ; else echo "xtrace disabled"; fi # xtrace enabled
#
#     set -e
#     if is_shell_attribute_set e; then echo "yes"; else echo "no"; fi # yes
#
#     set +e
#     if is_shell_attribute_set e; then echo "yes"; else echo "no"; fi # no
#
# EXIT STATUS
#   0 - The specified bash shell attribute is set.
#   1 - The specified bash shell attribute is not set.
#
###############################################################################
function is_shell_attribute_set {
  case "$-" in
    *"${1}"*)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}
export -f is_shell_attribute_set

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: TERMIN
#   AL / SHELL
#
# NAME
#   is_shell_option_set - Checks if a bash shell option is set.
#
# SYNOPSIS
#   is_shell_option_set option
#
# DESCRIPTION
#   Examines the current bash shell to determine if a specified option, such as
#   'pipefail', is enabled. This function is particularly useful for scripting
#   environments where specific shell behaviors are required for correct operation.
#   See discussion: https://stackoverflow.com/a/34709224/7022062
#
# USAGE EXAMPLE
#     set -o pipefail
#     if is_shell_option_set pipefail; then echo "yes"; else echo "no"; fi # yes
#
#     set +o pipefail
#     if is_shell_option_set pipefail; then echo "yes"; else echo "no"; fi # no
#
# EXIT STATUS
#   0 - The specified bash shell option is set.
#   1 - The specified bash shell option is not set or the function encountered
#       an error, such as a missing dependency or an invalid option name.
#
###############################################################################
function is_shell_option_set {

  # Check dependencies
  local DEPENDENCIES="grep"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  case "$(set -o | grep "${1}")" in
    *on) return 0 ;;
    *)   return 1 ;;
  esac
}
export -f is_shell_option_set

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: TERMINAL / SHELL
#
# NAME
#   terminal_initialize - Initializes the terminal environment.
#
# SYNOPSIS
#   terminal_initialize
#
# DESCRIPTION
#   Sets up the terminal environment, ensuring the TERM variable is set and
#   initializing font style variables for colored output. This setup is only
#   performed if the terminal supports it, ensuring compatibility across different
#   terminal types.
#
# USAGE EXAMPLE
#   terminal_initialize
#
###############################################################################
function terminal_initialize {

  # Check dependencies
  local DEPENDENCIES="terminal_is_tty command_exists"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # If we do not have a terminal type, set up dumb
  if [ -z "${TERM}" ]; then
    export TERM=dumb
  fi

  export FONT_STYLE_BOLD=""
  export FONT_STYLE_GREEN=""
  export FONT_STYLE_NORMAL=""
  export FONT_STYLE_RED=""

  if terminal_is_tty ; then

    if command_exists tput >/dev/null ; then
        # If this is a TTY, These set of "FONT_STYLE_*" variables allows us to decorate the output with some style (colour, boldness)
        FONT_STYLE_BOLD="$(tput bold)"
        FONT_STYLE_GREEN="$(tput setaf 2)"
        FONT_STYLE_NORMAL="$(tput sgr0)"
        FONT_STYLE_RED="$(tput setaf 1)"
    fi
  fi
}
export -f terminal_initialize

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: TERMINAL / SHELL
#
# NAME
#   terminal_is_interactive - Checks if the terminal is interactive.
#
# SYNOPSIS
#   terminal_is_interactive
#
# DESCRIPTION
#   Determines if the current terminal session is interactive, allowing scripts
#   to adjust behavior based on the ability to interact with the user directly.
#
# USAGE EXAMPLE
#   if terminal_is_interactive; then
#     echo "Interactive session detected."
#   fi
#
###############################################################################
function terminal_is_interactive {
  # Check dependencies
  local DEPENDENCIES="command_exists"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  command_exists tty >/dev/null && tty -s && return 0 || return 1
  return 1 # Default, it isn't.
}
export -f terminal_is_interactive

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: TERMINAL / SHELL
#
# NAME
#   terminal_is_tty - Checks if the terminal is a TTY.
#
# SYNOPSIS
#   terminal_is_tty
#
# DESCRIPTION
#   Verifies if the current terminal session is attached to a teletypewriter
#   (TTY), which is essential for scripts that require direct terminal access.
#
# USAGE EXAMPLE
#   if terminal_is_tty; then
#     echo "TTY session detected."
#   fi
#
###############################################################################
function terminal_is_tty {
    [ -t 0 ] && return 0 || return 1
}
export -f terminal_is_tty

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: TERMINAL / SHELL
#
# NAME
#   terminal_reset - Resets the terminal to a sane state.
#
# SYNOPSIS
#   terminal_reset
#
# DESCRIPTION
#   Utilizes the `tput reset` and `tput sane` commands to reset the terminal
#   state. This can be particularly useful if a previous command has left the
#   terminal in an unusable or visually corrupted state.
#
# USAGE EXAMPLE
#   terminal_reset
#
###############################################################################
function terminal_reset {

  # Check dependencies
  local DEPENDENCIES="terminal_is_tty command_exists"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  terminal_is_tty && command_exists tput >/dev/null && tput reset && tput sane
}
export -f terminal_reset

### END UTILITY FUNCTIONS: TERMINAL / SHELL


### BEGIN UTILITY FUNCTIONS: PROCESS

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: PROCESS
#
# NAME
#   check_dependencies - Checks for the presence of required command-line dependencies.
#
# SYNOPSIS
#   check_dependencies CALLER_FUNCTION_NAME DEPENDENCIES...
#
# DESCRIPTION
#   This function verifies whether all specified command-line tools or dependencies
#   are installed and available in the system's PATH. It is designed to be used
#   within scripts to ensure all required dependencies are met before proceeding
#   with script execution. The function accepts a caller function name for error
#   context and a list of dependencies as a space-separated strings.
#   If any dependencies are missing, it errors out, listing all missing dependencies to standard error,
#   and returns 1.
#
# DEPENDENCIES
#   Requires 'error' function to be defined elsewhere for reporting errors.
#
# USAGE EXAMPLE
#
#    # Check dependencies defined as an array
#    local DEPENDENCIES=(
#      "error"
#      "epoch_ms_get"
#      "mkdir"
#      "is_framework_api_defined"
#      "ensure_variable_not_empty"
#      "publish_message"
#      "ff_uuid"
#      "command_exists"
#      "ff_metric"
#   )
#   check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || return 1   # Note: check_dependencies will report missing dependencies
#
#   # Check dependencies defined as a string
#   local DEPENDENCIES="dd uudecode sed cut"
#   check_dependencies "${FUNCNAME[0]}" ${DEPENDENCIES} || return 1
#
# EXIT STATUS
#   0 - Success, all dependencies are met.
#   1 - Error, one or more dependencies are not met.
#
###############################################################################
function check_dependencies {

    # Get 1st argument: caller function name
    local CALLER_FUNCTION_NAME="${1}"
    shift

    # Get all the rest of the arguments and turn them into array of strings
    local DEPENDENCIES_STRING="${@}"
    local DEPENDENCIES=($DEPENDENCIES_STRING)  # Split string into an array

    local MISSING_DEPENDENCIES=()
    local MISSING_DEPENDENCY_COUNT=0

    # Ensure the caller function name is provided
    if [[ -z "${CALLER_FUNCTION_NAME}" ]]; then
        error "${CALLER_FUNCTION_NAME}" "CALLER_FUNCTION_NAME must not be empty"
        return 1
    fi

    # Ensure there is at least one dependency to check
    if [[ ${#DEPENDENCIES[@]} -eq 0 ]]; then
        error "${CALLER_FUNCTION_NAME}" "At least one dependency must be specified"
        return 1
    fi

    # Check each dependency
    local DEPENDENCY
    for DEPENDENCY in "${DEPENDENCIES[@]}"; do
      # Ignore empty array elements
      if [[ -n "${DEPENDENCY}" ]]; then
        if ! command_exists "${DEPENDENCY}" &> /dev/null; then
            MISSING_DEPENDENCIES+=("${DEPENDENCY}")
            ((MISSING_DEPENDENCY_COUNT++))
        fi
      fi
    done

    # Report missing dependencies, if any
    if [[ "${MISSING_DEPENDENCY_COUNT}" -gt 0 ]]; then
        # Convert the array to a string with spaces separating elements
        local MISSING_LIST=$(IFS=' ' ; echo "${MISSING_DEPENDENCIES[*]}")
        if [[ "${MISSING_DEPENDENCY_COUNT}" -eq 1 ]]; then
            error "${CALLER_FUNCTION_NAME}" "Dependency not met: ${MISSING_LIST}"
        else
            error "${CALLER_FUNCTION_NAME}" "Dependencies not met: ${MISSING_LIST}"
        fi
        return 1
    fi
}

# Export the function if you need to use it in scripts sourced from this script
export -f check_dependencies

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: PROCESS
#
# NAME
#   process_is_running_as_me - Checks if a process is running as the current user.
#
# SYNOPSIS
#   process_is_running_as_me command_pattern
#
# DESCRIPTION
#   Determines if a process, specified by a command pattern, is currently
#   running under the current user's context. This is useful for scripts that
#   need to ensure certain processes are not duplicated or need to check for
#   existing instances before proceeding.
#   Note: we are checking for the pattern at the beginning of the command by default.
#
# USAGE EXAMPLE
#   if process_is_running_as_me "my_script"; then
#     echo "Instance of my_script is already running."
#   fi
#
###############################################################################
function process_is_running_as_me {

    # Check dependencies
    local DEPENDENCIES="command_exists ps grep current_user_get error"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    local COMMAND_PATTERN="${1}"
    [ -n "${COMMAND_PATTERN}" ] || { error "${FUNCNAME[0]}" 'error_require_pattern_to_search_for'; return 1; }

    # We require PS and GREP commands
    local PS
    PS=$( command_exists ps ) || { error "${FUNCNAME[0]}" 'error_dependency_not_met_ps_command'; return 1; }

    local GREP
    GREP=$( command_exists grep ) || { error "${FUNCNAME[0]}" 'error_dependency_not_met_grep_command'; return 1; }

    # Get current user. Note: the ${USER} environment is NOT set when running as 'root' in docker, we must use f-n current_user_get() instead.
    local CURRENT_USER
    CURRENT_USER="$(current_user_get)" || { error "Can not get current user"; return 1; }

    ${PS} -u "${CURRENT_USER}" -U "${CURRENT_USER}" o command | ${GREP} --silent -e "^${COMMAND_PATTERN}"
}
export -f process_is_running_as_me

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: PROCESS
#
# NAME
#   retry_command - Retries a command until it succeeds no more than the given number of attempts.
#
# SYNOPSIS
#   retry_command retry_attempts_max sleep_between_tries_seconds command [arguments...]
#
# DESCRIPTION
#   Attempts to execute a specified command multiple times, with a delay
#   between each attempt, until the command exits successfully. This function
#   is useful for operations that may fail temporarily due to external factors,
#   such as network issues or resource locks.
#
# USAGE EXAMPLE
#   # Retry up to 5 times to dowload a file by URL "http://example.com/somefile.txt"
#   retry_command 5 10 wget "http://example.com/somefile.txt"
#
#   # Retry up to 5 times to install_xyz(), sleep 10 seconds between tries
#   retry_command 5 10 install_xyz || { abort "Failed to install_xyz"; }
#
# EXIT STATUS
#   0 - Command executed successfully within the given attempts.
#   Non-zero - Command failed after all attempts or bad arguments Error printed to standard error.
#              Note: the error code will be actual command exit code returned on the last failed attempt.
#
###############################################################################
function retry_command {

    # Check dependencies
    local DEPENDENCIES="error"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    # Get number of max attempts
    RETRY_ATTEMPTS_MAX=$1
    # Shift all arguments to the left (original $1 gets lost)
    shift

    # Check argument not empty and >0
    [ "${RETRY_ATTEMPTS_MAX}" != "" ] || { error "${FUNCNAME[0]}" 'failed_to_get_retry_attempts_max'; return 1; }
    [ "${RETRY_ATTEMPTS_MAX}" -gt 0 ] || { error "${FUNCNAME[0]}" 'error_retry_attempts_max_must_be_positive_number'; return 1; }

    # Get number of seconds to sleep between attempts
    SLEEP_SECONDS=$1
    shift # Shift all arguments to the left (original $1 gets lost)

    # Check argument not empty & >1
    [ "${SLEEP_SECONDS}" != "" ] || { error "${FUNCNAME[0]}" 'failed_to_get_sleep_seconds'; return 1; }
    [ "${SLEEP_SECONDS}" -gt 0 ] || { error "${FUNCNAME[0]}" 'error_sleep_seconds_must_be_postive_number'; return 1; }

    # Get the rest of the arguments as an array
    local COMMAND_AS_ARRAY=("$@")

    # Check: the command as array must be non-empty
    [ -n "${COMMAND_AS_ARRAY}" ] || { error "${FUNCNAME[0]}" 'error_got_empty_command'; return 1; }

    # Attempts loop: we will break out of the loop only if command is succeed or
    local ATTEMPT_COUNT=0
    local FAILED_COMMAND_EXIT_CODE=0
    while [ ${ATTEMPT_COUNT} -lt ${RETRY_ATTEMPTS_MAX} ]
    do
        # Increment attempts counter
        ATTEMPT_COUNT=$((ATTEMPT_COUNT+1))

        # Try the command and break the loop (by return 0) if succeed
        "${COMMAND_AS_ARRAY[@]}" && return 0

        # Preserve actual exit code returned by failed command (this will be non-zero value)
        FAILED_COMMAND_EXIT_CODE=$?

        # Sleep only if not last attempt
        [ ${ATTEMPT_COUNT} -lt ${RETRY_ATTEMPTS_MAX} ] && sleep ${SLEEP_SECONDS}
    done

    # Command failed on all attempts
    error "${FUNCNAME[0]}" "failed_after_all_attempts"

    # Return preserved bad code returned by the command
    return ${FAILED_COMMAND_EXIT_CODE}
}
export -f retry_command

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: PROCESS
#
# NAME
#   service_is_running - Checks if a service by a given name is running.
#
# SYNOPSIS
#   service_is_running service_name
#
# DESCRIPTION
#   Checks if the specified service is currently active (running). This function
#   is useful for script logic that depends on the state of system services.
#   It returns a code indicating the status (0 for running, non-zero for not running or error).
#
# USAGE EXAMPLE
#   # Check if the 'docker' service is running
#   if service_is_running docker; then
#     echo "Docker is running."
#   else
#     echo "Docker is not running."
#   fi
#
# EXIT STATUS
#   0 - Service is running.
#   Non-zero - Service is not running or an error occurred.
#
###############################################################################
function service_is_running {

  # Check dependencies
  local DEPENDENCIES="systemctl error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Take arguments
  local SERVICE_NAME="$1"

  # Check arguments (must be non-empty string)
  [ ! -z "${SERVICE_NAME}" ] || { error "${FUNCNAME[0]}" 'error_empty_argument'; return 1; }

  # Do the check
  systemctl is-active --quiet "${SERVICE_NAME}"
}
export -f service_is_running

### END UTILITY FUNCTIONS: PROCESS


### BEGIN UTILITY FUNCTIONS: STATE/SECRETS

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: PROCESS
#
# NAME
#   generate_strong_password - Generates a strong password with a default length of 16 characters or a specified length.
#
# SYNOPSIS
#   generate_strong_password [PASSWORD_LENGTH]
#
# DESCRIPTION
#   Utilizes a combination of 'dd', 'uudecode', 'sed', and 'cut' to generate
#   a strong password of specified length, printed to standard output. If no length
#   is specified, a 16-character password is generated by default. Suitable for creating
#   secure passwords for applications and services. PASSWORD_LENGTH must be a number
#   in the range [1..660]. If outside the range, it defaults to 1 or 660 depending on the input.
#
# DEPENDENCIES
#   Requires 'dd', 'uudecode', 'sed', and 'cut' to be installed on the system.
#
# USAGE EXAMPLE
#   PASSWORD=$(generate_strong_password) || { error "failed to generate password"; return 1; }
#   CUSTOM_PASSWORD=$(generate_strong_password 20) || { error "failed to generate password"; return 1; }
#
# EXIT STATUS
#   0 - Success, password generated.
#   1 - Error, invalid input or dependency not met.
#
###############################################################################
function generate_strong_password {

    # Check dependencies
    local DEPENDENCIES="dd uudecode sed cut error"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    # Works on Linux and Mac
    local PASSWORD_LENGTH_DEFAULT=16
    local PASSWORD_LENGTH_MIN=1
    local PASSWORD_LENGTH_MAX=660

    # Use the first argument as PASSWORD_LENGTH, default to PASSWORD_LENGTH_DEFAULT if not provided
    local PASSWORD_LENGTH=${1:-${PASSWORD_LENGTH_DEFAULT}}

    # Validate PASSWORD_LENGTH is a number and in the correct range
    if ! [[ ${PASSWORD_LENGTH} =~ ^[0-9]+$ ]]; then
        error "${FUNCNAME[0]}" "error_invalid_argument_PASSWORD_LENGTH_must_be_a_number"
        return 1
    elif (( PASSWORD_LENGTH < PASSWORD_LENGTH_MIN )); then
        PASSWORD_LENGTH=${PASSWORD_LENGTH_MIN}
    elif (( PASSWORD_LENGTH > PASSWORD_LENGTH_MAX )); then
        PASSWORD_LENGTH=${PASSWORD_LENGTH_MAX}
    fi

    # The following command produces a 660 characters long random string
    local RANDOM_STRING=$(dd if=/dev/urandom count=1 2> /dev/null | uuencode -m - | sed -ne '2,12p' | tr -d '\n') || { error "${FUNCNAME[0]}" 'failed_to_generate_random_string'; return 1; }

    # Cut the first PASSWORD_LENGTH characters
    echo "${RANDOM_STRING}" | cut -c 1-${PASSWORD_LENGTH}
}
export -f generate_strong_password

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: PROCESS
#
# NAME
#   secret_get - Retrieves a secret value by its key.
#
# SYNOPSIS
#   secret_get key_name
#
# DESCRIPTION
#   Looks up a secret value by its key name from a predefined storage location,
#   intended for securely managing configuration data like passwords or API keys.
#   The function ensures bash echo is disabled during its operation to prevent
#   sensitive information leakage and requires 'FF_AGENT_HOME' to be defined for
#   specifying the storage location.
#
# DEPENDENCIES
#   Requires 'tr' to be installed on the system.
#
# USAGE EXAMPLE
#   API_KEY=$(secret_get "api_service_key") || { error "failed to get api key"; return 1; }
#
# EXIT STATUS
#   0 - Secret found and printed to standard output.
#   1 - Secret not found, or an error occurred, including missing dependencies.
#
###############################################################################
function secret_get {

  # Check dependencies
  local DEPENDENCIES="tr cut error command_exists bash_echo_setting_get bash_echo_off_set"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Preserve current bash echo settings and enable bash echo setting
  BASH_ECHO_SETTINGS=$( bash_echo_setting_get ) || { error "${FUNCNAME[0]}" 'failed_to_bash_echo_setting_gets'; return 1; }

  bash_echo_off_set || { error "${FUNCNAME[0]}" 'failed_to_bash_echo_off_set'; return 1; } # Disable xtrace to avoid priting secrets

  local KEY="${1}"

  # Check KEY is not blank
  [ -n "${KEY}" ] || { error "secret_get(): blank KEY argument"; return 1; }

  # Check if KEY contains any prohibited symbols, then error out.
  [[ ! "${STATE_NAME}" =~ ([^a-z0-9_]+) ]] || {
    error "${FUNCNAME[0]}" 'error_bad_argument_illigal_charaacters_in_key'
    return 1
  }

  # Check if FF_AGENT_HOME is not empty
  if [ "${FF_AGENT_HOME}" == "" ]; then
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" 'error_ff_agent_home_not_set'
    return 1
  fi

  # Check if key is not empty
  if [ "${KEY}" == "" ]; then
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" 'error_empty_key'
    return 1
  fi

  # Due to the previous runs we sometimes end up with secret files having 'null' as a value (4-byte).
  # Let's run cleanup only once (upon 1st call) and set the flag to avoid any futher cleaning ups during this run.
  # Note: -z - true if the length of string is zero
  #       -n - true if the length of string is nonzero
  if [ -z "${SECRET_GET_WIPE_NULLS_RUN_ONCE_FLAG}" ]; then
      # Note: --files-with-matches - Suppress normal output; instead print the  name  of  each  input
      #                              file  from  which  output would normally have been printed.  The
      #                              scanning will stop on the first match.
      grep --files-with-matches null "${FF_AGENT_HOME}/secrets/*" 2>/dev/null | xargs rm 2>/dev/null
      SECRET_GET_WIPE_NULLS_RUN_ONCE_FLAG="any non empty string can be 'a flag'"
  fi

  # Case: requested key already exists in ff_agent "secrets/" folder
  if [ -e "${FF_AGENT_HOME}/secrets/${KEY}" ]; then
      cat "${FF_AGENT_HOME}/secrets/${KEY}"
      bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
      return 0
  fi

  # Case: cloud user-data JSON exists: search value by given KEY in it under "agent/configuration"
  if [ -e /var/lib/cloud/instance ]; then

      # Generic case: get value by given KEY from root level of agent/configuration JSON
      VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq '.[] | select(.mime_type=="agent/configuration")' | jq -r ".${KEY}" | grep -v -e '^null$' )
      # Note: -z - true if the length of string is zero
      #       -n - true if the length of string is nonzero
      if [ -n "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
          echo ${VALUE}
          bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
          return 0
      fi

      # Special case for "ff_agent_api_username" and "ff_agent_api_password" - these 2 values
      # are nested few levels deep in "agent/configuration"
      if [ "${KEY}" == "ff_agent_api_username" ] || [ "${KEY}" == "FF_AGENT_API_USERNAME" ]; then
        # TODO: here we rely on provisioning JSON on agent to have "control_api_user", which is incorrectly named and must be redesigned completely.
        VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq -r '.[] | select(.mime_type == "agent/configuration") | .roles[] | select(.role_name == "AgentRole") | .services[] | select(.service_name == "ActionManager") | .control_api_user' )
        if [ -n "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
            echo ${VALUE}
            bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
            return 0
        fi
      fi
      if [ "${KEY}" == "ff_agent_api_password" ] || [ "${KEY}" == "FF_AGENT_API_PASSWORD" ]; then
        # TODO: here we rely on provisioning JSON on agent to have "control_api_password", which is incorrectly named and must be redesigned completely.
        VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq -r '.[] | select(.mime_type == "agent/configuration") | .roles[] | select(.role_name == "AgentRole") | .services[] | select(.service_name == "ActionManager") | .control_api_password' )
        if [ -n "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
            echo ${VALUE}
            bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
            return 0
        fi
      fi
  fi

  # Case: search in "provisioning/instance"
  if [ -e /var/lib/cloud/instance ]; then
      VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq '.[] | select(.mime_type=="provisioning/instance")' | jq -r ".${KEY}" | grep -v -e '^null$' )
      # Note: -z - true if the length of string is zero
      #       -n - true if the length of string is nonzero
      if [ -n "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
          echo ${VALUE}
          bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
          return 0
      fi
  fi

  # Case: We are on a local VM agent - let's check user_data.editor_answers.json
  USER_DATA="/etc/ff/configuration/user_data.editor_answers.json"
  if [ -e "${USER_DATA}" ]; then
    VALUE=$( cat "${USER_DATA}" | jq ".${KEY}" | cut -d'"' -f2 )
      if [ -n "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
          bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
          echo ${VALUE}
          return 0
      fi
  fi

  # Case: We are on a new build (blank cloud box with user_data.json injected as: /etc/ff/configuration/user_data.json )
  if [ -f /etc/ff/configuration/user_data.json ]; then
      VALUE=$( sudo cat /etc/ff/configuration/user_data.json | jq '.[] | select(.mime_type=="agent/configuration")' | jq -r ".${KEY}" | grep -v -e '^null$' )
      if [ -n "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
          bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
          echo ${VALUE}
          return 0
      fi
  fi

  # Case: We're looking for KEY=="FF_AGENT_URI" and we are on a traffic_generator.
  # In this case FF_AGENT_URI was already generated and stored to /etc/ff/configuration/agent_uri
  # Let's retreive it from there and re-store it by secret_set()
  if [ "${KEY}" == "ff_agent_uri" ] && [ -f /etc/ff/configuration/agent_uri ]; then
    FF_AGENT_URI="$( cat /etc/ff/configuration/agent_uri )"
    # Store "agent" to proper unified place for secrets, so we don't have to look for it in random places again next time.
    if [ -n "${FF_AGENT_URI}" ]; then
      secret_set ff_agent_uri "${FF_AGENT_URI}"
      bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
      echo "${FF_AGENT_URI}"
      return 0
    fi
  fi

  # Case: We are on a legacy portal server in Amazon
  for environment in production staging development
  do
      ENVPATH="${HOME}/.control/environment/${environment}"
      if [ -e "${ENVPATH}" ]; then
          VALUE=$( grep -i "^${KEY}=" ${ENVPATH}/* | cut -d= -f2 | head -1 )
          if [ -n "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
              echo ${VALUE}
              bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
              return 0
          fi
      fi
  done

  bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
  error "${FUNCNAME[0]}" "Failed to find secret value by key: '${KEY}'"
  return 1
}
export -f secret_get

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: PROCESS
#
# NAME
#   secret_set - Sets a secret key/value pair.
#
# SYNOPSIS
#   secret_set key value
#
# DESCRIPTION
#   Stores a key/value pair as a secret, facilitating secure storage for sensitive
#   information. The function disables bash echo to protect the secret during
#   its operation and requires 'FF_AGENT_HOME' to be defined for specifying the
#   storage location.
#
# DEPENDENCIES
#   Requires the bash echo setting control functions and 'tr'.
#
# USAGE EXAMPLE
#   secret_set "database_password" "S3cur3P@ssw0rd"
#
# EXIT STATUS
#   0 - Secret successfully set.
#   1 - Error occurred, such as missing dependencies or failure to write the secret.
#
###############################################################################
function secret_set {

  # Check dependencies
  local DEPENDENCIES="bash_echo_setting_get bash_echo_off_set bash_echo_setting_set mkdir error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Preserve current bash echo settings and enable bash echo setting
  BASH_ECHO_SETTINGS=$( bash_echo_setting_get ) || { error "${FUNCNAME[0]}" 'failed_to_bash_echo_setting_gets'; return 1; }

  bash_echo_off_set || { error "${FUNCNAME[0]}" 'failed_to_bash_echo_off_set'; return 1; } # Disable xtrace to avoid priting secrets

  # Get arguments
  local URI="${1}"
  local SECRET="${2}"

  # Check FF_AGENT_HOME is set
  [ -n "${FF_AGENT_HOME}" ] || {
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" 'error_envirnment_not_set_ff_agent_home'
    return 1
  }

  # Check URI is not blank
  [ -n "${URI}" ] || {
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" 'error_blank_uri_argument'
    return 1
  }

  # Check if URI contains any prohibited symbols, then error out.
  [[ ! "${URI}" =~ ([^a-z0-9_]+) ]] || {
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" 'error_illigal_characters_in_uri_argument'
    return 1
  }

  # Check SECRET is not empty
  if [ -z "${SECRET}" ]; then
      bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
      error "${FUNCNAME[0]}" 'error_bad_argument_secret'
      return 1
  fi

  # Create secrets directory
  local SECRET_DIRECTORY="${FF_AGENT_HOME}/secrets"
  mkdir -p "${SECRET_DIRECTORY}" || {
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" 'failed_to_create_secrets_directory'
    return 1
  }

  # Store secret
  echo "${SECRET}" >"${SECRET_DIRECTORY}/${URI}" || {
    error "${FUNCNAME[0]}" 'failed_to_write_secret'
    return 1
  }

  bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
}
export -f secret_set

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: PROCESS
#
# NAME
#   state_get - Retrieves a previously set state by its name.
#
# SYNOPSIS
#   state_get state_name
#
# DESCRIPTION
#   Attempts to read a named state's value from a dedicated storage location,
#   printing the value to standard output if found. The function aims to preserve
#   bash echo settings while performing its operation to maintain script verbosity
#   control.
#
# USAGE EXAMPLE
#   CURRENT_STATE=$(state_get "operation_status")
#
# EXIT STATUS
#   0 - State found and printed to standard output.
#   1 - State not found or an error occurred.
#
###############################################################################
function state_get {

  # Check dependencies
  local DEPENDENCIES="error bash_echo_setting_get bash_echo_off_set bash_echo_setting_set"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Preserve current bash echo settings and enable bash echo setting
  BASH_ECHO_SETTINGS=$( bash_echo_setting_get ) || { error "${FUNCNAME[0]}" 'failed_to_bash_echo_setting_gets'; return 1; }

  bash_echo_off_set || { error "${FUNCNAME[0]}" 'failed_to_bash_echo_off_set'; return 1; } # Disable xtrace to avoid priting secrets

  # Get 1 argument: state name
  STATE_NAME="${1}"

  # Check state name isn't
  [ -n "${STATE_NAME}" ] || { error "state_get(): blank state name argument"; return 1; }

  # Check if state name contains any prohibited symbols, then error out.
  [[ ! "${STATE_NAME}" =~ ([^a-z0-9_]+) ]] || { error "state_get(): illigal characters in the state name argument: '${BASH_REMATCH[1]}'"; return 1; }

  # Make sure "${FF_AGENT_HOME}" is not empty
  if [ -z "${FF_AGENT_HOME}" ]; then
      error "Can not set state. FF_AGENT_HOME variable not defined. State would have been set to ${STATE_NAME}=${VALUE}"
      bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
      return 1
  fi

  # Construct path to the state file
  STATE_DIR="${FF_AGENT_HOME}/state"
  STATE_FILE="${STATE_DIR}/${STATE_NAME}"

  # Check if state file exists
  if [ -f "${STATE_FILE}" ]; then
    # State file found, try to print it's content and preserve result code
    local VALUE
    VALUE="$( cat "${STATE_FILE}" )"
    local EXIT_CODE=${?}
    # Print value to standard output
    echo -n "${VALUE}"
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    return ${EXIT_CODE}
  else
    # Error: state file not found. Restore xtrace and eturn code 1
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    return 1
  fi
}
export -f state_get

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: PROCESS
#
# NAME
#   state_set - Sets a named state with a specified value.
#
# SYNOPSIS
#   state_set state_name value
#
# DESCRIPTION
#   Stores a named state's value, providing a mechanism for tracking script
#   execution states, like 'success', 'running', or 'error'. It also constructs
#   and publishes a JSON object reflecting the state change to a predefined
#   messaging endpoint if the framework API is defined.
#
# VALUE CONVENTIONS
#  - The successfull end of some action or function should be noted by "success" value.
#  - The state name must be in lower case and contain only alphanumeric characters and underscore.
#  - The error code must start with prefix "failed_" or "error_" followed by an error message.
#  - Do not put dynamic neither in the error message nor in the state name. For example,
#    "failed_to_download_file" is OK, but "failed_to_download_file_after_28_attempts" is not (do not
#    polute the states set space).
#
# USAGE EXAMPLE
#   state_set "some_function_name" "success"
#   state_set "${FUNCNAME[0]}" "bad_arguments"
#
# EXIT STATUS
#   0 - State successfully set.
#   1 - Error occurred, such as a missing 'FF_AGENT_HOME' variable or illegal characters in input.
#
###############################################################################
function state_set {

  # Check dependencies
  local DEPENDENCIES=(
    "error"
    "epoch_ms_get"
    "mkdir"
    "is_framework_api_defined"
    "ensure_variable_not_empty"
    "publish_message"
    "ff_uuid"
    "command_exists"
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[@]}" || return 1  # Note: check_dependencies will report missing dependencies

  # Get 2 arguments: state and value
  local STATE_NAME="${1}"
  local STATE_VALUE="${2}"

  # Check state name / value aren't blank
  [ -n "${STATE_NAME}" ] || { error "state_set(): blank state name argument"; return 1; }
  [ -n "${STATE_VALUE}" ] || { error "state_set(): blank state value argument"; return 1; }

  # Check if state name / vaue contains any prohibited symbols, then error out.
  [[ ! "${STATE_NAME}" =~ ([^a-z0-9_]+) ]] || { error "state_set(): illigal characters in the state name argument: '${BASH_REMATCH[1]}'"; return 1; }
  [[ ! "${STATE_VALUE}" =~ ([^a-z0-9_]+) ]] || { error "state_set(): illigal characters in the state value argument: '${BASH_REMATCH[1]}'"; return 1; }

  # Make sure "${FF_AGENT_HOME}" is not empty
  if [ -z "${FF_AGENT_HOME}" ]; then
      error "Can not set state. FF_AGENT_HOME variable not set. State would have been set to ${STATE_NAME}=${STATE_VALUE}"
      return 1
  fi

  local STATE_DIR="${FF_AGENT_HOME}/state"

  # Make state directory
  if [ ! -d "${STATE_DIR}" ]; then

    mkdir -p "${STATE_DIR}" || {
      error "Can not set state. State directory ${STATE_DIR} can not be created. State would have been set to ${STATE_NAME}=${STATE_VALUE}"
      return 1;
    }
  fi

  # Define state filename
  local STATE_FILE="${STATE_DIR}/${STATE_NAME}"

  # Write value into the file
  echo "${STATE_VALUE}" >"${STATE_FILE}" || { error "${FUNCNAME[0]}: failed_to_write_state. State would have been set to ${STATE_NAME}=${STATE_VALUE}"; return 1; }

  # ------------------ Build JSON object "state/change" and send to FF_AGENT_API_FQDN

  # Temporarily disable sending state/change to the portal, until it is working reliably
  return 0

  # Check if framework API is defined
  if [ "$( is_framework_api_defined )" != "true" ]; then
    # No, the framework API is not defined. Simply return, we're done.
    # Return with success code 0
    return 0
  fi

  # Temporary: On early stages the FF_AGENT_URI is not yet defined. Check & log it if this is the case.
  if [ -z "${FF_AGENT_URI}" ]; then
    # FF_AGENT_URI is not yet defined. Log it (and what was the state name/value)
    error "WARNING: set_state() called while FF_AGENT_URI is not yet defined (this is expected for early stages callers like 'assert_ff_agent_home_exists')! STATE_NAME: ${STATE_NAME}, STATE_VALUE: ${STATE_VALUE}"

    # Return with success code 0
    return 0
  fi

  # Get current epoch time
  local TIMESTAMP_EPOCH_MS
  TIMESTAMP_EPOCH_MS="$( epoch_ms_get )" || { error "${FUNCNAME[0]}: failed to get time by calling epoch_ms_get()"; return 1; }

  # Check if we actually got non-empty string?
  [ -n "${TIMESTAMP_EPOCH_MS}" ] || { error "${FUNCNAME[0]}: got empty timestamp_epoch_ms value"; return 1; }

  # If state value contains: success|running, then: "is_success": true
  # else
  #   if state value contains: error|fail|'', then "is_error": true
  # else
  #   don't include neither "is_success" nor "is_error".
  local IS_SUCCESS_OR_IS_ERROR_JSON=''
  local IS_ERROR=false
  if [[ "${STATE_VALUE}" =~ success|running ]]; then
    IS_SUCCESS_OR_IS_ERROR_JSON='"is_success": true,'
  else
    if [[ "${STATE_VALUE}" == '' || "${STATE_VALUE}" =~ error|fail ]]; then
      IS_SUCCESS_OR_IS_ERROR_JSON='"is_error": true,'
      IS_ERROR=true
    fi
  fi

  # Get previous "old" state value
  local PREVIOUS_STATE_JSON=""
  local PREVIOUS_STATE_VALUE="$( cat ${STATE_FILE} )"
  # Only include "old_state" property if it is not-empty string
  if [ "${PREVIOUS_STATE_VALUE}" != "" ]; then
    PREVIOUS_STATE_JSON="\"previous_state\": \"${PREVIOUS_STATE_VALUE}\","
  fi

  # Compose "state/chate" JSON and pipe it to publish_message()
  # Note: we POST "state/change" JSON to ff_agent_api_fqdn. (from portal to self, from 'traffic generator' to portal, from 'inside docker' to (agent?)).
  local UUID
  UUID="$( ff_uuid )" || { error "${FUNCNAME[0]}" 'failed_generate_uuid'; return 1; }

  # Check: all the environment variables used in JSON are actually set.
  local ALL_EXPECTED_ENVRIONMENT_VARIABLES=(
    FF_AGENT_URI
    FF_AGENT_API_USERNAME
    FF_AGENT_API_PASSWORD
    FF_AGENT_API_FQDN
    HOSTNAME
    MIME_TYPE
    NAMESPACE
    ORGANIZATION
    STATE_NAME
    STATE_VALUE
    TIMESTAMP_EPOCH_MS
    UUID
  )

  # Define mime_type value
  MIME_TYPE="state/change"

  for VARIABLE_NAME in "${ALL_EXPECTED_ENVRIONMENT_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      local ERROR_DETAILS=$( echo "Required environment variable '${VARIABLE_NAME}' is not set." | tr '[:upper:]' '[:lower:]' )
      error "${FUNCNAME[0]}: ${ERROR_DETAILS}"
      return 1
    }
  done

  # Commpose JSON and publish it
  (
    cat <<- EOF
{
  "mime_type": "${MIME_TYPE}",
  "uri_template": "[namespace]::/organization/[organization]/[mime_type]/[uuid]",
  "uri": "${NAMESPACE}::/organization/${ORGANIZATION}/${MIME_TYPE}/${UUID}",
  "uuid": "${UUID}",
  "id": "${STATE_NAME}",
  "state": "${STATE_VALUE}",
  ${PREVIOUS_STATE_JSON}
  ${IS_SUCCESS_OR_IS_ERROR_JSON}
  "timestamp_epoch_ms": ${TIMESTAMP_EPOCH_MS},
  "ff_agent_uri": "${FF_AGENT_URI}",

  "is_event": true,
  "event_type": "set_environment",
  "source": "set_environment",
  "hostname": "${HOSTNAME}",
  "ff_agent_fqdn": "${FF_AGENT_FQDN}",

  "namespace": "${NAMESPACE}",
  "organization": "${ORGANIZATION}",
  "created_by": {
    "mime_type": "identity/statement",
    "user_id": $( id -u ${FF_AGENT_USERNAME} ),
    "username": "${FF_AGENT_USERNAME}"
  },
  "security_object_policy": {
    "mime_type": "security/object_policy",
    "schema_version": "ff20170505",
    "policy_language": "ff",
    "scope": {
      "can_read": "organization",
      "can_write": "system",
      "can_delete": "system"
    }
  }
}
EOF
) | publish_message

  # If we have ff_metric command handy try to sent the metric with name STATE_NAME and value 1
  if command_exists ff_metric >/dev/null; then
    # Report metric: start:1    tags: service:ipsec_tunnel  (+public_ip, organization)
    ff_metric --metric-name="${STATE_NAME}" --metric-value=1 --tag=state:"${STATE_VALUE}" --tag=is_error:"${IS_ERROR}"
  fi
}
export -f state_set

### END UTILITY FUNCTIONS: STATE/SECRETS



### BEGIN UTILITY FUNCTIONS: USER / GROUPS

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: USER / GROUPS
#
# NAME
#   can_sudo - Checks if a specified user can execute sudo commands.
#
# SYNOPSIS
#   can_sudo user_to_check
#
# DESCRIPTION
#   Determines whether the specified user has sudo privileges by checking
#   system configurations and group memberships. It ensures that scripts
#   and operations are executed by users with the necessary permissions.
#
# USAGE EXAMPLE
#   if can_sudo "john_doe"; then
#     echo "User john_doe can execute sudo commands."
#   fi
#
# EXIT STATUS
#   0 - User can execute sudo commands.
#   1 - User cannot execute sudo commands or an error occurred.
#
###############################################################################
function can_sudo {

    # Check dependencies
    local DEPENDENCIES="sudo groups grep"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    # Take argument
    local USER_TO_CHECK="${1}"

    local USER_CAN_SUDO=1  # Assume they can't. 1 is an error code meaning we can't.

    # SUDOers can be defined in a few places - /etc/sudoers and /etc/sudoers.d/*
    # Note: /etc/sudoers is old and bad
    if sudo --non-interactive --list --other-user="${USER_TO_CHECK}" &>/dev/null true
    then
        USER_CAN_SUDO=0
    else
        if groups "${USER_TO_CHECK}" 2>/dev/null | grep --text "\<sudo\>" &> /dev/null; then
            USER_CAN_SUDO=0 # I can sudo
        else
            USER_CAN_SUDO=1 # I can't sudo
        fi
    fi

    # TODO: If user can sudo, have that user check if they are in old /etc/sudoers or new form
    # and emit error otherwise.

    return ${USER_CAN_SUDO}
}
export -f can_sudo

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: USER / GROUPS
#
# NAME
#   check_group_exists - Checks if a specified group exists on the system.
#
# SYNOPSIS
#   check_group_exists group_name
#
# DESCRIPTION
#   Verifies the existence of a group on the system. This is useful for
#   ensuring that specific user group configurations are in place before
#   proceeding with operations that require certain group memberships.
#
# USAGE EXAMPLE
#   # Check if the group "docker" exists
#   if check_group_exists "docker"; then
#     echo "Group docker exists."
#   else
#     echo "Group docker does not exist."
#   fi
#
#   # Or as a 1-liner:
#   if ! check_group_exists 'docker'; then error "Group docker does not exist"; fi
#
# EXIT STATUS
#   0 - Group exists.
#   1 - Group does not exist or function was called without arguments.
#
###############################################################################
function check_group_exists {

  # Check dependencies
  local DEPENDENCIES="error getent"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Take argument
  local GROUP="${1}"

  # Check argument is not empty
  if [ -z "${GROUP}" ]; then
    error "check_group_exists() called with no arguments"
    return 1
  fi

  # Check if the group exist by given groupname
  getent group "${GROUP}" >/dev/null
}
export -f check_group_exists

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: USER / GROUPS
#
# NAME
#   create_user - Creates a user with a disabled password.
#
# SYNOPSIS
#   create_user username
#
# DESCRIPTION
#   Adds a new user to the system with login disabled. This function is
#   particularly useful for creating service accounts or system users that
#   do not require interactive login capabilities.
#
# DEPENDENCIES
#   Requires 'sudo' and 'adduser' commands to be available on the system.
#
# USAGE EXAMPLE
#   create_user "service_account"
#
# EXIT STATUS
#   0 - User successfully created.
#   1 - User not created due to missing username, insufficient privileges,
#       or other errors.
#
###############################################################################
function create_user {

  # Check dependencies
  local DEPENDENCIES="can_sudo sudo adduser"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Get argument
  local USERNAME="${1}"
	if [ -n "${USERNAME}" ]; then
		if can_sudo "${USERNAME}"; then
        	# TODO: Make this multiplatform. Check what happens if we do this in a docker.
        	sudo adduser --disabled-password --gecos "" "${USERNAME}"
			return ${?}
		fi
	fi
	return 1
}
export -f create_user

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: USER / GROUPS
#
# NAME
#   home_directory_for_user_get - Retrieves the home directory for a specified user.
#
# SYNOPSIS
#   home_directory_for_user_get username
#
# DESCRIPTION
#   Looks up and returns the home directory of the specified user. This can
#   be useful for scripts that need to perform operations within user-specific
#   directories or need to resolve user paths dynamically.
#
# DEPENDENCIES
#   Depends on 'getent' command; may not be available on all operating systems.
#
# USAGE EXAMPLE
#   HOME_DIR=$(home_directory_for_user_get "john_doe")
#   echo "John Doe's home directory is ${HOME_DIR}."
#
# EXIT STATUS
#   0 - Home directory found and printed to standard output.
#   1 - Home directory not found or function encountered an error.
#
###############################################################################
function home_directory_for_user_get {

    # Check dependencies
    local DEPENDENCIES="getent error cut"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    # TODO: OSX doesn't have getent. Find Equivalent
    HOME_DIR=$( getent passwd "${1}" | cut -d: -f6 )
    if [ -z "${HOME_DIR}" ]; then
        error "${FUNCNAME[0]}" "Failed to retrieve home directory for user '${1}'."
        return 1
    else
        echo "${HOME_DIR}"
    fi
}
export -f home_directory_for_user_get

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: USER / GROUPS
#
# NAME
#   is_effectively_root - Checks if the current user is effectively root.
#
# SYNOPSIS
#   is_effectively_root
#
# DESCRIPTION
#   Determines if the current script or command is being executed with root
#   privileges, enabling scripts to adapt their behavior based on available
#   permissions and security considerations.
#
# USAGE EXAMPLE
#   if is_effectively_root; then
#     echo "Running with root privileges."
#   fi
#
# EXIT STATUS
#   0 - The script/command is running with root privileges.
#   1 - The script/command is not running with root privileges.
#
###############################################################################
function is_effectively_root {
    if  [ "${EUID}" -eq 0 ]; then
        return 0 # I have root powers
    else
        return 1 # Don't have root powers
    fi
}
export -f is_effectively_root

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: USER / GROUPS
#
# NAME
#   is_user_in_group - Checks if a specified user is a member of a given group.
#
# SYNOPSIS
#   is_user_in_group username group_name
#
# DESCRIPTION
#   Determines whether a specified user belongs to a specified group, allowing
#   scripts to perform group-based permission checks or conditional operations.
#
# USAGE EXAMPLE
#   if is_user_in_group "john_doe" "sudo"; then
#     echo "John Doe is in the sudo group."
#   fi
#
# EXIT STATUS
#   0 - User is a member of the group.
#   1 - User is not a member of the group or function was called with missing arguments.
#
###############################################################################
function is_user_in_group {

  # Check dependencies
  local DEPENDENCIES="getent grep"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Get arguments
  local USERNAME="${1}"
  local GROUP="${2}"

  # Check arguments are not empty
  [ -z "${USERNAME}" ] && return 1
  [ -z "${GROUP}" ] && return 1

  # Check if user is in group
  if getent group "${GROUP}" | grep --quiet "\b${USERNAME}\b"; then
      # Yes, user is in group
      return 0
  else
      return 1
  fi
}
export -f is_user_in_group

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: USER / GROUPS
#
# NAME
#   ppid_command_get - Retrieves the command line of the parent process.
#
# SYNOPSIS
#   ppid_command_get
#
# DESCRIPTION
#   Extracts and prints the command line used to start the current process's
#   parent. This can be useful for debugging or for scripts that need to
#   behave differently based on how they were invoked.
#
# USAGE EXAMPLE
#   # Get the parent process command
#   PARENT_CMD=$(ppid_command_get)
#   echo "The parent process command is: ${PARENT_CMD}"
#
#   # Check if your parent process is nodejs
#   if [ $( ppid_command_get | grep --text -c node ) -gt "0" ]
#
# EXIT STATUS
#   There is no specific exit status; the command line is printed to standard output.
#
###############################################################################
function ppid_command_get {

    # Check dependencies
    local DEPENDENCIES="cat"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    local PPID_CMD=$( cat /proc/${PPID}/cmdline )
    echo "${PPID_CMD}"
}
export -f ppid_command_get

###############################################################################
# CATEGORY
#   UTILITY FUNCTIONS: USER / GROUPS
#
# NAME
#   user_exists - Checks if a specified user exists on the system.
#
# SYNOPSIS
#   user_exists username
#
# DESCRIPTION
#   Verifies the existence of a user account on the system. This is essential for
#   scripts that need to validate user information or configure user-specific settings.
#
# DEPENDENCIES
#   Depends on 'getent' command; may not be available on all operating systems.
#
# USAGE EXAMPLE
#   if user_exists "john_doe"; then
#     echo "User john_doe exists."
#   else
#     echo "User john_doe does not exist."
#   fi
#
# EXIT STATUS
#   0 - User exists.
#   1 - User does not exist or function was called without arguments.
#
###############################################################################
function user_exists {

    # Check dependencies
    local DEPENDENCIES="getent"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    # TODO: OSX doesn't have getent. Find Equivalent
    if [ -z "$(getent passwd ${1})" ]; then
        return 1 # User does not exist
    else
        return 0 # User exists
    fi
}
export -f user_exists

### END UTILITY FUNCTIONS: USER / GROUPS



### BEGIN DISCOVER FUNCTIONS

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   discover_environment - Discovers and sets key environmental variables.
#
# SYNOPSIS
#   discover_environment
#
# DESCRIPTION
#   Performs discovery and initialization of critical environmental variables such
#   as FF_AGENT_URI, FF_AGENT_FQDN, FF_CONTENT_URL, NAMESPACE, and ORGANIZATION. Ensures
#   the agent is correctly configured with essential information for its operation.
#
# DEPENDENCIES
#   Dependent on the successful setting of the FF_CONTENT_URL environment variable.
#
# USAGE EXAMPLE
#   discover_environment || abort "Failed to discover_environment";
#
# EXIT STATUS
#   0 - Success, environment discovered and initialized.
#   1 - Failure, unable to fully discover or initialize the environment.
#
###############################################################################
function discover_environment {

  # Check dependencies
  local DEPENDENCIES="ff_agent_home_get_best ff_agent_get_best_ff_agent_uri ff_agent_get_best_ff_agent_uuid ff_agent_get_best_ff_agent_fqdn ff_agent_get_best_ff_content_url abort"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  ######################################################################
  # Choose user, agent home and make sure agent home folder exists
  #
  # Choose proper user to run as create "ff_agent" folder (known as ${FF_AGENT_HOME}).
  # The proper user is not root but user with sudo that can install packages.
  # We need to ff_agent_home_get_best before we can set/get secrets.
  # This sets some of environment variables: FF_AGENT_USERNAME, FF_AGENT_HOME.
  # Also creates FF_AGENT_HOME directory.
  # Baseline installer must set the following environment variables:
  #  [x] FF_AGENT_HOME      (see ff_agent_home_get_best())
  #  [x] FF_AGENT_UUID (see ff_agent_get_best_ff_agent_uuid())
  #  [x] FF_AGENT_URI (see ff_agent_get_best_ff_agent_uri())
  #  [x] FF_AGENT_USER_HOME (see ff_agent_home_get_best())
  #  [x] FF_AGENT_USERNAME  (see ff_agent_home_get_best())
  #  [x] FF_CONTENT_URL (see ff_agent_get_best_ff_content_url())
  #  [x] FF_AGENT_FQDN (see ff_agent_get_best_ff_agent_fqdn())
  #  [x] N_PREFIX (see install_n())
  #  [x] NAMESPACE (see ff_agent_get_best_namespace())
  #  [x] ORGANIZATION (see ff_agent_get_best_organization())
  #  [x] TERM  (see terminal_initialize())
  #
  # Preserving a set of other discussed environment values to add in future:
  #  FF_API_TOKEN
  #  FF_PROTOCOL
  #  FF_PROXY_HOST
  #  FF_PROXY_PASSWORD
  #  FF_PROXY_PORT
  #  FF_PROXY_PROTOCOL
  #  FF_PROXY_USERNAME
  #
  ff_agent_home_get_best || { abort "Failed to ff_agent_home_get_best"; }
  assert_ff_agent_home_exists || { abort "Failed to assert_ff_agent_home_exists"; }

  # Similarly for FF_AGENT_UUID
  FF_AGENT_UUID=$( ff_agent_get_best_ff_agent_uuid )     || { abort "Failed to ff_agent_get_best_ff_agent_uuid"; }
  secret_set ff_agent_uuid "${FF_AGENT_UUID}"
  export FF_AGENT_UUID

  # Similarly for FF_AGENT_URI
  FF_AGENT_URI=$( ff_agent_get_best_ff_agent_uri )     || { abort "Failed to ff_agent_get_best_ff_agent_uri"; }
  secret_set ff_agent_uri "${FF_AGENT_URI}"
  export FF_AGENT_URI

  # Get best values, check errors, export and secret_set().
  FF_CONTENT_URL=$( ff_agent_get_best_ff_content_url ) || { abort "Failed to ff_agent_get_best_ff_content_url"; }
  secret_set ff_content_url "${FF_CONTENT_URL}"
  export FF_CONTENT_URL

  FF_AGENT_FQDN=$( ff_agent_get_best_ff_agent_fqdn )               || { abort "Failed to ff_agent_get_best_ff_agent_fqdn"; }
  secret_set ff_agent_fqdn "${FF_AGENT_FQDN}"
  export FF_AGENT_FQDN

  # N_PREFIX is set in install_n() and added to ${FF_AGENT_HOME}/.profile

  # Similarly for best NAMESPACE
  NAMESPACE=$( ff_agent_get_best_namespace ) || { abort "Failed to ff_agent_get_best_namespace"; }
  secret_set namespace "${NAMESPACE}"
  export NAMESPACE

  # Similarly for best ORGANIZATION
  ORGANIZATION=$( ff_agent_get_best_organization ) || { abort "Failed to ff_agent_get_best_organization"; }
  secret_set organization "${ORGANIZATION}"
  export ORGANIZATION
}
export -f discover_environment

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   discover_optional_environment_variable - Discovers or defaults an optional environment variable.
#
# SYNOPSIS
#   discover_optional_environment_variable variable_name [default_value]
#
# DESCRIPTION
#   Attempts to discover an optional environment variable and set it if not already defined.
#   If the variable is undefined and a default value is provided, the variable is set to this
#   default value. If no default is provided, the variable remains unset.
#
# DEPENDENCIES
#   Requires 'tr' to be installed on the system.
#
# USAGE EXAMPLE
#   discover_optional_environment_variable "VARIABLE_NAME" "443" || { error "Failed to set VARIABLE_NAME"; return 1; }
#
# EXIT STATUS
#   0 - Success, variable discovered or set to default.
#   1 - Failure, unable to process the variable, got empty variable name argument, dependency 'tr' not installed'.
#
# SEE ALSO
#   discover_required_environment_variable
#
###############################################################################
function discover_optional_environment_variable {

  # Check dependencies
  local DEPENDENCIES="error tr secret_get"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Get arguments
  local NAME="${1}"
  local DEFAULT_VALUE="${2}"

  # Check inputs: NAME can be empty
  [ -z "${NAME}" ] && { return 1; }

  # Check if such environment already defined
  if [[ -v "${NAME}" ]]; then
      # Variable '${NAME}' is already defined (has value: '${!NAME}').
      # Make sure to export it, so if it was just "shell variable"
      # it becomes "environment variable", thus available even for child processes.
      export "${NAME}"="${!NAME}"
      return 0
  fi

  # Try to get value by "secret_get()"
  local NAME_LOWERCASE="$( echo "${NAME}" | tr '[:upper:]' '[:lower:]' )"
  local RESTORED_VALUE=$( secret_get "${NAME_LOWERCASE}" 2> /dev/null ) # Suppress error: secret_get failed_to_find_secret_value
  if [ -n "${RESTORED_VALUE}" ]; then
      # Got non-empty value from secrets, use it to export variable
      export "${NAME}"="${RESTORED_VALUE}"
      return 0
  fi

  # Variable not yet defined, define it using default value
  if [ -n "${DEFAULT_VALUE}" ]; then
      export "${NAME}"="${DEFAULT_VALUE}"
      return 0
  fi

  # Case: can't find variable value neither from "secret_get()" nor from "DEFAULT_VALUE".
  # Not an error, but the variable remains unset
  return 0
}
export -f discover_optional_environment_variable

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   discover_os - Identifies the operating system.
#
# SYNOPSIS
#   discover_os
#
# DESCRIPTION
#   Determines the family of the operating system (e.g., linux, macos, windows)
#   using the 'OSTYPE' variable or 'uname' command as fallback.
#
# USAGE EXAMPLE
#   OS_FAMILY=$(discover_os)
#   echo "Operating system family: ${OS_FAMILY}"
#
# EXIT STATUS
#   Echoes the identified operating system family or word "unknown" if it was not identified.
#
###############################################################################
function discover_os {

    local OS_FAMILY="unknown"

    # Detect the platform based on "OSTYPE" variable. E.g. on a mac it might be 'darwin22.1.0'
    case "${OSTYPE}" in
    darwin*)  OS_FAMILY="macos" ;;
    linux*)   OS_FAMILY="linux" ;;
    linux-gnu*)   OS_FAMILY="linux" ;;
    bsd*)     OS_FAMILY="bsd" ;;
    msys*)    OS_FAMILY="windows" ;;
    cygwin*)  OS_FAMILY="windows" ;;
    *)        OS_FAMILY="unknown" ;;  # Failed to id OS, this is not an error yet, we have 2nd attpempt (see below).
    esac

    # If OS_FAMILY still not set, try to detect the platform based on "uname" output
    if [ "${OS_FAMILY}" == "unknown" ]; then
        OS=$( uname )
        ## If the uname command fails, we don't know the OS, so we set it to unknown, which will work with the case below.
        [[ $? == 0 ]] || { OS='unknown'; }

        case ${OS} in
        'Linux') OS_FAMILY='linux' ;;
        'FreeBSD') OS_FAMILY='bsd' ;;
        'WindowsNT') OS_FAMILY='windows' ;;
        'Darwin')  OS_FAMILY='macos' ;;
        #'AIX') OS_FAMILY='aix' ;;
        *) OS_FAMILY='unknown';;
        esac
    fi

    echo "${OS_FAMILY}"
}
export -f discover_os

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   discover_required_environment_variable - Ensures a required environment variable is set.
#
# SYNOPSIS
#   discover_required_environment_variable variable_name [default_value]
#
# DESCRIPTION
#   Ensures that a required environment variable is set, either from the existing
#   environment, by discovering it, or using a default value. Errors out if unable
#   to set.
#
# USAGE EXAMPLE
#   discover_required_environment_variable "FF_API_TOKEN" || {
#     error "FF_API_TOKEN is required but not set";
#   }
#
# EXIT STATUS
#   0 - Success, variable set.
#   1 - Failure, variable not set.
#
# SEE ALSO
#   discover_optional_environment_variable
#
###############################################################################
function discover_required_environment_variable {

  # Check dependencies
  local DEPENDENCIES="error discover_optional_environment_variable"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Get arguments
  local NAME="${1}"
  local DEFAULT_VALUE="${2}"

  # Check inputs: NAME can not be empty
  [ -n "${NAME}" ] || { error "${FUNCNAME[0]}" "Missing required argument 'NAME'"; return 1; }

  # Try to discover
  discover_optional_environment_variable "${NAME}" "${DEFAULT_VALUE}"

  # Check: must be discovered, otherwise error out
  if [[ ! -v "${NAME}" ]]; then
      error "Variable '${NAME}' is not defined, but required."
      return 1
  fi
}
export -f discover_required_environment_variable

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   epoch_ms_get - Gets the current time in milliseconds since the Unix epoch.
#
# SYNOPSIS
#   epoch_ms_get
#
# DESCRIPTION
#   Returns the current Unix timestamp in milliseconds. This is useful for
#   operations that require a high-resolution time stamp. Echoes the current
#   Unix epoch time in milliseconds
#
# DEPENDENCIES
#   Requires the 'date' command with GNU extensions. Might not work on systems
#   without GNU date (e.g., macOS without gdate).
#
# USAGE EXAMPLE
#   EPOCH_MS=$(epoch_ms_get) || { error "epoch_ms_get() failed"; return 1; }
#   echo "Current epoch in ms: ${EPOCH_MS}"
#
# TODO
#   Make this compatible with Darwin (MACOS) where date works differently.
#   For details on "date" command on Linux vs Darwin see discussion:
#   https://stackoverflow.com/questions/9804966/date-command-does-not-follow-linux-specifications-mac-os-x-lion
#
###############################################################################
function epoch_ms_get {

  # Check dependencies
  local DEPENDENCIES="date cut"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  echo "$( date +%s%N | cut -b1-13 )"  # https://serverfault.com/a/151112/413686>
}
export -f epoch_ms_get

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   ff_agent_get_best_ff_agent_uri - Determines the best FF_AGENT_URI value.
#
# SYNOPSIS
#   ff_agent_get_best_ff_agent_uri
#
# DESCRIPTION
#   Attempts to discover or generate the best FF_AGENT_URI value. If the environment
#   variable FF_AGENT_URI is not set, a new URI is generated using a UUID. The result
#   is either taken from the environment, discovered through secrets, or generated anew.
#
# DEPENDENCIES
#   discover_optional_environment_variable, error, ensure_variable_not_empty.
#
# USAGE EXAMPLE
#   FF_AGENT_URI=$( ff_agent_get_best_ff_agent_uri ) || { state_set "${FUNCNAME[0]}" "Failed to ff_agent_get_best_ff_agent_uri"; return 1; }
#
# EXIT STATUS
#   0 - Success, FF_AGENT_URI chosen and printed to standard output.
#   1 - Failure, unable to determine FF_AGENT_URI.
#
###############################################################################
function ff_agent_get_best_ff_agent_uri {

  # Check dependencies
  local DEPENDENCIES="discover_optional_environment_variable error ensure_variable_not_empty"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Try to get FF_AGENT_URI from environment or by secret_get()
  discover_optional_environment_variable "FF_AGENT_URI" || { error "${FUNCNAME[0]}" "Failed to discover optional environment variable FF_AGENT_URI"; return 1; }

  # Check if variable already set. If not set - generate new value
  if [ -z "${FF_AGENT_URI}" ]; then
      # Generate new uuid, check errors, export new value
      local UUID
      UUID="$( ff_agent_get_best_ff_agent_uuid )" || { error "${FUNCNAME[0]}" "Failed to ff_agent_get_best_ff_agent_uuid"; return 1; }
      FF_AGENT_URI="/agent/agent_uuid/${UUID}"
  fi

  # At this point we must have not empty FF_AGENT_URI value.
  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'FF_AGENT_URI' || { error "${FUNCNAME[0]}" "error_ensure_variable_not_empty_ff_agent_uri"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${FF_AGENT_URI}"
}
export -f ff_agent_get_best_ff_agent_uri

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   ff_agent_get_best_ff_agent_uuid - Determines the best FF_AGENT_UUID value.
#
# SYNOPSIS
#   ff_agent_get_best_ff_agent_uuid
#
# DESCRIPTION
#   Attempts to discover or generate the best FF_AGENT_UUID value. If the environment
#   variable FF_AGENT_UUID is not set, a new UUID is generated using ff_uuid. The result
#   is either taken from the environment, discovered through secrets, or generated anew.
#
# DEPENDENCIES
#   discover_optional_environment_variable, ff_uuid, error, ensure_variable_not_empty.
#
# USAGE EXAMPLE
#   FF_AGENT_UUID=$( ff_agent_get_best_ff_agent_uuid ) || { state_set "${FUNCNAME[0]}" "Failed to ff_agent_get_best_ff_agent_uuid"; return 1; }
#
# EXIT STATUS
#   0 - Success, FF_AGENT_UUID chosen and printed to standard output.
#   1 - Failure, unable to determine FF_AGENT_UUID.
#
###############################################################################
function ff_agent_get_best_ff_agent_uuid {

  # Check dependencies
  local DEPENDENCIES="discover_optional_environment_variable ff_uuid error ensure_variable_not_empty"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Try to get FF_AGENT_UUID from environment or by secret_get()
  discover_optional_environment_variable "FF_AGENT_UUID" || { error "${FUNCNAME[0]}" "failed to discover optional environment variable FF_AGENT_UUID"; return 1; }

  # Check if variable already set. If not set - generate new uuid
  if [ -z "${FF_AGENT_UUID}" ]; then
      # Generate new FF_AGENT_UUID, check errors, export new value
      FF_AGENT_UUID="$( ff_uuid )" || { error "${FUNCNAME[0]}" "failed to generate new uuid"; return 1; }
  fi

  # At this point we must have not empty FF_AGENT_UUID value.
  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'FF_AGENT_UUID' || { error "${FUNCNAME[0]}" "error_ensure_variable_not_empty_ff_agent_uuid"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${FF_AGENT_UUID}"
}
export -f ff_agent_get_best_ff_agent_uuid

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   ff_agent_get_best_ff_content_url - Determines the best FF_CONTENT_URL value.
#
# SYNOPSIS
#   ff_agent_get_best_ff_content_url
#
# DESCRIPTION
#   Chooses the best FF_CONTENT_URL value by trying to retrieve it from the environment
#   or adjusting it for proper usage. This is important for ensuring that content URLs
#   are correctly formatted and accessible.
#
# USAGE EXAMPLE
#   FF_CONTENT_URL=$( ff_agent_get_best_ff_content_url ) || { state_set "${FUNCNAME[0]}" "Failed to ff_agent_get_best_ff_content_url"; return 1; }
#
# EXIT STATUS
#   0 - Success, FF_CONTENT_URL chosen and printed to standard output.
#   1 - Failure, unable to determine FF_CONTENT_URL.
#
###############################################################################
function ff_agent_get_best_ff_content_url {

  # Check dependencies
  local DEPENDENCIES="discover_optional_environment_variable trim_slash error ensure_variable_not_empty"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Try to get FF_CONTENT_URL from environment or by secret_get()
  discover_optional_environment_variable "FF_CONTENT_URL" || { error "${FUNCNAME[0]}" "Failed to discover_optional_environment_variable"; return 1; }

  # Remove trailing slash from FF_CONTENT_URL, so it works correctly when we concatenate
  # FF_CONTENT_URL with other path components (e.g.: ${}/subfolder/file.txt)
  # Note: its save to call trim_slash() even if FF_CONTENT_URL is empty at this step.
  FF_CONTENT_URL="$( trim_slash "${FF_CONTENT_URL}" )" || { error "${FUNCNAME[0]}" "error_trim_slash_from_ff_content_url"; return 1; }

  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'FF_CONTENT_URL' || { error "${FUNCNAME[0]}" "error_ensure_variable_not_empty_ff_content_url"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${FF_CONTENT_URL}"
}
export -f ff_agent_get_best_ff_content_url

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   ff_agent_get_best_ff_agent_fqdn - Determines the best FF_AGENT_FQDN value.
#
# SYNOPSIS
#   ff_agent_get_best_ff_agent_fqdn
#
# DESCRIPTION
#   Chooses the best FF_AGENT_FQDN value by trying to retrieve it from the environment
#   or using the hostname command. This ensures that the FF_AGENT_FQDN value accurately
#   reflects the host's identity within the system or network.
#
# USAGE EXAMPLE
#   UPLOAD_TO=$( ff_agent_get_best_ff_agent_fqdn ) || { state_set "${FUNCNAME[0]}" "Failed to ff_agent_get_best_ff_agent_fqdn"; return 1; }
#
# EXIT STATUS
#   0 - Success, FF_AGENT_FQDN chosen and printed to standard output.
#   1 - Failure, unable to determine FF_AGENT_FQDN.
#
###############################################################################
function ff_agent_get_best_ff_agent_fqdn {

  # Check dependencies
  local DEPENDENCIES="discover_optional_environment_variable error ensure_variable_not_empty hostname"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Try to get FF_AGENT_FQDN from environment or by secret_get()
  discover_optional_environment_variable "FF_AGENT_FQDN" || { error "${FUNCNAME[0]}" "Failed to discover_optional_environment_variable_ff_agent_fqdn"; return 1; } # Note: FF_AGENT_FQDN: FF_AGENT_FQDN will be set to legacy portal hostname if this is a portal.

  # Check if variable already set. If not try to get it's value by command 'hostname --fqdn'
  [ -z "${FF_AGENT_FQDN}" ] && { FF_AGENT_FQDN="$( hostname --fqdn )"; }

  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'FF_AGENT_FQDN' || { error "${FUNCNAME[0]}" "error_ensure_variable_not_empty_ff_agent_fqdn"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${FF_AGENT_FQDN}"
}
export -f ff_agent_get_best_ff_agent_fqdn

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   ff_agent_get_best_namespace - Determines the best NAMESPACE value.
#
# SYNOPSIS
#   ff_agent_get_best_namespace
#
# DESCRIPTION
#   Chooses the best NAMESPACE value by trying to retrieve it from the environment
#   or defaulting to a predefined namespace. This ensures that the agent operates
#   within the correct namespace context.
#
# USAGE EXAMPLE
#   NAMESPACE=$(ff_agent_get_best_namespace) || { state_set "${FUNCNAME[0]}" "Failed to ff_agent_get_best_namespace"; return 1; }
#
# EXIT STATUS
#   0 - Success, NAMESPACE chosen and printed to standard output.
#   1 - Failure, unable to determine NAMESPACE.
#
###############################################################################
function ff_agent_get_best_namespace {

  # Check dependencies
  local DEPENDENCIES="discover_optional_environment_variable error ensure_variable_not_empty"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Try to get value from environment or by secret_get()
  discover_optional_environment_variable "NAMESPACE" || { error "${FUNCNAME[0]}" "Failed to discover_optional_environment_variable_namespace"; return 1; }

  # Check if variable already set. If not set it to our default "system.local" namespace: '00000000-0000-0000-0000-000000000000'.
  [ -z "${NAMESPACE}" ] && { NAMESPACE='00000000-0000-0000-0000-000000000000'; }

  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'NAMESPACE' || { error "${FUNCNAME[0]}" "error_ensure_variable_not_empty_namespace"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${NAMESPACE}"
}
export -f ff_agent_get_best_namespace

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   ff_agent_get_best_organization - Determines the best ORGANIZATION value.
#
# SYNOPSIS
#   ff_agent_get_best_organization
#
# DESCRIPTION
#   Chooses the best ORGANIZATION value by trying to retrieve it from the environment
#   or defaulting to a predefined organization. This is crucial for ensuring that the
#   agent is associated with the correct organizational context.
#
# USAGE EXAMPLE
#   ORGANIZATION=$(ff_agent_get_best_organization) || {
#     state_set "${FUNCNAME[0]}" "Failed to ff_agent_get_best_organization"; return 1;
#   }
#
# EXIT STATUS
#   0 - Success, ORGANIZATION chosen and printed to standard output.
#   1 - Failure, unable to determine ORGANIZATION.
#
###############################################################################
function ff_agent_get_best_organization {

  # Check dependencies
  local DEPENDENCIES="discover_optional_environment_variable error ensure_variable_not_empty"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Try to get value from environment or by secret_get()
  discover_optional_environment_variable "ORGANIZATION" || { error "${FUNCNAME[0]}" "Failed to discover_optional_environment_variable_organization"; return 1; }

  # Check if variable already set. If not set it to our default organization "system.local"
  [ -z "${ORGANIZATION}" ] && { ORGANIZATION='system.local'; }

  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'ORGANIZATION' || { error "${FUNCNAME[0]}" "error_ensure_variable_not_empty_organization"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${ORGANIZATION}"
}
export -f ff_agent_get_best_organization

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   ff_uuid - Generates a unique UUID.
#
# SYNOPSIS
#   ff_uuid
#
# DESCRIPTION
#   Generates a universally unique identifier (UUID) using the uuidgen command.
#   This function is a utility to provide unique identifiers for various use cases
#   within the system.
#
# DEPENDENCIES
#   Requires the uuidgen command; attempts to install if not present.
#
#   NEW_UUID=$(ff_uuid) || {
#     state_set "${FUNCNAME[0]}" "Failed to ff_uuid"; return 1;
#   }
#
# EXIT STATUS
#   0 - Success, UUID generated and printed to standard output.
#   1 - Failure, unable to generate UUID.
#
###############################################################################
function ff_uuid {

  # Check dependencies
  local DEPENDENCIES="apt_update apt_install command_exists error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check dependency: "uuidgen" we need to make sure it is installed ('uuidgen' is part of 'uuid-runtime' package)
  if ! command_exists uuidgen >/dev/null; then

    # Try to install missing dependency
    apt_update >/dev/null
    [ $? -ne 0 ] || { error "uuidgen is missing and failed to apt_update"; return 1; }

    apt_install uuid-runtime >/dev/null  # Note: we mute output of apt-install otherwise it will be mixed into the ff_uuid() function result!
    [ $? -ne 0 ] || { error "uuidgen is missing and failed to apt_install it"; return 1; }

    # Check again
    if ! command_exists uuidgen >/dev/null; then
      # Still failing to find uuidgen, return error
      return 1
    fi
  fi

  # Generate uuid and return it's exit code as a return code
  uuidgen
}
export -f ff_uuid

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   hardware_architecture_get - Retrieves the hardware architecture.
#
# SYNOPSIS
#   hardware_architecture_get
#
# DESCRIPTION
#   Uses 'dpkg' to print the architecture of the hardware, such as amd64 or arm64.
#   This function is primarily useful in Debian-based distributions. Echoes the hardware architecture.
#
# DEPENDENCIES
#   Requires 'dpkg' command, limiting its use to Debian-based systems.
#
# USAGE EXAMPLE
#   ARCH=$(hardware_architecture_get)
#   echo "Hardware architecture: ${ARCH}"
#
###############################################################################
function hardware_architecture_get {

  # Check dependencies
  local DEPENDENCIES="dpkg"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  dpkg --print-architecture
}
export -f hardware_architecture_get

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   lsb_codename_get - Retrieves the LSB (Linux Standard Base) codename.
#
# SYNOPSIS
#   lsb_codename_get
#
# DESCRIPTION
#   Returns the codename for the current Linux distribution, such as 'focal' for Ubuntu 20.04,
#   using the 'lsb_release' command. Echoes the LSB codename of the Linux distribution.
#
# DEPENDENCIES
#   Requires 'lsb_release' command, which might not be present in minimal installations.
#
# USAGE EXAMPLE
#   CODENAME=$(lsb_codename_get)
#   echo "LSB codename: ${CODENAME}"
#
###############################################################################
function lsb_codename_get {

  # Check dependencies
  local DEPENDENCIES="lsb_release command_exists error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # --codename Display the code name of the currently installed distribution. (example: focal or jammy)
  command_exists >/dev/null lsb_release && lsb_release --short --codename
}
export -f lsb_codename_get

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   lsb_id_get - Retrieves the LSB (Linux Standard Base) ID.
#
# SYNOPSIS
#   lsb_id_get
#
# DESCRIPTION
#   Returns the ID for the current Linux distribution, such as 'Ubuntu',
#   using the 'lsb_release' command. This ID represents the distributor's ID.
#   Echoes the LSB ID of the Linux distribution.
#
# DEPENDENCIES
#   Requires 'lsb_release' command, which might not be included in minimal installations.
#
# USAGE EXAMPLE
#   LSB_ID=$(lsb_id_get)
#   echo "LSB ID: ${LSB_ID}"
#
###############################################################################
# Category: environment
# Utility function - Get release - e.g. 16.04, 18.04, 20.04
function lsb_id_get {

  # Check dependencies
  local DEPENDENCIES="lsb_release command_exists error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  for DEPENDENCY in basename lsb_release
  do
    command_exists "${DEPENDENCY}" >/dev/null || { error "${FUNCNAME[0]} error dependency ${DEPENDENCY} not found."; return 1; }
  done

  command_exists >/dev/null lsb_release && lsb_release --short --id
}
export -f lsb_id_get

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   lsb_id_get_downcase - Retrieves and converts the LSB ID to lowercase.
#
# SYNOPSIS
#   lsb_id_get_downcase
#
# DESCRIPTION
#   Fetches the distributor's ID from the Linux Standard Base information and
#   converts it to lowercase, facilitating case-insensitive comparisons.
#   Echoes the lowercase LSB ID of the Linux distribution.
#
# DEPENDENCIES
#   Depends on 'lsb_release' and 'tr' commands. 'lsb_release' might not be present in all distributions.
#
# USAGE EXAMPLE
#   LSB_ID_LOWERCASE=$(lsb_id_get_downcase)
#   echo "LSB ID, lowercase: ${LSB_ID_LOWERCASE}"
#
###############################################################################
function lsb_id_get_downcase {

  # Check dependencies
  local DEPENDENCIES="lsb_release tr command_exists error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # --id Display the distributor's ID. (example: Ubuntu)
  command_exists >/dev/null lsb_id_get && lsb_id_get | tr '[:upper:]' '[:lower:]'
}
export -f lsb_id_get_downcase

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   lsb_release_get - Retrieves the LSB release version.
#
# SYNOPSIS
#   lsb_release_get
#
# DESCRIPTION
#   Returns the release version of the current Linux distribution as provided by the LSB,
#   such as '20.04' for Ubuntu 20.04 Focal Fossa. Echoes the LSB release version of the Linux distribution.
#
# DEPENDENCIES
#   Requires 'lsb_release' command, which might not be included in minimal or non-Debian based installations.
#
# USAGE EXAMPLE
#   LSB_RELEASE=$(lsb_release_get)
#   echo "LSB release version: ${LSB_RELEASE}"
#
###############################################################################
function lsb_release_get {

  # Check dependencies
  local DEPENDENCIES="lsb_release command_exists error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # --release Display the release number of the currently installed  distribution. (example: 22.04)
  command_exists >/dev/null lsb_release && lsb_release --short --release
}
export -f lsb_release_get

###############################################################################
# CATEGORY
#   DISCOVERY
#
# NAME
#   os_name_get - Determines the operating system name.
#
# SYNOPSIS
#   os_name_get
#
# DESCRIPTION
#   Extracts and returns the operating system's name in lowercase, such as 'linux' or 'darwin'
#   for macOS, based on the output of 'uname'. Echoes the name of the operating system.
#
# DEPENDENCIES
#   Depends on 'uname' and 'tr' commands.
#
# USAGE EXAMPLE
#   OS_NAME=$(os_name_get)
#   echo "Operating system name: ${OS_NAME}"
#
###############################################################################
function os_name_get {

  # Check dependencies
  local DEPENDENCIES="uname tr"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  local OS_NAME="$( basename $( uname --operating-system ) | tr '[:upper:]' '[:lower:]' )"
  if [ -z "${OS_NAME}" ]; then
    # Error, got empty string
    return 1
  fi

  echo "${OS_NAME}"
}
export -f os_name_get

### END DISCOVER FUNCTIONS


### BEGIN SET ENVIRONMENT FUNCTIONS

###############################################################################
# CATEGORY
#   SET ENVIRONMENT
#
# NAME
#   assert_ff_agent_home_exists - Ensures the FF_AGENT_HOME directory exists.
#
# SYNOPSIS
#   assert_ff_agent_home_exists
#
# DESCRIPTION
#   Confirms the existence of the directory specified by the FF_AGENT_HOME
#   environment variable. It checks for the required environment variable
#   FF_AGENT_HOME and verifies that the corresponding directory exists in the
#   filesystem. If the directory does not exist, the function will report an
#   error and return a nonzero code.
#
# DEPENDENCIES
#   Requires the following functions to be defined and accessible within the
#   environment: 'state_set', 'ensure_variable_not_empty', and 'error'.
#   The function 'check_dependencies' is used to verify the presence of these
#   dependencies before proceeding with the main operations.
#
# USAGE EXAMPLE
#   assert_ff_agent_home_exists || { abort "FF_AGENT_HOME directory does not exist."; }
#
# EXIT STATUS
#   0 - on success, indicating the FF_AGENT_HOME directory exists.
#   1 - on failure, indicating either the FF_AGENT_HOME variable is unset or the
#       specified directory does not exist.
#
###############################################################################

function assert_ff_agent_home_exists {

  # Check dependencies
  local DEPENDENCIES="state_set ensure_variable_not_empty error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  state_set "${FUNCNAME[0]}" 'started'

  # Define required variables
  local REQUIRED_VARIABLES=(
    FF_AGENT_HOME
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      error "Failed to ensure required environment variable is not empty: '${VARIABLE_NAME,,}'"
      state_set "${FUNCNAME[0]}" "error_ensure_variable_not_empty"
      return 1
    }
  done

  # Make sure ${FF_AGENT_HOME} folder exist
  [ -d "${FF_AGENT_HOME}" ] || { state_set "${FUNCNAME[0]}" "error_ff_agent_home_does_not_exist"; return 1; }
  state_set "${FUNCNAME[0]}" 'success'
}
export -f assert_ff_agent_home_exists

###############################################################################
# CATEGORY
#   SET ENVIRONMENT
#
# NAME
#   check_environment_variables_are_set - Checks if all expected environment variables are set.
#
# SYNOPSIS
#   check_environment_variables_are_set
#
# DESCRIPTION
#   Verifies that all required environment variables, such as FF_AGENT_USERNAME,
#   FF_AGENT_HOME, FF_AGENT_URI, FF_AGENT_FQDN, FF_CONTENT_URL, N_PREFIX, and TERM, are set.
#   Reports an error for any unset variable.
#
# DEPENDENCIES
#   Requires 'tr' to be installed on the system for error handling purposes.
#
# USAGE EXAMPLE
#   check_environment_variables_are_set || abort "One or more environment variables are not set.";
#
# EXIT STATUS
#   0 - on success, indicating all required environment variables are set.
#   1 - on failure, indicating one or more required environment variables are unset.
#
###############################################################################
function check_environment_variables_are_set {

  # Check dependencies
  local DEPENDENCIES="ensure_variable_not_empty tr error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Define list of required environment variables (must be not empty)
  local ALL_EXPECTED_ENVRIONMENT_VARIABLES=(
    FF_AGENT_USERNAME
    FF_AGENT_HOME
    FF_AGENT_URI
    FF_AGENT_FQDN
    FF_CONTENT_URL
    N_PREFIX
    TERM
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${ALL_EXPECTED_ENVRIONMENT_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      error "${FUNCNAME[0]}" "Expected variable is not set: '${VARIABLE_NAME}'"
      return 1
    }
  done
}
export -f check_environment_variables_are_set

###############################################################################
# CATEGORY
#   SET ENVIRONMENT
#
# NAME
#   check_nodejs_installation - Verifies the Node.js installation and version.
#
# SYNOPSIS
#   check_nodejs_installation
#
# DESCRIPTION
#   Checks if Node.js is installed at the expected path and version. It verifies
#   the installation directory is not under /usr, matches the expected version
#   against the actual version, and checks the npm installation.
#   Function sets state to indicate success or error code (because it is a complex multi-step function).
#
# USAGE EXAMPLE
#   check_nodejs_installation || abort "Node.js installation checks failed.";
#
# EXIT STATUS
#   0 - on success, indicating Node.js is correctly installed.
#   1 - on failure, indicating a problem with the Node.js installation.
#
###############################################################################
function check_nodejs_installation {

  # Check dependencies
  local DEPENDENCIES="state_set error nodejs_desired_version_get node command_exists"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  state_set "${FUNCNAME[0]}" 'started'

  local ERRORS_COUNT=0
  # Check nodejs is installed
  local WHICH_NODE="$( command_exists node )"
  if [ "${WHICH_NODE}" == "" ]; then
    # 'node' does not exist
    ERROR_CODE="error_check_nodejs_installation_nodejs_not_installed"
    state_set "${FUNCNAME[0]}" "${ERROR_CODE}"
    (( ERRORS_COUNT++ ))
  else
    # 'node' exists: run few more node-related checks
    # Check nodejs is not installed under /usr
    [[ "${WHICH_NODE}" =~ ^/usr/ ]] && {
      ERROR_CODE="error_check_nodejs_installation_wrong_installation_dir"
      state_set "${FUNCNAME[0]}" "${ERROR_CODE}"
      (( ERRORS_COUNT++ ))
    }

    # Get expected nodejs version
    local EXPECTED_VERSION="$( nodejs_desired_version_get )"
    [ -z "${EXPECTED_VERSION}" ] && {
      ERROR_CODE="failed_to_nodejs_desired_version_get"
      state_set "${FUNCNAME[0]}" "${ERROR_CODE}"
      (( ERRORS_COUNT++ ))
    }

    # Get actual nodejs version
    local ACTUAL_VERSION="$( node --version )"
    [ -z "${ACTUAL_VERSION}" ] && {
      ERROR_CODE="failed_to_get_actual_nodejs_version"
      state_set "${FUNCNAME[0]}" "${ERROR_CODE}"
      (( ERRORS_COUNT++ ))
    }

    # Compare expected vs actual nodejs versions
    if [ "${EXPECTED_VERSION}" != "${ACTUAL_VERSION}" ]; then
      # Version mismatch
      ERROR_CODE="error_mismatching_nodejs_versions"
      state_set "${FUNCNAME[0]}" "${ERROR_CODE}"
      (( ERRORS_COUNT++ ))
    fi
  fi

  # Check npm is installed
  WHICH_NPM=$( command_exists npm )
  [ "${WHICH_NPM}" != "" ] || {
    ERROR_CODE="error_check_npm_installation_nodejs_not_installed"
    state_set "${FUNCNAME[0]}" "${ERROR_CODE}"
    (( ERRORS_COUNT++ ))
  }

  # Check npm is not installed under /usr
  [[ "${WHICH_NPM}" =~ ^/usr/ ]] && {
    ERROR_CODE="error_check_npm_installation_wrong_installation_dir"
    state_set "${FUNCNAME[0]}" "${ERROR_CODE}"
    (( ERRORS_COUNT++ ))
  }

  # List of all the checks done with their statuses
  if [ ${ERRORS_COUNT} -gt 0 ]; then
    # We found errors
    state_set "${FUNCNAME[0]}" 'failed'
    return 1
  fi

  state_set "${FUNCNAME[0]}" 'success'
}
export -f check_nodejs_installation

###############################################################################
# CATEGORY
#   SET ENVIRONMENT
#
# NAME
#   secret_check_set_and_get - Tests the functionality of setting and getting a secret.
#
# SYNOPSIS
#   secret_check_set_and_get
#
# DESCRIPTION
#   Verifies the ability to set and retrieve a secret using secret_set and secret_get
#   functions, respectively. Function sets the secret as a time based value then retrieves
#   the value and checks that the retrieved value is within couple seconds range from the
#   expected value (this makes the check multithread safe).
#
# USAGE EXAMPLE
#   if ! secret_check_set_and_get; then
#     echo "Failed to set or get a secret.";
#     exit 1;
#   fi
#
# EXIT STATUS
#   0 - on success, indicating the secret was set and retrieved successfully.
#   1 - on failure, indicating an issue with setting or retrieving the secret.
#
###############################################################################
function secret_check_set_and_get {

  # Check dependencies
  local DEPENDENCIES="error secret_set secret_get date"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Define test state name
  SECRET_NAME="secret_check_set_and_get"

  # Lets use current epoch seconds as the value, so even if another process uses the same check
  # the stored value will be within a couple of seconds of the expected value.
  # If we use some exact random value it will fail for multiple process doing the same check.
  # Also if we use some const static value the check will be not fully valid (could work in the past, but now failing, which we
  # would fail to detect because the expected static value simplly exists from the past).
  EXPECTED_VALUE=$( date +%s ) || { error "${FUNCNAME[0]}" 'failed to generate test value'; return 1; }

  # Check generated EXPECTED_VALUE is not empty
  [ -n "${EXPECTED_VALUE}" ] || { error "${FUNCNAME[0]}" 'failed check: generated test value is blank'; return 1; }

  # Set the secret
  secret_set "${SECRET_NAME}" "${EXPECTED_VALUE}" || { error "${FUNCNAME[0]}" 'failed to secret_set'; return 1;}

  # Try to retrieve value
  local RETRIEVED_VALUE
  RETRIEVED_VALUE=$( secret_get "${SECRET_NAME}" ) || { error "${FUNCNAME[0]}" "failed to retrieve secret '${SECRET_NAME}'"; return 1; }

  # Compare retrieved and expected values
  local EPOCH_DELTA_S=$(( ${RETRIEVED_VALUE} - ${EXPECTED_VALUE} ))
  if [[ ${EPOCH_DELTA_S} -ge 0 ]] && [[ ${EPOCH_DELTA_S} -lt 5 ]]; then
    # Test passed: the retrieved value is within couple seconds of expected value
    return 0
  fi

  # Test failed, retrieved value is not within couple seconds of expected value
  error "${FUNCNAME[0]}" "error: retrieved value '${RETRIEVED_VALUE}' is not within couple seconds of the expected value '${EXPECTED_VALUE}'"
  return 1
}
export -f secret_check_set_and_get

###############################################################################
# CATEGORY
#   SET ENVIRONMENT
#
# NAME
#   current_user_get - Retrieves the current user name, avoiding reliance on the $USER variable.
#
# SYNOPSIS
#   current_user_get
#
# DESCRIPTION
#   A more reliable alternative to the ${USER} environment variable for obtaining the current
#   user's name. This function is particularly useful in environments like Docker, where $USER
#   might not be set. It attempts to use the 'whoami' command as a fallback.
#   Prints the current user's name to standard output.
#   For more details see discussion:
#   https://stackoverflow.com/questions/54411218/docker-why-isnt-user-environment-variable-set
#
# USAGE EXAMPLE
#   URRENT_USER="$(current_user_get)" || { error "Can not get current user"; return 1; }
#
# EXIT STATUS
#   0 - on success.
#   1 - on failure.
#
###############################################################################
function current_user_get {

  # Check dependencies
  local DEPENDENCIES="command_exists whoami error"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Check if environment variable USER is set, then use it.
  if [ -z "${USER}" ]; then
    # The USER environment variable is blank.
    # Try to get current username by 'whoami'
    USER="$( whoami )" || { error "${FUNCNAME[0]}" "ERROR whoami command failed"; return 1; }
    [ -n "${USER}" ] || { error "${FUNCNAME[0]}" "Failed to current_user_get"; return 1; }
  fi

  # Print username to standard output
  echo "${USER}"
}
export -f current_user_get

###############################################################################
# CATEGORY
#   SET ENVIRONMENT
#
# NAME
#   ff_agent_check_bin_is_in_the_path - Checks if FF_AGENT_BIN is in the system PATH.
#
# SYNOPSIS
#   ff_agent_check_bin_is_in_the_path
#
# DESCRIPTION
#   Verifies that the FF_AGENT_BIN directory is included in the system's PATH
#   environment variable, ensuring executables in that directory are accessible system-wide.
#
# USAGE EXAMPLE
#   if ! ff_agent_check_bin_is_in_the_path; then
#     echo "FF_AGENT_BIN is not in PATH.";
#     exit 1;
#   fi
#
# EXIT STATUS
#   0 - if FF_AGENT_BIN is in PATH.
#   1 - if FF_AGENT_BIN is not in PATH or if an error occurs.
#
###############################################################################
function ff_agent_check_bin_is_in_the_path {

  # Check dependencies
  local DEPENDENCIES="printenv grep"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Define FF_AGENT_BIN path
  local FF_AGENT_BIN="${FF_AGENT_HOME}/bin"

  # Check if FF_AGENT_BIN is in the PATH
  printenv PATH | grep --quiet "${FF_AGENT_BIN}" || {
    # Error - FF_AGENT_BIN is not in the PATH
    error "${FUNCNAME[0]}" "FF_AGENT_BIN is not in the PATH"
    return 1
  }
}
export -f ff_agent_check_bin_is_in_the_path

###############################################################################
# CATEGORY
#   SET ENVIRONMENT
#
# NAME
#   ff_agent_home_get_best - Determines the best FF_AGENT_HOME directory based on the current user.
#
# SYNOPSIS
#   ff_agent_home_get_best
#
# DESCRIPTION
#   Sets the FF_AGENT_USERNAME (example: ubuntu) and FF_AGENT_HOME (/home/ubuntu/ff_agent)
#   environment variables, aiming to avoid using the root user and preferring a user with
#   sudo privileges for better security. It ensures the FF_AGENT_HOME directory exists and
#   is appropriate for the user. It exports FF_AGENT_USERNAME and FF_AGENT_HOME.
#
# USAGE EXAMPLE
#   ff_agent_home_get_best || {
#     echo "Failed to determine the FF_AGENT_HOME.";
#     exit 1;
#   }
#
# EXIT STATUS
#   0 - on success. Exports FF_AGENT_USERNAME and FF_AGENT_HOME.
#   1 - on failure.
#
###############################################################################
function ff_agent_home_get_best {

    # Check dependencies
    local DEPENDENCIES="current_user_get home_directory_for_user_get error"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    # These exports are our "return values"
    # Note: we should not get value from subprocess and call 'export' on the same 1-line like this: "export SOMEVAR=$( some_function_call ) || { error "error details"; return 1; } "
    #       because export would hide actual exit call of the "some_function_call" and thus we'll miss an error!
    FF_AGENT_USERNAME="$(current_user_get)" || { error "terminal_error_failed_to_current_user_get"; return 1; }
    export FF_AGENT_USERNAME

    # Even if this function run by some other/not-chosen" user, the FF_AGENT_USER_HOME would point to the "right/choosen" home. Example: /home/ubuntu
    # Only when we run as ritgh/choosen user the FF_AGENT_USER_HOME and HOME have the same values.
    FF_AGENT_USER_HOME=$( home_directory_for_user_get "${FF_AGENT_USERNAME}" ) || { error "terminal_error_failed_to_get_agent_user_home"; return 1; }
    export FF_AGENT_USER_HOME

    local AGENT_DIR_NAME="ff_agent"
    export FF_AGENT_HOME="${FF_AGENT_USER_HOME}/${AGENT_DIR_NAME}"
}
export -f ff_agent_home_get_best

###############################################################################
# CATEGORY
#   SET ENVIRONMENT
#
# NAME
#   ff_api_get - Makes an HTTPS GET request to the specified FF API endpoint.
#
# SYNOPSIS
#   ff_api_get endpoint
#
# DESCRIPTION
#   Performs an HTTPS GET request to the FF_AGENT_FQDN using the provided endpoint. Requires
#   the following environment variables to be set:
#    - FF_AGENT_PORT
#    - FF_AGENT_API_USERNAME
#    - FF_AGENT_API_PASSWORD
#    - FF_AGENT_API_FQDN
#    - FF_AGENT_API_PORT
#
# It is used for interacting with the FF API securely.
#
# USAGE EXAMPLE
#   RESPONSE=$(ff_api_get "/admin/organizations") || { error "API request failed."; return 1; }
#
# EXIT STATUS
#   0 - on success. Echoes the API response to standard output.
#   Non-zero code - on failure.
#
###############################################################################
function ff_api_get {

    # Check dependencies
    local DEPENDENCIES="curl shopt ensure_variable_not_empty error"
    check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

    # Get argument
    CALL="${1}"

    # Check required arguments are not empty
    # Define required variables
    local REQUIRED_VARIABLES=(
      CALL
      FF_AGENT_API_USERNAME
      FF_AGENT_API_PASSWORD
      FF_AGENT_API_FQDN
    )

    # Check required environment variables are set
    for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
      ensure_variable_not_empty "${VARIABLE_NAME}" || {
        error "${FUNCNAME[0]}" "Failed to ensure required environment variable is not empty: '${VARIABLE_NAME,,}'"
        return 1
      }
    done

    # If FF_AGENT_API_PROTOCOL is not set, use "https"
    FF_AGENT_API_PROTOCOL="${FF_AGENT_API_PROTOCOL:-https}"
    export FF_AGENT_API_PROTOCOL

    # If FF_AGENT_API_PORT is not set, use "443"
    FF_AGENT_API_PORT="${FF_AGENT_API_PORT:-443}"
    export FF_AGENT_API_PORT

    # Run command, capture server response as ${RESULT} and curl exit code as ${STATUS}
    local RESULT
    RESULT=$( curl \
        --silent   \
        --retry 3    \
        --request POST \
        --connect-timeout 10 \
        --max-time 35  \
        --retry-delay 1 \
        --user "${FF_AGENT_API_USERNAME}:${FF_AGENT_API_PASSWORD}" \
        "${FF_AGENT_API_PROTOCOL}://${FF_AGENT_API_FQDN}:${FF_AGENT_API_PORT}${CALL}" \
    )
    local STATUS=${?}

    if [ "${STATUS}" != "0" ]; then
        return ${STATUS}
    fi

    # =========================================== case-insensitive matching begin ==============
    # Save the current state of nocasematch
    CURRENT_NOCASEMATCH=$(shopt -p nocasematch)

    # Enable case-insensitive matching
    shopt -s nocasematch

    if [[ ${RESULT} =~ (^cannot get) ]]; then
        # The string contains 'Cannot GET'
        # Restore the original nocasematch state before returning
        ${CURRENT_NOCASEMATCH}
        return 1
    else
        echo "The string does not contain 'Cannot GET'"
    fi

    # Restore the original nocasematch state
    ${CURRENT_NOCASEMATCH}
    # =========================================== case-insensitive matching end ==============

    if [[ ${RESULT} =~ (^.*"mime_type".+"rest/error") ]]; then
        return 1
    fi

    echo ${RESULT}
}
export -f ff_api_get

###############################################################################
# CATEGORY
#   SET ENVIRONMENT
#
# NAME
#   is_framework_api_defined - Checks if the framework API is properly defined in the environment.
#
# SYNOPSIS
#   is_framework_api_defined
#
# DESCRIPTION
#   Function checks if we have framework API defined by checking if all of the following is set:
#    - FF_AGENT_API_FQDN
#    - ( FF_AGENT_API_USERNAME and FF_AGENT_API_PASSWORD ) OR ( FF_AGENT_API_TOKEN )
#   Useful for conditional logic based on API availability.
#   Echoes to standard output 'true' if the API is defined, 'false' otherwise.
#
# USAGE EXAMPLE
#   if [ "$(is_framework_api_defined)" == "true" ]; then
#     echo "Framework API is defined.";
#   else
#     echo "Framework API is not defined.";
#   fi
#
# EXIT STATUS
#   0 - Success. The API is properly defined (i.e., all necessary variables are set).
#   1 - Faulure. The API is not properly defined (i.e., one or more necessary variables are missing).
#
###############################################################################
function is_framework_api_defined {

  # Print 'false' and return 1if FF_AGENT_API_FQDN not set
  [ -z "${FF_AGENT_API_FQDN}" ] && { echo 'false'; return 1; }

  # Print 'true' if both FF_AGENT_API_USERNAME and FF_AGENT_API_PASSWORD are set
  [ -n "${FF_AGENT_API_USERNAME}" ] && [ -n "${FF_AGENT_API_PASSWORD}" ] && { echo 'true'; return 0; }

  # Print 'true' if FF_AGENT_API_TOKEN is set
  [ -n "${FF_AGENT_API_TOKEN}" ] && { echo 'true'; return 0; }

  # Print 'false' in all other cases
  echo 'false'
  return 1
}
export -f is_framework_api_defined

###############################################################################
# CATEGORY
#   SET ENVIRONMENT
#
# NAME
#   nodejs_desired_version_get - Outputs the desired Node.js version for the environment.
#
# SYNOPSIS
#   nodejs_desired_version_get
#
# DESCRIPTION
#   Provides the version of Node.js that is desired to be installed on the system,
#   aiding in the installation and verification processes by defining a target version.
#   Echoes the expected Node.js version (e.g., 'v18.4.0') to standard output.
#
# USAGE EXAMPLE
#   DESIRED_VERSION=$(nodejs_desired_version_get)
#   echo "The desired Node.js version is ${DESIRED_VERSION}."
#
###############################################################################
function nodejs_desired_version_get {

  # Check dependencies
  local DEPENDENCIES="lsb_release_get"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  local RELEASE=$( lsb_release_get ) # Will give us the version of ubuntu.
  case "${RELEASE}" in
    18.*) echo 'v17'
    ;;
    20.*) echo 'v18.4.0'
    ;;
    21.*) echo 'v18.4.0'
    ;;
    22.*) echo "v20.5.1"
    ;;
    *) echo 'v18.4.0';;
  esac
}
export -f nodejs_desired_version_get

###############################################################################
# CATEGORY
#   SET ENVIRONMENT
#
# NAME
#   publish_message - Sends a JSON message to the FF_AGENT_API_FQDN.
#
# SYNOPSIS
#   echo '{"example": "data"}' | publish_message
#
# DESCRIPTION
#   Accepts a JSON payload through stdin and wraps it in a delivery message format
#   before POSTing it to the configured FF_AGENT_FQDN. Requires FF_AGENT_API_USERNAME, FF_AGENT_API_PASSWORD,
#   and FF_AGENT_FQDN to be set (check done by calling is_framework_api_defined()).
#
# DEPENDENCIES
#   Requires 'curl' to be installed on the system.
#
# USAGE EXAMPLE
#   echo '{"a": 1, "b": true}' | publish_message
#   cat  "/path/to/file.json"  | publish_message
#
# EXIT STATUS
#   0 - Success. The message was sent.
#   1 - Failure. The message was not sent. Check the error log.
#
###############################################################################
function publish_message {

  # Check dependencies
  local DEPENDENCIES="bash_echo_setting_get bash_echo_setting_set cat curl error ff_uuid log secret_get"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Preserve current bash echo settings and enable bash echo setting
  # Note: can't use state_set here otherwize will fall into recursive loop
  BASH_ECHO_SETTINGS=$( bash_echo_setting_get ) || { error "${FUNCNAME[0]}" "Failed to bash_echo_setting_get"; return 1; }

  bash_echo_off_set || { error "${FUNCNAME[0]}" "Failed to bash_echo_off_set"; return 1; }

  # Read piped json
  INPUT_JSON=`cat`

  # Check if API is defined (this will check for:
  #  - FF_AGENT_API_FQDN
  #  - (FF_AGENT_API_USERNAME, FF_AGENT_API_PASSWORD) or FF_AGENT_API_TOKEN
  if [ "$( is_framework_api_defined )" != "true" ]; then
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" "Framework API is not defined"
    return 1
  fi

  # If FF_AGENT_API_PROTOCOL is not set, use "https"
  FF_AGENT_API_PROTOCOL="${FF_AGENT_API_PROTOCOL:-https}"
  export FF_AGENT_API_PROTOCOL

  # If FF_AGENT_API_PORT is not set, use "443"
  FF_AGENT_API_PORT="${FF_AGENT_API_PORT:-443}"
  export FF_AGENT_API_PORT

  # Check inputs
  if [ "${INPUT_JSON}" == "" ]; then
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" "INPUT_JSON is missing"
    return 1
  fi

  local UUID="$( ff_uuid )"
  if [ "${UUID}" == "" ]; then
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" "failed to generate UUID"
    return 1
  fi

  local TRANSACTION_ID="$( ff_uuid )"
  if [ "${TRANSACTION_ID}" == "" ]; then
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" "failed to generate TRANSACTION_ID"
    return 1
  fi

  # Wrap input JSON into the MESSAGE
  local MESSAGE=$(
    # Part 1/3: headers and start of payload
    cat <<- EOF
    {
      "uri": "/organization/${ORGANIZATION}/delivery/message/${UUID}",
      "mime_type": "delivery/message",
      "header": {
        "mime_type": "delivery/publish_header",
        "transaction_id": "${TRANSACTION_ID}",

        ${HAS_ERRORS_ELEMENT}

        "from": "/service/set_environment/instance/${UUID}",
        "to":"/service/storage"
      },
      "payload": [
EOF
    # Part 2/3: payload
    echo "${INPUT_JSON}"

    # Part 3/3: footer: closing payload array and message envelop
    cat <<- EOF
      ]
    }
EOF
  )

  # Run command, capture server response as ${RESULT} and curl exit code as ${STATUS}

  local RESULT
  RESULT=$(
    curl \
      --silent   \
      --retry 3    \
      --request POST \
      --connect-timeout 10 \
      --max-time 35  \
      --retry-delay 1 \
      --header "Content-Type: application/json" \
      --data "${MESSAGE}" \
      --user "${FF_AGENT_API_USERNAME}:${FF_AGENT_API_PASSWORD}" \
      "${FF_AGENT_API_PROTOCOL}://${FF_AGENT_API_FQDN}:${FF_AGENT_API_PORT}/"
  ) || {
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" "Failed to post to ${FF_AGENT_API_PROTOCOL}://${FF_AGENT_API_FQDN}:${FF_AGENT_API_PORT}/"
    return 1
  }

  # Even if curl succeed, check some edge cases, when server replied with some JSON error
  if [[ ${RESULT} =~ (^Cannot GET) ]]; then
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" "Failed to post to ${FF_AGENT_API_PROTOCOL}://${FF_AGENT_API_FQDN}:${FF_AGENT_API_PORT}/. Got: Cannot GET"
    return 1
  fi

  # Check if resut has error mime_type (TODO: improve it to rely on actual response http_code, see implemented in url_get())
  if [[ ${RESULT} =~ (^.*"mime_type".+"rest/error") ]]; then
    bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    error "${FUNCNAME[0]}" "Failed to post to ${FF_AGENT_API_PROTOCOL}://${FF_AGENT_API_FQDN}:${FF_AGENT_API_PORT}/. Got rest/error"
    return 1
  fi

  # Return success
  bash_echo_setting_set "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
}
export -f publish_message

###############################################################################
# CATEGORY
#   SET ENVIRONMENT
#
# NAME
#   set_environment_is_working - Verifies the setup of the environment.
#
# SYNOPSIS
#   set_environment_is_working [--verbose]
#
# DESCRIPTION
#   Conducts a series of checks to ensure that the environment is correctly configured,
#   including the existence of essential commands and the functionality of state and secret management.
#   The --verbose flag enables detailed logging of each check performed.
#
# USAGE EXAMPLE
#   if ! set_environment_is_working --verbose; then
#     echo "Environment setup has issues.";
#     exit 1;
#   fi
#
# EXIT STATUS
#   0 - if the environment is correctly set up.
#   1 - if there are issues with the environment setup.
#
###############################################################################
function set_environment_is_working {

  # Check dependencies: commands are in the path
  local DEPENDENCIES=(
    cat
    check_environment_variables_are_set
    command_exists
    error
    ff_agent_check_bin_is_in_the_path
    log
    secret_check_set_and_get
    state_check_set_and_get
  )
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES[*]}" || { error "${FUNCNAME[0]}" 'error_check_dependencies'; return 1; }  # Note: check_dependencies will report exact missing dependencies

  # Check dependencies: all required environment variables are set
  # Define required variables
  local REQUIRED_VARIABLES=(
    FF_AGENT_HOME
    FF_AGENT_URI
    FF_AGENT_USER_HOME
    FF_AGENT_USERNAME
    FF_CONTENT_URL
    FF_AGENT_FQDN
    # FONT_STYLE_BOLD   # Commented out as not mandatory
    # FONT_STYLE_GREEN
    # FONT_STYLE_NORMAL
    # FONT_STYLE_RED
    N_PREFIX
    NAMESPACE
    ORGANIZATION
    # TERM
  )

  # Iterate required environment variables and make sure they all are set to non-empty value
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      error "${FUNCNAME[0]}" "Failed to ensure required environment variable is not empty: '${VARIABLE_NAME,,}'"
      return 1
    }
  done

  local HAS_ERRORS=false
  local VERBOSE=false

  # Set VERBOSE envrionment variable if requested by --verbose
  [ "${1}" == "--verbose" ] && VERBOSE=true

  # Check dependencies: commands are executed without errors
  # Loop through array of f-nested f-ns, on error set flag HAS_ERRORS (don't exit)
  # MaKE SURE THESE COMMANDS BELOW ARE TESTED ABOVE
  CHECKS=(
    # Check expected environments are in place
    check_environment_variables_are_set

    # Check nodejs installation
    check_nodejs_installation

    # Check state_set() / state_get() by setting random value to some test state and then retrieving it back
    state_check_set_and_get

    # Check secret_set() / secret_get() by setting random value to some test secret and then retrieving it back
    secret_check_set_and_get

    # Check ff_agent/bin is in the path
    ff_agent_check_bin_is_in_the_path
  )

  # Iterate over the list of commands to check
  local COMMAND
  for COMMAND in "${CHECKS[@]}"; do
    # Execute the command, capturing its output if needed and checking its return status
    if OUTPUT=$(${COMMAND} 2>&1); then
      # Command succeeded
      if [ "${VERBOSE}" == 'true' ]; then
        log "SUCCESS assertion='${COMMAND}'"
      fi
    else
      # Command failed
      HAS_ERRORS=true
      if [ "${VERBOSE}" == 'true' ]; then
        error "FAILED assertion='${COMMAND}' with output: ${OUTPUT}"
      fi
      error "error_assertion_failed_${COMMAND}"
    fi
  done

  # TODO: check if list of required basic packages is installed

  # TODO: instead of "cherry-picking" what to check we should have 1:1 "doer/instaler" and corresponding "checker" functions defined, which we'll call here by list.

  # Check if we have any errors
  if [ "${HAS_ERRORS}" == "true" ]; then
    # We have errors
    error "${FUNCNAME[0]}" 'Failed: has_errors'
    return 1
  fi
}
export -f set_environment_is_working

###############################################################################
# CATEGORY
#   SET ENVIRONMENT
#
# NAME
#   state_check_set_and_get - Tests the functionality of setting and getting a state.
#
# SYNOPSIS
#   state_check_set_and_get
#
# DESCRIPTION
#   Verifies the ability to set and retrieve a state using state_set and state_get
#   functions, respectively. Function sets test state as a time based generated value
#   then retrieves the value and checks that the retrieved value is within couple
#   seconds range from the expected value (this makes the check multithread safe).
#
# DEPENDENCIES
#   Requires 'uuidgen' and 'tr' to be installed on the system.
#
# USAGE EXAMPLE
#   if ! state_check_set_and_get; then
#     echo "Failed to set or get a state.";
#     exit 1;
#   fi
#
# EXIT STATUS
#   0 - on success, indicating the state was set and retrieved successfully.
#   1 - on failure, indicating an issue with setting or retrieving the state.
#
###############################################################################
function state_check_set_and_get {

  # Check dependencies
  local DEPENDENCIES="state_get error date"
  check_dependencies "${FUNCNAME[0]}" "${DEPENDENCIES}" || return 1  # Note: check_dependencies will report missing dependencies

  # Define test secret name
  local STATE_NAME="state_check_set_and_get"

  # Lets use current epoch seconds as the value, so even if another process uses the same check
  # the stored value will be within a couple of seconds of the expected value.
  # If we use some exact random value it will fail for multiple process doing the same check.
  # Also if we use some const static value the check will be not fully valid (could work in the past, but now failing, which we
  # would fail to detect because the expected static value simplly exists from the past).
  EXPECTED_VALUE=$( date +%s ) || { error "${FUNCNAME[0]}" 'failed to generate test value'; return 1; }

  # Check generated EXPECTED_VALUE is not empty
  [ -n "${EXPECTED_VALUE}" ] || { error "${FUNCNAME[0]}" 'failed check: generated test value is blank'; return 1; }

  # Set the state
  state_set "${STATE_NAME}" "${EXPECTED_VALUE}" || { error "${FUNCNAME[0]}" "failed to set state '${STATE_NAME}'"; return 1; }

  # Try to retrieve value
  local RETRIEVED_VALUE
  RETRIEVED_VALUE=$( state_get "${STATE_NAME}" ) || { error "${FUNCNAME[0]}" "failed to retrieve state '${STATE_NAME}'"; return 1; }

  # Compare retrieved and expected values
  local EPOCH_DELTA_S=$(( ${RETRIEVED_VALUE} - ${EXPECTED_VALUE} ))
  if [[ ${EPOCH_DELTA_S} -ge 0 ]] && [[ ${EPOCH_DELTA_S} -lt 5 ]]; then
    # Test passed: the retrieved value is within couple seconds of expected value
    return 0
  fi

  # Test failed, retrieved value is not within couple seconds of expected value
  error "${FUNCNAME[0]}" "error: retrieved value '${RETRIEVED_VALUE}' is not within couple seconds of the expected value '${EXPECTED_VALUE}'"
  return 1
}
export -f state_check_set_and_get

### END SET ENVIRONMENT FUNCTIONS

terminal_initialize
