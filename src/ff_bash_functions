#!/usr/bin/env bash

# This file is a collection of useful bash functions, which we want to source for all
# users and other scripts.
#
#
# Note: we "export -f" all the functions
# Or alternatively we could:
# declare -x -f log
# See this discussion for these and other ways to solve bash functions visibility (note also ~/.bashrc and ~/.profile way to inject f-ns for all users)
# https://stackoverflow.com/questions/1885871/exporting-a-function-in-shell
# https://unix.stackexchange.com/questions/22796/can-i-export-functions-in-bash


# Usage: assert_makedir directory
# Make directory if it does not exist
function assert_makedir {
  if [ -d "${1}" ]; then
     log "INFO: Directory \"${1}\" exists, skipping creation."
  else
     assert_clean_exit mkdir "${1}"
  fi
  return 0
}
export -f assert_makedir

# Usage: assert_cd directory
function assert_cd {

  # Check first if it is a directory.
  if [ ! -d "${1}" ]; then
     log "ERROR: Can not enter directory \"${1}\" -- it is not a directory."
     abort
  fi

  # Directory exists, now enter it. May fail due to permissions.
  if [ -d "${1}" ]; then
     assert_clean_exit cd "${1}"
  else
     log "ERROR: Can not enter directory \"${1}\""
     log "SUGGEST: check user ID and directory permissions."
     abort
  fi

  return 0
}
export -f assert_cd

# Usage: assert_clean_exit command
# Ensures command must exit cleanly (0) else will abort the entire system
function assert_clean_exit {
  #echo "TRY: ${@}"
  "${@}"
  local STATUS=${?}
  if [ ${STATUS} -ne 0 ]; then
     log "ERROR: Command \"${@}\"did not exit cleanly."
     abort
  # else
  # 	log "SUCCESS: ${@}"
  fi
}
export -f assert_clean_exit

# Ask for value and store it in variable
# @param ${1} reference Variable
# @param ${2} string Question
# @param ${3} string Prompt tooltip
# @param ${4} string Default value
# @return  Success (0) if user enter Y, Failure (1)
# Usage:
# SOME_VAR=""
# ask_for_value SOME_VAR "Set value for SOME_VAR" "SOME_VAR="
# ask_for_value SOME_VAR "Update value for SOME_VAR" "SOME_VAR=" "${SOME_VALUE}"
function ask_for_value {
    local VALUE=""

    local  __RESULTVAR=${1}
    local QUESTION=${2}
    local TOOLTIP=${3}
    local DEFAULT=${4}

    while [[ -z ${VALUE} ]]
    do
        log "${QUESTION}"
        if [[ -z ${DEFAULT} ]]
        then
            read -p "${TOOLTIP}" VALUE
        else
            read -e -p "${TOOLTIP}" -i "${DEFAULT}" VALUE
        fi
    done

    if [[ "${__RESULTVAR}" ]]; then
        eval ${__RESULTVAR}="'${VALUE}'"
    else
        echo "${VALUE}"
    fi
}
export -f ask_for_value

# Ask for question and read user input Y/n
# @param ${1} string Question
# @return  Success (0) if user enter Y, Failure (1) on n
# Usage: ask_for_yn "Does vim rox the house?"
function ask_for_yn {
    local QUESTION=${1}
    local ANSWER=""

    while [[ ${ANSWER,,} != "y" ]] && [[ ${ANSWER,,} != "n" ]]
    do
        log "${QUESTION}"
        read -p "Answer [Y/n]: " ANSWER
        if [[ -n ${ANSWER} ]] && [[ ${ANSWER,,} == "y" ]]
        then
            return 0
        fi
    done
    return 1
}
export -f ask_for_yn

# Check if a command exists. A command could be a function, something in path, a direct path to a command
# This will return in stdout the path to the command, and will return 0 if the command exists, otherwise 1
function command_exists () {
  command -v "${1}"
  return $?
}
export -f command_exists

# Check if a value exists in an array
# @param ${1} mixed  Needle
# @param ${2} array  Haystack
# @return  Success (0) if value exists, Failure (1) otherwise
# Usage: in_array "$needle" "${haystack[@]}"
# See: http://fvue.nl/wiki/Bash:_Check_if_array_element_exists
function in_array {
    local hay needle=${1}
    shift
    for hay; do
        [[ ${hay} == ${needle} ]] && return 0
    done
    return 1
}
export -f in_array

# Return index or needle in haystack, otherwise 255
# Bash range for return value from fn is (0-255) this is why when I return -1 it's 255
# @param ${1} mixed  Needle
# @param ${2} array  Haystack
# @return  Success (index) if value exists, Failure (255) otherwise
# Usage: index_of "$needle" "${haystack[@]}"
function index_of {
    local NEEDLE=${1}
    declare -a HAYSTACK=("${!2}")
    for i in "${!HAYSTACK[@]}"; do
        if [[ "${HAYSTACK[$i]}" == "${NEEDLE}" ]]; then
            return ${i};
        fi
    done
    return -1;
}
export -f index_of



# Table of contents
# generated by command:
#    cat ./src/ff_bash_functions | grep '^### BEGIN\|^### END\|^function' | sed 's/^function /    - /g' |  sed 's/{//g'
# TODO: regenerate list of functions when stable/finished
# TODO: make another f-n to generate this list (see help(), but only print f-ns we added using "set_environment" instead of all buildin f-ns)

###############################################################################
# Utility help function
# This will list all the defined bash funcitons *build in" and our "custom" ones.
function help {
    echo "Builtin functions:"
    typeset -F | cut -d' ' -f3
}
export -f help

###############################################################################
# Utility loging function to stderr
# Require ${SERVICE} to be defined. Proudce all the output in the std error stream.
#
# Usage example:
#   log "Some event happened."
#
# Example output:
#   Tue 07 Sep 2021 07:29:02 PM UTC: SomeService: Some event happened.
#
function log {
  if [ "${SERVICE}" != "" ]; then
    local LOGGER_TAG="--tag '${SERVICE}'"
  fi
   
  echo "$(date --utc): ${SERVICE}: ${@}" | tee >(logger ${LOGGER_TAG} ) >&2
}
export -f log

###############################################################################
# Utility error logging function
function error {
    log error "${@}"
}
export -f error

###############################################################################
# Utility abort / exit function - called when terminal conditions
function abort {
    error "abort called - aborting ${@}"
    set_state ${SERVICE}_last_run_state abort
    exit 1
}
export -f abort

###############################################################################
# Utility is_shell_attribute_set function
# See discussion: https://stackoverflow.com/a/34709224/7022062
# Usage example:
#     set -x
#     if is_shell_attribute_set x; then echo "xtrace enabled" ; else echo "xtrace disabled"; fi # xtrace enabled
#
#     set -e
#     if is_shell_attribute_set e; then echo "yes"; else echo "no"; fi # yes
#
#     set +e
#     if is_shell_attribute_set e; then echo "yes"; else echo "no"; fi # no
#     
function is_shell_attribute_set { # attribute, like "e"
  case "$-" in
    *"${1}"*)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

###############################################################################
# Utility is_shell_attribute_set function
# See discussion: https://stackoverflow.com/a/34709224/7022062
# Usage example:
#     set -o pipefail
#     if is_shell_option_set pipefail; then echo "yes"; else echo "no"; fi # yes
#
#     set +o pipefail
#     if is_shell_option_set pipefail; then echo "yes"; else echo "no"; fi # no
#
function is_shell_option_set { # option, like "pipefail"
  case "$(set -o | grep "${1}")" in
    *on) return 0 ;;
    *)   return 1 ;;
  esac
}


###############################################################################
#
function successful_exit {
    set_state ${SERVICE}_last_run_state success
    log ${SERVICE}_last_run_state success

    # Anthony May 8 2021 - I am choosing to leave the hotpatch for now.
    # Any 'secrets' it has are already installed on the filesystem, so there is no reason to remove it.

    exit 0
}
export -f successful_exit

# Check if terminal is interactive
# This is useful in cases where we might wish to ask a question
# If you run this script from ssh, it will return 255 (e.g. ssh hostname "terminal_is_interactive" )
function terminal_is_interactive () {
  command_exists tty && tty -s && return 0 || return 1
  return 1 # Default, it isn't.
}
export -f terminal_is_interactive

# Initialize the terminal
# Ensures that TERM is set
# Ensures we set up colours only if TERM is set, else empty strings
# Works even if we don't have tput command, which we might not
function terminal_initialize() {
  
  # If we do not have a terminal type, set up dumb
  if [ -z "${TERM}" ]; then
    export TERM=dumb
  fi

  FONT_STYLE_BOLD=""
  FONT_STYLE_GREEN=""
  FONT_STYLE_RED=""
  FONT_STYLE_NORMAL=""
  
  terminal_is_tty || return

  if command_exists tput ; then
      # If this is a TTY, These set of "t_*" variables allows us to decorate the output with some style (colour, boldness)
      FONT_STYLE_BOLD="$(tput bold)"
      FONT_STYLE_GREEN="$(tput setaf 2)"
      FONT_STYLE_RED="$(tput setaf 1)"
      FONT_STYLE_NORMAL="$(tput sgr0)"
  fi
}
export -f terminal_initialize

# Check if this terminal is a TTY
function terminal_is_tty () {
    [ -t 0 ] && return 0 || return 1
}
export -f terminal_is_tty

# Reset terminal state - sometimes useful if a command messes up terminal state
function terminal_reset () {
  [ is_tty && command_exists tput ] && tput reset && tput sane
}
export -f terminal_reset


###############################################################################
# Category: time
# Utility function to get Unix epoch time in milliseconds
# Usage example:
#   "current epoch_ms value is: $( get_epoch_ms )"
function get_epoch_ms {
    # TODO - Make this compatible with Darwin (MACOS) where date works differently.
    # For details on "date" command on Linux vs Darwin see discussion: 
    # https://stackoverflow.com/questions/9804966/date-command-does-not-follow-linux-specifications-mac-os-x-lion
    echo "$( date +%s%N | cut -b1-13 )"  # https://serverfault.com/a/151112/413686>
}
export -f get_epoch_ms


###############################################################################
# Category: environment
# Utility function - Get LSB ID - e.g. Ubuntu
function get_lsb_id {
    lsb_release --short --id
}
export -f get_lsb_id

###############################################################################
# Category: environment
# Utility function - Get release - e.g. 16.04, 18.04, 20.04
function get_lsb_release {
    lsb_release --short --release
}
export -f get_lsb_release

###############################################################################
# Category: environment
# Utility function - Get codename - e.g. breezy, focal, ..
function get_lsb_codename {
    lsb_release --short --codename
}
export -f get_lsb_codename

###############################################################################
# Category: environment
# Utility function - Get hardware architecture (e.g. arm64, amd64)
function get_hardware_architecture {
    dpkg --print-architecture 
}
export -f get_hardware_architecture

###############################################################################
# Category: identity
# Utility function - Check if User Exists
function user_exists {
    # TODO: OSX doesn't have getent. Find Equivalent
    if [ -z "$(getent passwd ${1})" ]; then
        return 1 # User does not exist
    else
        return 0 # Exists
    fi
}
export -f user_exists

###############################################################################
# Category: identity
# Utility function - Get home directory for user
function get_home_directory_for_user {
    # TODO: OSX doesn't have getent. Find Equivalent
    HOME_DIR=$( getent passwd "${1}" | cut -d: -f6 )
    if [ -z "${HOME_DIR}" ]; then
        return 1
    else
        echo "${HOME_DIR}"
    fi
}
export -f get_home_directory_for_user

###############################################################################
#
# A proper user is one that can install packages and is not root.
# Note: function will create ${AGENT_HOME} folder if it does not exist yet.
#
# Sets following environment variables:
#   BEST_USER_TO_RUN_AS - example: ubuntu
#   AGENT_HOME_DIR      - example: /home/ubuntu
#   AGENT_DIR_NAME      - example: ff_agent
#   AGENT_HOME          - example: /home/ubuntu/ff_agent
#
# Return:
#  on success - export environment variables and return 0
#  on error - return nonzero code
#
function choose_ff_agent_home {
    
    # These exports are our "return values"
    # Note: we should not: "export SOMEVAR=$( some_function_call ) || { error "error details"; abort; } " because export would hide actual exit call of the "some_function_call" and thus we'll miss an error!
    BEST_USER_TO_RUN_AS=$( get_best_user_to_run_as ) || { error "Failed to get_best_user_to_run_as."; return 1; }
    export BEST_USER_TO_RUN_AS
    
    AGENT_HOME_DIR=$( get_home_directory_for_user "${BEST_USER_TO_RUN_AS}" ) || { error "Failed to get_home_directory_for_user"; return 1; }
    export AGENT_HOME_DIR
    
    export AGENT_DIR_NAME="ff_agent"
    export AGENT_HOME="${AGENT_HOME_DIR}/${AGENT_DIR_NAME}"
}
export -f choose_ff_agent_home

###############################################################################
#
# Function makes sure ${AGENT_HOME} folder exist. If not - tries to create it.
#
# Require environment variables set:
#   - AGENT_HOME
#   - BEST_USER_TO_RUN_AS
#
# Return:
#  on success - return 0
#  on error - return nonzero code
#
function ensure_agent_home_exists {

  # Define required variables
  local REQUIRED_VARIABLES=( 
    AGENT_HOME
    BEST_USER_TO_RUN_AS
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || { return 1; }  # Note: the error(details) was already reported by ensure_variable_not_empty()
  done

  # Make sure ${AGENT_HOME} folder exist
  if [ ! -d "${AGENT_HOME}" ]; then
      # Create new folder if missing
      mkdir -p "${AGENT_HOME}"
      if [ ${?} -ne 0 ]; then
        # Failed to create ${AGENT_HOME} - report error() and abort()
        # error "Did not find AGENT_HOME directory at ${AGENT_HOME}. Tried to create it but failed. Aborting."
        set_state "${FUNCNAME[0]}" "failed_to_create_agent_home"
        return 1
      fi
      # Change ownership of AGENT_HOME to the BEST_USER_TO_RUN_AS (case: installer started by 'root')
      sudo chown "${BEST_USER_TO_RUN_AS}:$(id -gn ${BEST_USER_TO_RUN_AS})" "${AGENT_HOME}"
  fi
}
export -f ensure_agent_home_exists

###############################################################################
#
# Function checks if variable given by name is defined.
# Function takes the only argument: variable name.
# Return:
#    on "success" (variable is defined) - return 0
#    on "error" (varialbe not devined) - return non zero code and callse error(error_details)
#
function ensure_variable_defined {
  local NAME="$1"
  [[ -z "${NAME}" ]] && { error "error_ensure_variable_defined_no_arguments"; return 1; }  # Check: NAME is not blank
  [[ -v "${NAME}" ]] && { return 0; }  # Check: variable by NAME is defined

  # Create meaningful error code, which include lowcase variable name
  local ERROR_CODE=$( echo "error_expected_variable_not_set_${NAME}" | tr '[:upper:]' '[:lower:]' )

  # Report an error and return nonzero code.
  error "${ERROR_CODE}"
  return 1
}
export -f ensure_variable_defined

###############################################################################
#
# Function checks if variable given by name is defined and has non-empty value.
# Function takes the only argument: variable name.
# Return:
#    on "success" (variable is defined and non-empty) - return 0
#    on "error" (varialbe not defined or has empty value) - return nonzero code and callse error(error_details)
#
function ensure_variable_not_empty {
  local NAME="$1"
  [[ -z "${NAME}" ]] && { error "error_ensure_variable_not_empty_no_arguments"; return 1; }  # Check: NAME itself is not blank
  [[ -v "${NAME}" ]] && [[ ! -z "${!NAME}" ]] && { return 0; }  # Check: variable by NAME is defined and not empty

  # Create meaningful error code, which include lowcase variable name
  local ERROR_CODE=$( echo "error_ensure_variable_not_empty_${NAME}" | tr '[:upper:]' '[:lower:]' )

  # Report an error and return nonzero code.
  error "${ERROR_CODE}"
  return 1
}
export -f ensure_variable_not_empty

###############################################################################
#
# stop_pm2 solves the problem of pm2 running by multiple user (designated "choosen user" and "root").
# stop_pm2 would stop all found pm2 instances and remove it from automatic startup.
#
# Dependency: environment variables must be set:
#    - AGENT_HOME_DIR
#    - BEST_USER_TO_RUN_AS
#
function stop_pm2 {
    set_state "${FUNCNAME[0]}" 'stopping'

    # # There was a problem inside stop_pm2() due to npm re-installed in a new location
    # # We used this "snapshot" which happened to be useful.
    # # TODO: let's add even more useful findings here and move it into the ff_bash_funcions as "debug_snapshot()"
    # echo "--------------- debug_snapshot begin -----------------"
    # date
    # pwd
    # whoami
    # which n
    # which npm
    # which node
    # n --version
    # npm --version
    # node --version
    # echo ${PATH}
    # echo ${N_PREFIX}  # expected result: /home/ubuntu/ff_agent/.n
    # pm2 ps
    # which pm2
    # sudo ps aux | grep pm2
    # sudo systemctl status pm2-${BEST_USER_TO_RUN_AS}
    # echo "--------------- debug_snapshot end -----------------"

    # Check required environment variables are set: AGENT_HOME_DIR BEST_USER_TO_RUN_AS
    for VARIABLE_NAME in AGENT_HOME_DIR BEST_USER_TO_RUN_AS; do
      ensure_variable_not_empty "${VARIABLE_NAME}" || { return 1; }  # Note: the error(details) was already reported by ensure_variable_not_empty()
    done

    # pm2 may not be  installed, so we have nothing to stop
    PM2=$( which pm2 )
    if [ -z "${PM2}" ]; then
      set_state "${FUNCNAME[0]}" 'pm2_executable_not_found_error'
      return 1
    fi

    timeout 5 ${PM2} unstartup
    timeout 5 ${PM2} kill
    timeout 5 sudo ${PM2} unstartup
    timeout 5 sudo ${PM2} kill

    # Kill all processes mentioning pm2 owned by me. This is a tad aggressive, but
    # pm2 has some stupid process names
    ps auxw | grep ^${BEST_USER_TO_RUN_AS} | grep -i pm2 | grep -v grep | grep -v hotpatch
    PROCS=$( ps auxw | grep ^${BEST_USER_TO_RUN_AS} | grep -i pm2 | grep -v grep | grep -v hotpatch | awk '{ print $2 }' )
    if [ "${PROCS}" != "" ]; then
      kill ${PROCS}
    fi
    PROCS=$( ps auxw | grep ^${BEST_USER_TO_RUN_AS} | grep -i pm2 | grep -v grep | grep -v hotpatch | awk '{ print $2 }' )
    [ "${PROCS}" != "" ] && { set_state "${FUNCNAME[0]}" "assertion_failure_should_be_no_pm2_processes_owned_by_user"; return 1; }
    set_state "${FUNCNAME[0]}" "assertion_success_no_pm2_processes_owned_by_user"

    # Disable any root style services
    for ACTION in stop disable
    do
      sudo systemctl "${ACTION}" pm2-${BEST_USER_TO_RUN_AS}
    done

    # Tell root to remove the startup entry for itself.
    # Otherwise, on a reboot, it might come back
    timeout 5 sudo pm2 unstartup
    pm2 kill

    # Kill any root processes lingering
    ps auxw | grep root | grep -i pm2 | grep -v grep | grep -v hotpatch
    PROCS=$( ps auxw | grep root | grep -i pm2 | grep -v grep | grep -v hotpatch | awk '{ print $2 }' )
    if [ "${PROCS}" != "" ]; then
      kill ${PROCS}
    fi
    PROCS=$( ps auxw | grep root | grep -i pm2 | grep -v grep | grep -v hotpatch | awk '{ print $2 }' )
    [ "${PROCS}" != "" ] && { set_state "${FUNCNAME[0]}" "assertion_failure_should_be_no_pm2_processes_owned_by_root"; return 1; }
    set_state "${FUNCNAME[0]}" 'assertion_success_no_pm2_processes_owned_by_root'

    # Post condition, there is no pm2 process running for any user
    ps auxw | grep -i pm2 | grep -v grep
    PROCS=$( ps auxw | grep -i pm2 | grep -v grep | grep -v hotpatch | awk '{ print $2 }' )
    if [ "${PROCS}" != "" ]; then
      set_state "${FUNCNAME[0]}" 'could_not_stop_all_pm2_processes_error'
      return 1
    fi
    PROCS=$( ps auxw | grep -i pm2 | grep -v grep | grep -v hotpatch | awk '{ print $2 }' )
    [ "${PROCS}" != "" ] && { set_state "${FUNCNAME[0]}" "assertion_failure_should_be_no_pm2_processes_running"; return 1; }
    set_state "${FUNCNAME[0]}" 'assertion_success_no_pm2_processes'

    # Just in case, make sure we own our own .pm2
    if [ -d "${AGENT_HOME_DIR}/.pm2" ]; then
      sudo chown -R "${BEST_USER_TO_RUN_AS}:$(id -gn ${BEST_USER_TO_RUN_AS})" ${AGENT_HOME_DIR}/.pm2 || { set_state "${FUNCNAME[0]}" "could_not_change_ownership_of_directory"; return 1; }
    fi

    set_state "${FUNCNAME[0]}" 'success_stopped'
    return 0
}
export -f stop_pm2

###############################################################################
#
# Find out the best user to run as.
# Return:
#  on success - return a string (username to use).
#  on error - log error() and abort() execution
#
# The logic "best user" selection:
# We don't run as root, or root-like account.
# We would like an account that can install packages to set the environment up correctly.
# We check the following user accounts candidates: "ff_agent", "ubuntu" or current user.
# Selected user should have rights to install packages. Ideally locally, but one step at a time.
#
function get_best_user_to_run_as {

    POTENTIAL_USERS=( ff_agent ubuntu ${USER} )

    if effectively_root
    then
        # Look for a better user.
        for POTENTIAL_USER in ${POTENTIAL_USERS[@]}
        do
            if user_exists ${POTENTIAL_USER}
            then
                if can_sudo "${POTENTIAL_USER}"
                then
                    echo "${POTENTIAL_USER}"
                    return 0
                fi
            fi
        done

        error "Current user ${USER} is effectively root and this script can not run as root."
        error "Tried to find other users to run as (${POTENTIAL_USERS}) but was not successful."
        abort

    else
        # We aren't root. But can we sudo? We need that to currently install certain packages.
        if can_sudo "${USER}"
        then
            echo "${USER}"
            return 0
        else
            error "User ${USER} can not sudo. Currently sudo is required to install packages. Please run from a non-root account with sudo privileges."
            exit 1
        fi
    fi

}
export -f get_best_user_to_run_as

###############################################################################
# Category: identity
# Utility function - Create User, with a disabled password
function create_user {
  USERNAME="${1}"
	if [ ! -z "${USERNAME}" ]; then
		if can_sudo "${USERNAME}"; then
        	# TODO: Make this multiplatform. Check what happens if we do this in a docker.
        	sudo adduser --disabled-password --gecos "" "${USERNAME}"
			return ${?}
		fi
	fi
	return 1
}
export -f create_user

###############################################################################
# Category: authorization
# Utility function - Am I root? Return 0 if I am, 1 if not
function effectively_root {
    if  [ "${EUID}" -eq 0 ]; then
        return 0 # I have root powers
    else
        return 1 # Don't have root powers
    fi
}
export -f effectively_root

###############################################################################
# Category: authorization
# Utility function - Can I sudo?
# @param1 user_to_check
function can_sudo {
    USER_TO_CHECK="${1}"

    USER_CAN_SUDO=1  # Assume they can't. 1 is an error code meaning we can't.

    # SUDOers can be defined in a few places - /etc/sudoers and /etc/sudoers.d/*
    # Note: /etc/sudoers is old and bad
    if sudo --non-interactive --list --other-user="${USER_TO_CHECK}" &>/dev/null true
    then
        USER_CAN_SUDO=0
    else
        if groups "${USER_TO_CHECK}" 2>/dev/null | grep --text "\<sudo\>" &> /dev/null; then
            USER_CAN_SUDO=0 # I can sudo
        else
            USER_CAN_SUDO=1 # I can't sudo
        fi
    fi

    # TODO: If user can sudo, have that user check if they are in old /etc/sudoers or new form
    # and emit error otherwise.

    return ${USER_CAN_SUDO}
}
export -f can_sudo

###############################################################################
# Category: process
# Utility function - Get cmdline of parent process ID -- useful to know who is starting us
# E.g. if [ $( get_ppid_cmd | grep --text -c node ) -gt "0" ] -> will let you check if your parent process is nodejs
function get_ppid_cmd {
    PPID_CMD=$( cat /proc/${PPID}/cmdline )
    echo "${PPID_CMD}"
}
export -f get_ppid_cmd

###############################################################################
# Category: container
# Utility function - Get Docker Version
function get_installed_docker_version {
    DOCKER_PATH=$( command -v docker )
    if [ -z "${DOCKER_PATH}" ]; then
        return 1
    else
        DOCKER_VERSION=$( ${DOCKER_PATH} -v | cut -d" " -f 3 | cut -d"." -f 1 )
        echo "${DOCKER_VERSION}"
    fi
}
export -f get_installed_docker_version

###############################################################################
# Category: container
# Utility function - Check if container exists
#
# Usage example:
#    if container_name_exists "some_container_name"; then
#       # Yes, container by given name does exist.
#    else
#       # No such container found
#    fi
#
function container_name_exists {
    CONTAINER_NAME="${1}"
    # -z - true if the length of string is zero
    # -n - true if the length of string is nonzero
    if [ -z "${CONTAINER_NAME}" ]; then
        error "error_no_container_name_specified"
        return 2
    fi
    CONTAINER_ID=$(docker inspect --format="{{.Id}}" ${CONTAINER_NAME} 2> /dev/null)
    if [[ "${CONTAINER_ID}" ]]; then
        return 0
    else
        return 1
    fi
}
export -f container_name_exists

###############################################################################
# Category: container
# Utility function - Check if docker container running. This checks if it is running, but it could be in a 'restart' loop.
function is_container_running () {
    CONTAINER_NAME="${1}"
    if [ -z "${CONTAINER_NAME}" ]; then
        error "error_no_container_name_specified"
        return 2
    fi
    if [ "$( docker container inspect -f '{{.State.Running}}' ${CONTAINER_NAME} )" == "true" ]; then
        return 0
    else
        return 1
    fi
}
export -f is_container_running

###############################################################################
# Category: container
# Utility function - Check if docker container healthy or not. This checks if the container is actually in the state 'running' vs. restarting
function is_container_healthy () {
    CONTAINER_NAME="${1}"

    # -z - true if the length of string is zero
    # -n - true if the length of string is nonzero
    if [ -z "${CONTAINER_NAME}" ]; then
        error "error_no_container_name_specified"
        return 2
    fi
    if [ "$( docker container inspect -f '{{.State.Status}}' ${CONTAINER_NAME} )" == "running" ]; then
        return 0
    else
        return 1
    fi
}
export -f is_container_healthy

###############################################################################
# Category: aaa
# Utility function - check if user is in a group
# Usage: is_user_in_group "user" "group"
function is_user_in_group () {
  USERNAME="${1}"
  GROUP="${2}"
  [ -z "${USERNAME}" ] && return 1
  [ -z "${GROUP}" ] && return 1
  if getent group "${GROUP}" | grep -q "\b${USERNAME}\b"; then
      return 0
  else
      return 1
  fi
}
export -f is_user_in_group

###############################################################################
# Category: container
# Utility function - Restart docker containers
function restart_containers {

    # THIS CHECK FAILS:
    # + return 0
    # + CONTAINERS=(control_backend service_metric_proxy control_proxy real_browser service_provisioning delivery_discover)
    # + restart_containers control_backend service_metric_proxy control_proxy real_browser service_provisioning delivery_discover
    # + '[' -z control_backend service_metric_proxy control_proxy real_browser service_provisioning delivery_discover ']'
    # /home/ubuntu/ff_agent/bin/hotpatch: line 434: [: too many arguments
    # + CONTAINERS=(${@})
    # + CONTAINERS_TO_RESTART=()
    # + for CONTAINER in ${CONTAINERS[@]}
    # + container_name_exists control_backend
    # ... and it keep working normally

    # if [ -z "${@}" ]; then
    #     error "error_no_container_names_specified"
    #     return 2
    # fi
    CONTAINERS=(${@})
    CONTAINERS_TO_RESTART=()
    for CONTAINER in ${CONTAINERS[@]}
    do
        # We only restart a container if it is defined
        if container_name_exists "${CONTAINER}"
        then
            CONTAINERS_TO_RESTART+=( ${CONTAINER} )
        fi
    done

    if (( ${#CONTAINERS_TO_RESTART[@]} )); then
        # TODO: Factor out sudo
        sudo docker restart ${CONTAINERS_TO_RESTART[@]}
        return ${?}
    fi

    return 1
}
export -f restart_containers

###############################################################################
# Category: container
# Utility function - Restart docker containers
# Function gets container name (case sensitive) (can be partial) as the only input argument and
# tries to find all matching containers (even if they're in stopped state). Then for every found
# container it will "docker stop" and "docker remove" them.
# Runction return code 0 on success
#
function stop_and_remove_container_by_name {
  CONTAINER_NAME="${1}"

  # Check the container name isn't blank
  if [ "${CONTAINER_NAME}" == "" ]; then
    return 1
  fi

  # Count existing container(s) by given docker name
  FOUND_CONTAINERS_COUNT=$( docker ps -a | grep "${CONTAINER_NAME}" | wc -l )

  # Check if we found >1
  if [ ${FOUND_CONTAINERS_COUNT} -gt 1 ]; then
    # Yes, we found >1 containers to stop/remove         
    for DOCKER_ID in $(docker ps -a | grep "${CONTAINER_NAME}" | awk '{print $1}'); do
      # Make sure DOCKER_ID is not a blank string
      if [ "${DOCKER_ID}" == "" ]; then
        # TODO: shall the utility f-n use set_state?
        return 1
      fi

      # Try to stop and remove the container
      docker stop "${DOCKER_ID}"
      docker rm "${DOCKER_ID}"

      # Sometimes container can be in the broken state, in this case even after stopping and removing it
      # the DOCKER_ID is still visible in the "docker ps" list. In this cas we need to kill -9 corresponding
      # process on the host level:
      STILL_PRESENT_DOCKER_ID=$( docker ps -a | grep "${DOCKER_ID}" | wc -l )
      if [ "${STILL_PRESENT_DOCKER_ID}" != "" ]; then
        # Yes, we have found "unstoppable" docker. Kill -9 the corresponding process now
        PID_TO_KILL_COUNT=$( sudo ps aux | grep "${DOCKER_ID}" | wc -l )
        PID_TO_KILL=$( sudo ps aux | grep "${DOCKER_ID}" )
        if [ ${PID_TO_KILL_COUNT} -ne 1 ]; then
          # Something went wrong, we supposed to find exactly ONE pid to terminate.
          return 1
        fi
        
        # Send "kill -9" signal to the found process
        sudo kill -9 "${PID_TO_KILL}" || { set_state "${FUNCNAME[0]}" 'error_killing_process'; return 1; }

        # The "unstoppable" docker terminated, now we can safely remove the container
        docker rm "${DOCKER_ID}"
      fi
    done

    # Cleanup some space
    docker system prune -a -f
  fi

  return 0
}
export -f stop_and_remove_container_by_name

###############################################################################
# Category: file
# Utility function - Easy way to check if a glob matches.
# This is a bash builtin wrapper. e.g. glob_matches '/tmp/abc*' will return 0 or 1
function glob_matches {
	compgen -G ${@} >/dev/null
	return ${?}
}
export -f glob_matches

###############################################################################
# Category: file
# Utility function - Easy way to check if a file contains a pattern
function file_contains_pattern {
    FILE="${1}"
    PATTERN="${2}"

    if [ ! -e "${FILE}" ]; then
        return 1
    fi
    if [  -z "${PATTERN}" ]; then
        return 1
    fi
    grep --quiet --text "${PATTERN}" "${FILE}"
}
export -f file_contains_pattern

###############################################################################
# Category: file
# Utility function - checks if given file has "EOL" at the end of the file. It gets the path to the file as the only argument and:
#   - returns value 0 if file has EOL at the end (or file is empty)
#   - returns nonzero value in case file doesn't have EOL at the end
#
# Function is used to avoid concatination of more than one name/vale pairs into configuration files (be it yaml or .env files).
#
function does_file_have_eol_at_the_end {
    FILENAME="${1}"
    if [ ! -s "${FILENAME}" ]; then
        # Note: For our needs (to avoid concatination of name/value lines) we consider empty file as having EOL (i.e. safe to append more name/values)
        # The file is empty.
        # Note: function does_file_have_eol_at_the_end() got empty file. 
        # For our needs (to avoid concatination of name/value lines) 
        # we consider empty file as having EOL (i.e. safe to append more name/values)
        return 0
    # -z - true if the length of string is zero
    # -n - true if the length of string is nonzero
    elif [ -z "$(tail -c 1 <"${FILENAME}")" ]; then
        # The file ends with a newline or with a null byte,
        return 0
    else
        # The file does not end with a newline nor with a null byte.
        return 1
    fi
}
export -f does_file_have_eol_at_the_end

###############################################################################
# Category: file
# Utility function - truncates file to zero
#
# Return codes
#   0 - success
#   2 - missing target filename
#   3 - target file does not exist
#   4 - not enough permissions to read the target file
#   5 - not enough permissions to writ the target file
#   6 - failed to truncate the target file (expected size didn't drop to zero)
#
# Usage example:
#   truncate_file /some/path/to/the/file.txt
#
# Note: if you truncating the log file, which is actively used by running process(es) there might be the case
# when right after you truncated the file it was written to before we checked the size, so error code 6 might
# be not an error in these cases.
#
function truncate_file {
  # Get filename argument
  TARGET_FILE="${1}"

  # Check filename is not blank
  if [ "${TARGET_FILE}" == "" ]; then
    # Error: missing target filename
    return 2
  fi

  # Check file exists
  if [ ! -f "${TARGET_FILE}" ]; then
    # Error: file does not exist
    return 3
  fi

  # Check if target file is readable
  if [ ! -r "${TARGET_FILE}" ]; then
    # Error: not enough permissions to read target file
    return 4
  fi  

  # Check if target file is writable
  if [ ! -w "${TARGET_FILE}" ]; then
    # Error: not enough permissions to write target file
    return 5
  fi

  # Check if file is not empty, then truncate it to zero
  if [ -s "${TARGET_FILE}" ]; then
    # File is not empty.
    # Warning: don't "sudo" here, for files with permissions like "-rw-rw-r--" truncate won't have access by root user
    truncate --size=0 "${TARGET_FILE}" || { set_state "${FUNCNAME[0]}" 'error_trancating_file'; return 1; }
  else
    # File is already empty
    return 0
  fi

  # Final check: file must have zero size now
  if [ -s file ]; then
    # Error: File is not empty after truncation
    return 6
  fi

  return 0
}
export -f truncate_file

###############################################################################
# Category: file
# Utility function - parses given file and replaces all lines containing a match by the given regular expression to other string.
# replace_all_lines_by_regexp "find pattern" "replacement string" "/path/to/file"
#
# Usage example:
#   replace_all_lines_by_regexp "Some line matcher regexp \(.*\)" "New content"  /some/path/to/the/file.txt
#
# Return codes:
#   0 - successfully replaced lines
#   1 - missing inputs: regular expression or replacement string is empty
#   2 - missing target filename
#   3 - target file does not exist
#   4 - not enough permissions to read the target file
#   5 - not enough permissions to writ the target file
#   6 - the pattern was not found (in some cases this might be 'success' because some line was already replaced successfully before)
#   7 - failed to search by given pattern (most probably bad regex pattern)
#   8 - editor return an error (most probably bad regex pattern
#   9 - zero lines replaced (despite the pattern was found and editor didn't error out and we have all the permissions)
#  10 - Failed to create temporary file
#  11 - Failed to copy target file to temporary file
#
function replace_all_lines_by_regexp {

  # Get regexp argument
  REGEX="${1}"
  REPLACE="${2}"

  # Check if regex is not empty
  if [ "${REGEX}" == "" ]; then
    # Error: missing regular expression
    return 1
  fi

  # REPLACEMENT STRING CAN BE EMPTY. DISABLING THIS CHECK.
  # # Check if replacement string is not empty
  # if [ "${REPLACE}" == "" ]; then
  #   # Error: missing replacement string
  #   return 1
  # fi

  # Get filename argument
  TARGET_FILE="${3}"

  # Check filename is not blank
  if [ "${TARGET_FILE}" == "" ]; then
    # Error: missing target filename
    return 2
  fi

  # Check file exists
  if [ ! -f "${TARGET_FILE}" ]; then
    # Error: file does not exist
    return 3
  fi

  # Check if target file is readable
  if [ ! -r "${TARGET_FILE}" ]; then
    # Error: not enough permissions to read target file
    return 4
  fi  

  # Check if target file is writable
  if [ ! -w "${TARGET_FILE}" ]; then
    # Error: not enough permissions to write target file
    return 5
  fi

  # Try to find by given regexp
  GREP_OUTPUT=$( grep -q "${REGEX}" "${TARGET_FILE}" 2>&1 )
  GREP_CODE=${?}

  # Check if the pattern is found
  if [ ${GREP_CODE} -eq 1 ]; then
    # The pattern was not found
    return 6
  fi
  if [ ${GREP_CODE} -gt 1 ]; then
    # Error: 7 - failed to search by given pattern.
    # Pass grep output through stdout.
    return 7
  fi
  
  # Make a temporary copy of the edited file (the only reason: we need to count number of modified lines by the editor)
  ORIGINAL_FILE_COPY="$( mktemp 2>&1 )"
  if [ ${?} -ne 0 ] || [ ! -f "${ORIGINAL_FILE_COPY}" ]; then
    # "failed to create temporary file. Details: ${ORIGINAL_FILE_COPY}"
    return 10
  fi

  # Create a temporary copy of the target file before editing it
  cp "${TARGET_FILE}" "${ORIGINAL_FILE_COPY}"
  if [ ${?} -ne 0 ]; then
    # "failed to copy file ${TARGET_FILE} to temporary file ${ORIGINAL_FILE_COPY}"
    return 11
  fi

  # We found line(s) in the target file. Edit file:
  EDITOR_OUTPUT=$( sudo sed -i "s/${REGEX}/${REPLACE}/" "${TARGET_FILE}" 2>&1 )

  # Check if stream editor error out.
  # Example: bad pattern would return code=1 and error message: sed: -e expression #1, char 8: unterminated address regex
  EDITOR_CODE=${?}
  if [ ${EDITOR_CODE} -ne 0 ]; then
    # Error: editor return an error (most probably bad regex pattern)
    # Pass editor output (error details) to stdout.
    rm "${ORIGINAL_FILE_COPY}"
    return 8
  fi

  # Count the number of modified lines
  # Note: sed always return 0, so it won't let us know how many changes were done unless we count "before" and "after"
  MODIFIED_LINES_COUNT=$( diff "${TARGET_FILE}" "${ORIGINAL_FILE_COPY}" | grep '^<' | wc -l )
  rm "${ORIGINAL_FILE_COPY}"

  # Check the number of modified lines is > 0
  if [ ${MODIFIED_LINES_COUNT} -gt 0 ]; then
    # Success. Pass the number of deleted lines through stdout.
    return 0
  else
    # Somehow the number of lines did't change even though we found the pattern (obviously an error).
    # Pass editor output (error details) to stdout.
    return 9
  fi
}
export -f replace_all_lines_by_regexp

###############################################################################
# Category: file
# Utility function -  parses given file and removes all lines containing a match by the given regular expression.
#
# Usage example:
#   remove_all_lines_by_regexp "Some line matcher regexp \(.*\)"  /some/path/to/the/file.txt
#
# Return codes:
#   0 - successfully removed lines
#   1 - missing regular expression
#   2 - missing target filename
#   3 - target file does not exist
#   4 - not enough permissions to read the target file
#   5 - not enough permissions to writ the target file
#   6 - the pattern was not found (in some cases this might be 'success' because some lines were already removed successfully before)
#   7 - failed to search by given pattern (most probably bad regex pattern)
#   8 - editor return an error (most probably bad regex pattern
#   9 - zero lines removed (despite the pattern was found and editor didn't error out and we have all the permissions)
#
function remove_all_lines_by_regexp {

  # Get regexp argument
  REGEX="${1}"
  
  # Check is is not empty string
  if [ "${REGEX}" == "" ]; then
    # Error: missing regular expression
    return 1
  fi

  # Get filename argument
  TARGET_FILE="${2}"

  # Check filename is not blank
  if [ "${TARGET_FILE}" == "" ]; then
    # Error: missing target filename
    return 2
  fi

  # Check file exists
  if [ ! -f "${TARGET_FILE}" ]; then
    # Error: file does not exist
    return 3
  fi

  # Check if target file is readable
  if [ ! -r "${TARGET_FILE}" ]; then
    # Error: not enough permissions to read target file
    return 4
  fi  

  # Check if target file is writable
  if [ ! -w "${TARGET_FILE}" ]; then
    # Error: not enough permissions to write target file
    return 5
  fi

  # Try to find by given regexp
  # Note: we collect grep output even though "-q" is used: to cover all the error cases and
  # not spill output to stderr/stdout. We might enrich return error with more details later
  # (examaple: bad syntax in the used regex).
  GREP_OUTPUT=$( grep -q "${REGEX}" "${TARGET_FILE}" 2>&1 )
  GREP_CODE=${?}

  # Check if the pattern is found
  if [ ${GREP_CODE} -eq 1 ]; then
    # The pattern was not found
    return 6
  fi
  if [ ${GREP_CODE} -gt 1 ]; then
    # Error: 7 - failed to search by given pattern.
    return 7
  fi
  
  # Take a note on the current number of lines
  LINE_COUNT_BEFORE_CHANGE="$( cat "${TARGET_FILE}" | wc -l )"

  # Found line in the target file. Edit file:
  EDITOR_OUTPUT=$( sed -i "/${REGEX}/d" "${TARGET_FILE}" 2>&1 )

  # Check if stream editor error out.
  # Example: bad pattern would return code=1 and error message: sed: -e expression #1, char 8: unterminated address regex
  EDITOR_CODE=${?}
  if [ ${EDITOR_CODE} -ne 0 ]; then
    # Error: editor return an error (most probably bad regex pattern)
    return 8
  fi

  # Count the number of deleted lines
  # Note: sed always return 0, so it won't let us know how many changes were done
  LINE_COUNT_AFTER_CHANGE="$( cat "${TARGET_FILE}" | wc -l )"
  DELETED_LINES_COUNT=$(( LINE_COUNT_BEFORE_CHANGE - LINE_COUNT_AFTER_CHANGE ))

  # Check the number of deleted lines
  if [ ${DELETED_LINES_COUNT} -gt 0 ]; then
    # Success
    return 0
  else
    # Somehow the number of lines did't change even though we found the pattern (obviously an error).
    return 9
  fi
}
export -f remove_all_lines_by_regexp

###############################################################################
# Utility wrapper around apt_update for safer headless operation
function apt_update {
    APT_COMMAND=update
    sudo DEBIAN_FRONTEND=noninteractive apt-get -oDpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${APT_COMMAND}
    if [ ${?} -ne 0 ]; then
       error "updating packages"
       return 1
    fi
    return 0
}
export -f apt_update

###############################################################################
# Utility wrapper around apt_update for safer headless operation
function apt_upgrade {
    APT_COMMAND=upgrade
    # Note: we suppress stdout noise (only stderr will still be "visible", but TODO: think of better way to collect evidences insted of just 1 large pile)
    sudo DEBIAN_FRONTEND=noninteractive apt-get -oDpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${APT_COMMAND} > /dev/null
    if [ ${?} -ne 0 ]; then
       error "Error upgrading packages"
       return 1
    fi
    return 0
}
export -f apt_upgrade

###############################################################################
# Utility wrapper around apt install for safer headless operation
function apt_install {
    PACKAGES=${@}
    APT_COMMAND=install

    for PACKAGE in ${PACKAGES}
    do
        # Note: we suppress stdout noise (only stderr will still be "visible", but TODO: think of better way to collect evidences insted of just 1 large pile)
        sudo DEBIAN_FRONTEND=noninteractive apt-get -oDpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${APT_COMMAND} ${PACKAGE} > /dev/null
        if [ ${?} -ne 0 ]; then
            error "Error installing package: ${PACKAGE}"
            return 1
        fi
    done
    return 0
}
export -f apt_install

###############################################################################
# Utility wrapper around apt reinstall for safer headless operation
function apt_reinstall {
    PACKAGES=${@}
    APT_COMMAND=reinstall

    for PACKAGE in ${PACKAGES}
    do
        sudo DEBIAN_FRONTEND=noninteractive apt-get -oDpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${APT_COMMAND} ${PACKAGE}
        if [ ${?} -ne 0 ]; then
            error "Error reinstalling packages: ${PACKAGE}"
            return 1
        fi
    done
    return 0
}
export -f apt_reinstall

###############################################################################
# Utility wrapper around apt_remove for safer headless operation
function apt_remove {
    PACKAGES=${@}
    APT_COMMAND=remove

    for PACKAGE in ${PACKAGES}
    do
        sudo DEBIAN_FRONTEND=noninteractive apt-get -oDpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${APT_COMMAND} "${PACKAGE}"
        if [ ${?} -ne 0 ]; then
            error "Error removing packages: ${PACKAGE}"
            return 1
        fi
    done
}
export -f apt_remove


###############################################################################
# Utility wrapper to list all the files by given package name (even if package not installed).
# As for reverse checking files from packages apt-file would be the best bet.
#
# Discussion: https://serverfault.com/a/1059513/413686
#
# Usage:
#    apt_list <package name>
#
# Example: 
#    apt_list libjansson-dev
#
apt_list () {
    apt-get download -o Dir::Cache::archives="./" --print-uris "$@" |awk -F\' '{print $2}' | xargs -I '{}' curl -skL '{}' | dpkg-deb -c /dev/stdin 
}
export -f apt_list

###############################################################################
# Utility function, getting secret value by given secret key name.
# Note: get_secret() require the "$AGENT_HOME"to be set.
function get_secret {

    # Preserve current xtrace state
    if is_shell_attribute_set x; then
      XTRACE_WAS_ENABLED=true
    fi

    set  +x # Disble xtrace to avoid priting secrets

    KEY="${1}"

    # Check if AGENT_HOME is not empty
    if [ "${AGENT_HOME}" == "" ]; then
      [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
      return 1
    fi

    # Check if key is not empty
    if [ "${KEY}" == "" ]; then
      [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
      return 1
    fi

    # Due to the previous runs we sometimes end up with secret files having 'null' as a value (4-byte).
    # Let's run cleanup only once (upon 1st call) and set the flag to avoid any futher cleaning ups during this run.
    # Note: -z - true if the length of string is zero
    #       -n - true if the length of string is nonzero
    if [ -z "${GET_SECRET_WIPE_NULLS_RUN_ONCE_FLAG}" ]; then
        grep -l null "${AGENT_HOME}/secrets/*" 2>/dev/null | xargs rm 2>/dev/null
        GET_SECRET_WIPE_NULLS_RUN_ONCE_FLAG="any non empty string can be 'a flag'"
    fi

    # Case: requested key already exists in ff_agent "secrets/" folder
    if [ -e "${AGENT_HOME}/secrets/${KEY}" ]; then
        cat "${AGENT_HOME}/secrets/${KEY}"
        [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
        return
    fi

    # Case: cloud user-data JSON exists: search in it under "agent/configuration"
    if [ -e /var/lib/cloud/instance ]; then
        VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq '.[] | select(.mime_type=="agent/configuration")' | jq -r ".${KEY}" | grep -v -e '^null$' )
        # Note: -z - true if the length of string is zero
        #       -n - true if the length of string is nonzero
        if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
            echo ${VALUE}
            [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
            return
        fi

        # Special case for "control_api_user" and "control_api_password" - these 2 values
        # are nexted few levels deep in "agent/configuration"
        if [ "${KEY}" == "control_api_user" ] || [ "${KEY}" == "CONTROL_API_USER" ]; then
          VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq -r '.[] | select(.mime_type == "agent/configuration") | .roles[] | select(.role_name == "AgentRole") | .services[] | select(.service_name == "ActionManager") | .control_api_user' )
          if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
              echo ${VALUE}
              [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
              return
          fi
        fi
        if [ "${KEY}" == "control_api_password" ] || [ "${KEY}" == "CONTROL_API_PASSWORD" ]; then
          VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq -r '.[] | select(.mime_type == "agent/configuration") | .roles[] | select(.role_name == "AgentRole") | .services[] | select(.service_name == "ActionManager") | .control_api_password' )
          if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
              echo ${VALUE}
              [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
              return
          fi
        fi
    fi

    # Case: search in "provisioning/instance"
    if [ -e /var/lib/cloud/instance ]; then
        VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq '.[] | select(.mime_type=="provisioning/instance")' | jq -r ".${KEY}" | grep -v -e '^null$' )
        # Note: -z - true if the length of string is zero
        #       -n - true if the length of string is nonzero
        if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
            echo ${VALUE}
            [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
            return
        fi
    fi

    # Case: We are on a local VM agent - let's check user_data.editor_answers.json
    USER_DATA="/etc/ff/configuration/user_data.editor_answers.json"
    if [ -e "${USER_DATA}" ]; then
	    VALUE=$( cat "${USER_DATA}" | jq ".${KEY}" | cut -d'"' -f2 )
        if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
            [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
            echo ${VALUE}
            return
        fi
    fi

    # Case: We are on a new build (blank cloud box with user_data.json injected as: /etc/ff/configuration/user_data.json )
    if [ -f /etc/ff/configuration/user_data.json ]; then
        VALUE=$( sudo cat /etc/ff/configuration/user_data.json | jq '.[] | select(.mime_type=="agent/configuration")' | jq -r ".${KEY}" | grep -v -e '^null$' )
        if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
            [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
            echo ${VALUE}
            return
        fi
    fi

    # Case: We're looking for KEY=="AGENT_URI" and we are on a traffic_generator.
    # In this case AGENT_URI was already generated and stored to /etc/ff/configuration/agent_uri
    # Let's retreive it from there and re-store it into our standardized place (by set_secret)
    if [ "${KEY}" == "agent_uri" ] && [ -f /etc/ff/configuration/agent_uri ]; then
      AGENT_URI="$( cat /etc/ff/configuration/agent_uri )"
      # Store "agent" to proper unified place for secrets, so we don't have to look for it in random places again next time.
      if [ ! -z "${AGENT_URI}" ]; then
        set_secret agent_uri "${AGENT_URI}"
        echo "${AGENT_URI}"
        return
      fi
    fi

    # Case: We are on a legacy control server in Amazon
    for environment in production staging development
    do
        ENVPATH="${AGENT_HOME_DIR}/.control/environment/${environment}"
        if [ -e "${ENVPATH}" ]; then
            VALUE=$( grep -i "^${KEY}=" ${ENVPATH}/* | cut -d= -f2 | head -1 )
            if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
                echo ${VALUE}
                [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
                return
            fi
        fi
    done

    [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
    return 1
}
export -f get_secret

###############################################################################
# Utility function
function set_secret {
    # Preserve current xtrace state
    if is_shell_attribute_set x; then
      XTRACE_WAS_ENABLED=true
    fi

    set  +x # Disble xtrace to avoid priting secrets
    SECRET_DIRECTORY="${AGENT_HOME}/secrets"
    mkdir -p "${SECRET_DIRECTORY}"
    URI="${1}"
    SECRET="${2}"
    if [ -z "${SECRET}" ]; then
        [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
        return 1
    fi
    if [ -z "${URI}" ]; then
        [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
        return 1
    fi
    echo "${SECRET}" >"${SECRET_DIRECTORY}/${URI}"
    
    [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
    

    return 0
}
export -f set_secret

###############################################################################
# Utility function
#
# The set_state() function require "${AGENT_HOME}" to be set to non-empty string.
#
# Note: each call to "set_state()" will also generate a JSON wich will be published
# by calling "publish_message()".
#
function set_state {
  # Preserve current xtrace state
  if is_shell_attribute_set x; then
    XTRACE_WAS_ENABLED=true
  fi

  set  +x # Disble xtrace to avoid priting secrets

  # Get 2 arguments: state and value
  STATE="${1}"
  VALUE="${2}"
  
  # Make sure "${AGENT_HOME}" is not empty
  if [ -z "${AGENT_HOME}" ]; then
      error "Can not set state. AGENT_HOME variable not defined. State would have been set to ${STATE}=${VALUE}"
      [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
      return 1
  fi

  STATE_DIR="${AGENT_HOME}/state"

  # Make state directory (with -p safe to call even if directory exists)
  if mkdir -p "${STATE_DIR}"; then
    # Define state filename
    STATE_FILE="${STATE_DIR}/${STATE}"

    # Write value into the file
    echo "${VALUE}" >"${STATE_FILE}"

    # Check if writing into the file return good exit code
    if [ ${?} -ne 0 ]; then
        # Report an error, resotre trace and return error code (1)
        error "Can not set state. State file ${STATE_FILE} can not be written to. State would have been set to ${STATE}=${VALUE}"
        [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
        return 1
    fi

  else
    # mkdir failed
    error "Can not set state. State directory ${STATE_DIR} can not be created. State would have been set to ${STATE}=${VALUE}"
    [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
    return 1
  fi
  
  # ------------------ Build JSON object "state/change" and send to FF_HOST

  # Check if framework API is defined
  if [ "$( is_framework_api_defined )" != "true" ]; then
    # No, the framework API is not defined. Simply return, we're done.
    [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
    # Return with success code 0
    return 0
  fi

  # Get current epoch time
  TIMESTAMP_EPOCH_MS="$( get_epoch_ms )"

  # If state value contains: success|running, then: "is_success": true
  # else
  #   if state value contains: error|fail|'', then "is_error": true
  # else
  #   don't include neither "is_success" nor "is_error".
  IS_SUCCESS_OR_IS_ERROR=''
  if [[ "${VALUE}" =~ success|running ]]; then
    IS_SUCCESS_OR_IS_ERROR='"is_success": true,'
  else
    if [[ "${VALUE}" == '' || "${VALUE}" =~ error|fail ]]; then
      IS_SUCCESS_OR_IS_ERROR='"is_error": true,'
    fi
  fi

  # Get previous "old" state value
  PREVIOUS_STATE_JSON=""
  PREVIOUS_STATE_VALUE="$( cat ${STATE_FILE} )"
  # Only include "old_state" property if it is not-empty string
  if [ "${PREVIOUS_STATE_VALUE}" != "" ]; then
    PREVIOUS_STATE_JSON="\"previous_state\": \"${PREVIOUS_STATE_VALUE}\","
  fi

  # Compose "state/chate" JSON and pipe it to publish_message()
  # Note: we POST "state/change" JSON to ff_host. (from portal to self, from 'traffic generator' to portal, from 'inside docker' to (agent?)).
  TMP_UUID="$( uuidgen )"
  MIME_TYPE="state/change"
  STATE_ID="$( basename ${STATE_FILE} )"
  (
    cat <<- EOF
{
  "mime_type": "${MIME_TYPE}",
  "uri_template": "/set_environment/[mime_type]/id/[id]/[uuid]",
  "uri": "${NAMESPACE}::/set_environment/${MIME_TYPE}/id/${STATE_ID}/${TMP_UUID}",
  "uuid": "${TMP_UUID}",
  "id": "${STATE_ID}",
  "state": "${VALUE}",
  ${PREVIOUS_STATE_JSON}
  ${IS_SUCCESS_OR_IS_ERROR}
  "timestamp_epoch_ms": ${TIMESTAMP_EPOCH_MS},
  "agent_uri": "${AGENT_URI}",

  "is_event": true,
  "event_type": "set_environment",
  "source": "set_environment",
  "hostname": "${HOSTNAME}",
  "ff_host": "${FF_HOST}",

  "namespace": "${NAMESPACE}",
  "organization": "${ORGANIZATION}",
  "created_by": {
    "mime_type": "identity/statement",
    "user_id": $( id -u ${BEST_USER_TO_RUN_AS} ),
    "username": "${BEST_USER_TO_RUN_AS}"
  },
  "security_object_policy": {
    "mime_type": "security/object_policy",
    "schema_version": "ff20170505",
    "policy_language": "ff",
    "scope": {
      "can_read": "organization",
      "can_write": "system",
      "can_delete": "system"
    }
  }
}
EOF
) | publish_message

  [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)

  # Return with success code 0
  return 0
}
export -f set_state

###############################################################################
# Function get_state() allows to get state set (by string name).
# Return value:
#   - if state found by given state name, print its value to standard output and return code 0
#   - if state not found, print nothing into standard output and return code 1
#
function get_state {
  # Preserve current xtrace state
  if is_shell_attribute_set x; then
    XTRACE_WAS_ENABLED=true
  fi

  set  +x # Disble xtrace to avoid priting secrets

  # Get 1 argument: state name
  STATE="${1}"
  
  # Make sure "${AGENT_HOME}" is not empty
  if [ -z "${AGENT_HOME}" ]; then
      error "Can not set state. AGENT_HOME variable not defined. State would have been set to ${STATE}=${VALUE}"
      [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
      return 1
  fi

  # Construct path to the state file
  STATE_DIR="${AGENT_HOME}/state"
  STATE_FILE="${STATE_DIR}/${STATE}"

  # Check if state file exists
  if [ -f "${STATE_FILE}" ]; then
    # State file found, try to print it's content and preserve result code
    VALUE="$( cat "${STATE_FILE}" )"
    EXIT_CODE=$?
    # Print value to standard output
    echo -n "${VALUE}"
    [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
    return $EXIT_CODE
  else
    # Error: state file not found. Restore xtrace and eturn code 1
    [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
    return 1
  fi
}
export -f get_state

###############################################################################
# Utility function
function generate_strong_password {
    # Works on Linux and Mac
    # Makes password 16 characters long
    dd if=/dev/urandom count=1 2> /dev/null | uuencode -m - | sed -ne 2p | cut -c-16
}
export -f generate_strong_password

###############################################################################
#
# Figure out environment - where are we?
# Function sets secrets (by set_secret f-n calls), which stores them under ${AGENT_HOME_DIR}/ff_agent/secrets/ folder.
# Function also sets corresponding environment variables:
#     - is_container,
#     - is_portal,
#     - is_local,
#     - is_traffic_generator
#     - agent_uri
#     - ff_host
#     - namespace
#     - organization
#     - ff_api_username
#     - ff_api_password
#
# Note: The discover_environment() step must check if the above variables are set (exist in environment),
# if not, then it must check those by the "get_secret()". This step discovers values (no "mkdir" or any other actions taken).
#
#
# Dependencies:
#    - CONTENT_URL variable must be set either by "set_secrets" or in environment variable
#    - uuidgen must be installed (used to generate AGENT_URI)
#
function discover_environment {

  ######################################################################
  # Preserve current xtrace state
  if is_shell_attribute_set x; then
    local XTRACE_WAS_ENABLED=true
  fi

  ######################################################################
  # Choose user, agent home and make sure agent home folder exists
  #
  # Choose proper user to run as create "ff_agent" folder (known as ${AGENT_HOME}).
  # The proper user is not root but user with sudo that can install packages.
  # We need to choose_ff_agent_home before we can set/get secrets.
  # This sets some of environment variables: BEST_USER_TO_RUN_AS, AGENT_HOME_DIR, AGENT_DIR_NAME, AGENT_HOME.
  # Also creates AGENT_HOME directory.
  choose_ff_agent_home || { error "failed_to_choose_ff_agent_home"; return 1; }
  ensure_agent_home_exists || { error "failed_to_ensure_agent_home_exists"; return 1; }

  ######################################################################
  # CONTENT_URL: check if CONTENT_URL is set (non-empty), else error out.
  # Note: only after "choose user" is complete can we reliably set_secret()
  if [ -z "${CONTENT_URL}" ]; then
    # The CONTENT_URL variable is not set or empty. Try to retrieve it from stored secrets.
    CONTENT_URL=$( get_secret "content_url" )
    
    # Make sure CONTENT_URL is now not empty or error out.
    ensure_variable_not_empty 'CONTENT_URL' || { return 1; }  # Note: the error(details) was already reported by ensure_variable_not_empty()
    
    # Export newly retrieved value
    export CONTENT_URL
  fi
  # Store/update CONTENT_URL value
  set_secret content_url "${CONTENT_URL}"

  ######################################################################
  # Get AGENT_URI or generate a new one.
  discover_optional_environment_variable "AGENT_URI" || { return 1; }
  
  # Check if variable already set. If not set - generate it
  if [ -z "${AGENT_URI}" ]; then
      # Before using "uuidgen" we need to make sure it is installed (is part of 'uuid-runtime' package)
      [ "$(which uuidgen)" != "" ] || { assert_clean_exit apt_update; assert_clean_exit apt_install uuid-runtime; }
      AGENT_URI="/agent/agent_guid/$( uuidgen )"
  fi
  
  # set_secret() only if not empty
  [ ! -z "${AGENT_URI}" ] && { set_secret agent_uri "${AGENT_URI}"; }

  ######################################################################
  # FF_HOST: FF_HOST will be set to legacy control hostname if this is a control.
  discover_optional_environment_variable "FF_HOST" || { return 1; }

  # Check if variable already set. If not set - generate it
  [ -z "${FF_HOST}" ] && { export FF_HOST="$( hostname )"; }
  
  # set_secret() only if not empty
  [ ! -z "${FF_HOST}" ] && { set_secret ff_host "${FF_HOST}"; }  
  
  # ######################################################################
  # # Discover set of "ff environment" variables
  # discover_ff_environment || { set_state "${FUNCNAME[0]}" "failed_to_discover_ff_environment"; return 1; }

  [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)

  # Note: we need explicitly return zero code here since the previous test for XTRACE_WAS_ENABLED might return false then f-n return 1
  return 0
}
export -f discover_environment

# ###############################################################################
# #
# function discover_ff_environment {
  
#     # Define 2 lists of variable names and default values: required and optional.
#     # It creates a local variable (only seen in scope of current f-n)
#     declare -A REQUIRED_VARIABLES
#     # REQUIRED_VARIABLES[FF_HOST]=''
#     # REQUIRED_VARIABLES[FF_PORT]='443'
#     # REQUIRED_VARIABLES[FF_PROTOCOL]='https'

#     declare -A OPTIONAL_VARIABLES
#     OPTIONAL_VARIABLES[FF_HOST]=''
#     OPTIONAL_VARIABLES[FF_PORT]='443'
#     OPTIONAL_VARIABLES[FF_PROTOCOL]='https'
#     OPTIONAL_VARIABLES[FF_API_USERNAME]=''
#     OPTIONAL_VARIABLES[FF_API_PASSWORD]=''
#     OPTIONAL_VARIABLES[FF_API_TOKEN]=''
#     OPTIONAL_VARIABLES[FF_PROXY_HOST]=''
#     OPTIONAL_VARIABLES[FF_PROXY_PORT]=''
#     OPTIONAL_VARIABLES[FF_PROXY_PROTOCOL]=''
#     OPTIONAL_VARIABLES[FF_PROXY_USERNAME]=''
#     OPTIONAL_VARIABLES[FF_PROXY_PASSWORD]=''

#     # Discover required variables
#     for NAME in ${!REQUIRED_VARIABLES[@]}; do
#         # Check NAME is not empty
#         [ -z "${NAME}" ] && { continue; }
#         # Get default value and call discovery f-n
#         local DEFAULT_VALUE="${REQUIRED_VARIABLES[${NAME}]}"
#         discover_required_environment_variable "${NAME}" "${DEFAULT_VALUE}" || { return 1; }
#     done

#     # Discover optional variables
#     for NAME in ${!OPTIONAL_VARIABLES[@]}; do
#         # Check NAME is not empty
#         [ -z "${NAME}" ] && { continue; }
#         # Get default value and call discovery f-n
#         local DEFAULT_VALUE="${OPTIONAL_VARIABLES[${NAME}]}"
#         discover_optional_environment_variable "${NAME}" "${DEFAULT_VALUE}" || { return 1; }
#     done
# }
# export -f discover_ff_environment

###############################################################################
#
# F-n takes 2 arguments:
#    - environment variable name (must be not empty)
#    - default value (can be blank if no default value set)
#
# F-n checks:
#    - if such variable already exists function exit with no changes to environment
#    - if no such variable exists f-n tries to get previously stored value by calling "get_secret ${NAME}" and export this value (if found)
#    - if no value found on previous steps, then f-n exports this variable with ${DEFAULT_VALUE} (only if default value is not blank)
#
# Return: 0 on success, any other code on error
#
function discover_optional_environment_variable {
  local NAME="$1"
  local DEFAULT_VALUE="$2"

  # Check inputs: NAME can be empty
  [ -z "${NAME}" ] && { return 1; }

  # Check if such environment already defined (bash 4.2+ around 2011)
  if [[ -v "${NAME}" ]]; then
      # Variable '${NAME}' is already defined (has DEFAULT_VALUE: '${!NAME}').
      return 0
  fi

  # Try to get value by "get_secret()"
  local RESTORED_VALUE=$( get_secret "${NAME}" )
  if [ ! -z "${RESTORED_VALUE}" ]; then
      # Got non-empty value, use it to export variable
      export "${NAME}"="${RESTORED_VALUE}"
      return 0
  fi

  # Variable not yet defined, define it
  if [ ! -z "${DEFAULT_VALUE}" ]; then
      export "${NAME}"="${DEFAULT_VALUE}"
      return 0
  fi

  # Case: can't find variable value neither from "get_secret()" nor from "DEFAULT_VALUE". Not an error.
  return 0
}
export discover_optional_environment_variable

###############################################################################
#
# F-n discover_required_environment_variable is similar to discover_optional_environment_variable, but after an attempt
# to discover variable it checks if the value was actually found/set and if not, then error out.
#
function discover_required_environment_variable {
  local NAME="$1"
  local DEFAULT_VALUE="$2"

  # Check inputs: NAME can be empty
  [ -z "${NAME}" ] && { return 1; }

  # Try to discover
  discover_optional_environment_variable "${NAME}" "${DEFAULT_VALUE}"

  # Check: must be discovered, otherwise error out
  if [[ ! -v "${NAME}" ]]; then
      # Variable '${NAME}' is not defined, but required. Return an error.
      return 1
  fi

  return 0
}


###############################################################################
#
# discover_os() tries to identify operating system type/version and return it as a string.
# In case of error it will return string: "unknown"
#
function discover_os {
    
    local OS_FAMILY="unknown"

    # Detect the platform based on "OSTYPE" variable
    case "${OSTYPE}" in
    darwin*)  OS_FAMILY="macos" ;; 
    linux*)   OS_FAMILY="linux" ;;
    linux-gnu*)   OS_FAMILY="linux" ;;
    bsd*)     OS_FAMILY="bsd" ;;
    msys*)    OS_FAMILY="windows" ;;
    cygwin*)  OS_FAMILY="windows" ;;
    *)        OS_FAMILY="unknown" ;;  # Failed to id OS, this is not an error yet, we have 2nd attpempt (see below).
    esac

    # If OS_FAMILY still not set, try to detect the platform based on "uname" output
    if [ "${OS_FAMILY}" == "unknown" ]; then
        OS="`uname`"
        case ${OS} in
        'Linux') OS_FAMILY='linux' ;;
        'FreeBSD') OS_FAMILY='bsd' ;;
        'WindowsNT') OS_FAMILY='windows' ;;
        'Darwin')  OS_FAMILY='macos' ;;
        #'AIX') OS_FAMILY='aix' ;;
        *) ;;
        esac
    fi

    echo "${OS_FAMILY}"
}
export -f discover_os

###############################################################################
#
# Function takes the only parameter: REST-API "call" and makes https GET request: https://${FF_HOST}${CALL}
#
# Usage example:  ff_api_get "/admin/organizations"
#
function ff_api_get {
    CALL="${1}"
    if [ "${CALL}" == "" ]; then
        return 1
    fi

    if [ "${FF_API_USERNAME}" == "" ]; then
        return 1
    fi

    if [ "${FF_API_PASSWORD}" == "" ]; then
        return 1
    fi

    if [ "${FF_HOST}" == "" ]; then
        return 1
    fi

    # Run command, capture server response as ${RESULT} and curl exit code as ${STATUS}
    RESULT=$( curl -s --retry 5 -u "${FF_API_USERNAME}:${FF_API_PASSWORD}" https://${FF_HOST}${CALL} )
    STATUS=${?}

    if [ "${STATUS}" != "0" ]; then
        return ${STATUS}
    fi

    if [[ ${RESULT} =~ (^Cannot GET) ]]; then
        return 1
    fi

    if [[ ${RESULT} =~ (^.*"mime_type".+"rest/error") ]]; then
        return 1
    fi

    echo ${RESULT}
    return 0
}
export -f ff_api_get

###############################################################################
#
# Function publish_message() takes JSON payload, wraps it into the message and posts JSON to the FF_HOST.
#
# Function returns 0 upon successfully sending POST to FF_HOST, any other code otherwise.
#
# Usage example:
#   echo '{"a": 1, "b": true}' | publish_message
#   cat  "/path/to/file.json"  | publish_message
#
function publish_message {

    # Preserve current xtrace state
    if is_shell_attribute_set x; then
      XTRACE_WAS_ENABLED=true
    fi

    set  +x # Disble xtrace to avoid priting secrets

    # Read piped json
    INPUT_JSON=`cat`

    # Check inputs
    CONTROL_API_USER=$( get_secret control_api_user )
    if [ "${CONTROL_API_USER}" == "" ]; then
      [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
      # error: CONTROL_API_USER is missing
      # can't use set_state here otherwize will fall into recursive loop
      return 1
    fi

    CONTROL_API_PASSWORD=$( get_secret control_api_password )
    if [ "${CONTROL_API_PASSWORD}" == "" ]; then
      [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
      # error: CONTROL_API_PASSWORD is missing
      # can't use set_state here otherwize will fall into recursive loop
      return 1
    fi

    if [ "${INPUT_JSON}" == "" ]; then
      [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
      # error: INPUT_JSON is missing
      return 1
    fi

    if [ "${FF_HOST}" == "" ]; then
      [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
      # error: FF_HOST is missing
      return 1
    fi

    MESSAGE_UUID="$( uuidgen )"
    if [ "${MESSAGE_UUID}" == "" ]; then
      [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
      # error: failed to generate MESSAGE_UUID
      return 1
    fi

    TRANSACTION_ID="$( uuidgen )"
    if [ "${TRANSACTION_ID}" == "" ]; then
      [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)
      # error: failed to generate TRANSACTION_ID
      return 1
    fi

    CURL_INSTALLED_PATH="$( which curl )"
    if [ "${CURL_INSTALLED_PATH}" == "" ]; then
      log "WARNING: curl is not yet isntalled. Skppping publishing JSON: ${INPUT_JSON}"
      return 0
    fi

    # Wrap input JSON into the MESSAGE
    MESSAGE=$(
      # Part 1/3: headers and start of payload
      cat <<- EOF
     {
        "uri": "/organization/${ORGANIZATION}/delivery/message/${MESSAGE_UUID}",
        "mime_type": "delivery/message",
        "header": {
          "mime_type": "delivery/request_header",
          "transaction_id": "${TRANSACTION_ID}",
          
          ${HAS_ERRORS_ELEMENT}
          
          "from": "/service/set_environment/instance/${UUID}",
          "to":"/service/storage"
        },
        "payload": [
EOF
      # Part 2/3: payload
      echo "${INPUT_JSON}"

      # Part 3/3: footer: closing payload array and message envelop
      cat <<- EOF
        ]
      }
EOF
    )

    # Run command, capture server response as ${RESULT} and curl exit code as ${STATUS}
    # TODO: why "https://${FF_HOST}/service/delivery" endpoint return "201 Created", but JSON isn't stored to DB? Does it have to me a message (not just a body)?
    RESULT=$(
      curl \
        --silent   \
        --retry 5    \
        --request POST \
        --header "Content-Type: application/json" \
        --data "${MESSAGE}" \
        --user "${CONTROL_API_USER}:${CONTROL_API_PASSWORD}" \
        https://${FF_HOST}/
    )
    STATUS=${?}

    [ "${XTRACE_WAS_ENABLED}" == "true" ] && set  -x  # Restore xtrace state (only  if it was enabled before)

    # Check result
    if [ "${STATUS}" != "0" ]; then
        return ${STATUS}
    fi

    # Even if curl succeed, check some edge cases, when server replied with some JSON error
    if [[ ${RESULT} =~ (^Cannot GET) ]]; then
        return 1
    fi

    if [[ ${RESULT} =~ (^.*"mime_type".+"rest/error") ]]; then
        return 1
    fi

    # Return success
    return 0
}
export -f publish_message

###############################################################################
# Utility function f
# Search recursively from current location for files or directories starting with a prefix prefix, case insensitive
# @param $1 string package name
# @param $2 array  package list to append
# @return  Success if value exists, Failure otherwise
# Usage: f prefix
# Example: f index  # Will show all files or directories starting with 'index'
function f {
    FILE_PREFIX="${1}"
    if [ "${FILE_PREFIX}" != "" ]; then
        find . -iname "${FILE_PREFIX}*"
        return $?
    else
        echo "Find files with prefix, starting from current working directory down recursively." 1>&2
        echo "Usage: f index" 1>&2
        return 1
    fi
}

###############################################################################
# Utility function s
# Search from current directory for files containing keyword (case insensitive)
# Ignores node_modules directory
# @param $1 pattern
# @return  Success if keyword exists, Failure otherwise
# Usage: s pattern
function s {
#!/bin/bash -
    GREP_OPTIONS="--color=always"
    PATTERN="${1}"
    if [ "${PATTERN}" != "" ]; then
        find . -name "*" -type f -not -path "*node_modules*" -exec grep -i --text --line-number -H "${PATTERN}" {} \;
        return $?
    else
        echo "Search files in a subtree for a regex. Case insensitive." 1>&2
        echo "Usage: s pattern" 1>&2
        return 1
    fi
}

###############################################################################
# Utility function is_set_environment_working() checks if all the aspects of "set_environment"
# are in place and functioning as expected
#
function is_set_environment_working {
  set_state "${FUNCNAME[0]}" "started"

  # Check if all expected environments are in place
  check_all_environment_variables_are_set || { set_state "${FUNCNAME[0]}" "failed_check_check_all_environment_variables_are_set"; return 1; }

  # TODO: check if n / npm / nodejs are installed and path doesn't start with "/usr"
  check_nodejs_installation || { set_state "${FUNCNAME[0]}" "failed_check_check_nodejs_installation"; return 1; }

  # TODO: check docker is installer with >= minimal version

  # TOOD: check if list of required basic packages is installed

  # TODO: instead of "cherry-picking" what to check we should have 1:1 "doer/instaler" and corresponding "checker" functions defined, which we'll call here by list.

  # Return success
  set_state "${FUNCNAME[0]}" "successs"
  return 0
}
export -f is_set_environment_working

###############################################################################
# Utility function check_all_environment_variables_are_set() checks if all the expected environment variables are set
# On success: reuturn 0
# On failure: return nonzero code
#
function check_all_environment_variables_are_set {

  # Define list of expected non-empty variables
  local ALL_EXPECTED_ENVRIONMENT_VARIABLES=(
    # "General" fields
    FF_HOST

    # "Dynamically learned" fields
    BEST_USER_TO_RUN_AS
    AGENT_HOME_DIR
    AGENT_DIR_NAME
    AGENT_HOME
  )

  # Check required environment variables are set
  for VARIABLE_NAME in ${ALL_EXPECTED_ENVRIONMENT_VARIABLES[@]}; do 
    ensure_variable_not_empty "${VARIABLE_NAME}" || { return 1; }    # Note: the error(details) was already reported by ensure_variable_not_empty()
  done
}
export -f check_all_environment_variables_are_set

###############################################################################
#
# Function checks if we have framework API defined by checking if all of the following is set:
#    - FF_HOST
#    - ( FF_API_USERNAME and FF_API_PASSWORDS ) OR ( FF_API_TOKEN )
#
# As a result: functions prints "true" or "false" into std output stream.
# Usage example:
#    if [ "$( is_framework_api_defined )" == "true" ]; then
#       : # yes, the framework API is defined
#    fi
#
function is_framework_api_defined {
  # Print 'false' if FF_HOST not set
  [ -z "${FF_HOST}" ] && { echo 'false'; return; }

  # Print 'true' if both FF_API_USERNAME and FF_API_PASSWORDS are set
  [ ! -z "${FF_API_USERNAME}" ] && [ ! -z "${FF_API_PASSWORDS}" ] && { echo 'true'; return; }

  # Print 'true' if FF_API_TOKEN is set
  [ ! -z "${FF_API_TOKEN}" ] && { echo 'true'; return; }

  # Print 'false' in all other cases
  echo 'false'
  return
}
export -f is_framework_api_defined

###############################################################################
# Utility function check_nodejs_installation() checks if nodejs is installed under right path (TODO: and right version)
# On success: reuturn 0
# On failure: return nonzero code
#
function check_nodejs_installation {

  # Let's run all the checks and collect all the found errors into associative array (key = name of the check, value = error code)
  declare -A CHECK_CODES
  declare -A ERRORS

  # Check nodejs is installed
  CHECK_NAME='is_nodejs_installed'
  WHICH_NODE="$( which node )"
  [ "${WHICH_NODE}" != "" ] || {
    ERROR_CODE="error_check_nodejs_installation_nodejs_not_installed"
    set_state "${FUNCNAME[0]}" "${ERROR_CODE}";
    ERRORS[${CHECK_NAME}]="${ERROR_CODE}"; 
  }

  # Check nodejs is not installed under /usr
  CHECK_NAME='is_nodejs_installed_into_right_path'
  [[ "${WHICH_NODE}" =~ ^/usr/ ]] && { 
    ERROR_CODE="error_check_nodejs_installation_wrong_installation_dir"
    set_state "${FUNCNAME[0]}" "${ERROR_CODE}";
    ERRORS[${CHECK_NAME}]="${ERROR_CODE}"; 
  }

  # Check npm is installed
  CHECK_NAME='is_npm_installed'
  WHICH_NPM="$(which npm)" 
  [ "${WHICH_NPM}" != "" ] || { 
    ERROR_CODE="error_check_nmp_installation_nodejs_not_installed"
    set_state "${FUNCNAME[0]}" "${ERROR_CODE}"; 
    ERRORS[${CHECK_NAME}]="${ERROR_CODE}";
  }

  # Check nodejs is not installed under /usr
  CHECK_NAME='is_npm_installed_into_right_path'
  [[ "${WHICH_NPM}" =~ ^/usr/ ]] && { 
    ERROR_CODE="error_check_npm_installation_wrong_installation_dir"
    set_state "${FUNCNAME[0]}" "${ERROR_CODE}";
    ERRORS[${CHECK_NAME}]="${ERROR_CODE}"; 
  }

  # Get expected nodejs version
  CHECK_NAME='get_expected_nodejs_version'
  local EXPECTED_VERSION="$( get_expected_nodejs_version )"
  [ -z "${EXPECTED_VERSION}" ] && { 
    ERROR_CODE="failed_to_get_expected_nodejs_version"
    set_state "${FUNCNAME[0]}" "${ERROR_CODE}";
    ERRORS[${CHECK_NAME}]="${ERROR_CODE}";
  }

  # Get actual nodejs version
  CHECK_NAME='get_actual_nodejs_version'
  local ACTUAL_VERSION="$( node --version )"
  [ -z "${ACTUAL_VERSION}" ] && {
    ERROR_CODE="failed_to_get_actual_nodejs_version"
    set_state "${FUNCNAME[0]}" "${ERROR_CODE}"; 
    ERRORS[${CHECK_NAME}]="${ERROR_CODE}";
  }

  # Compare expected vs actual nodejs versions
  CHECK_NAME='is_nodejs_right_versions'
  if [ "${EXPECTED_VERSION}" != "${ACTUAL_VERSION}" ]; then
    # Version mismatch
    ERROR_CODE="error_mismatching_nodejs_versions"
    set_state "${FUNCNAME[0]}" "${ERROR_CODE}"; 
    ERRORS[${CHECK_NAME}]="${ERROR_CODE}";
  fi

  # # Iterate all errors
  # for KEY in "${!ERRORS[@]}"; do
  #   echo "  \"${KEY}\": \"${ERRORS[${KEY}]}\","
  # done
  
  # List of all the checks done with their statuses
  if [ ${#ERRORS[@]} -eq 0 ]; then
    # No errors
    return 0
  else
    # We found some errors
    return 1
  fi

}
export -f check_nodejs_installation

###############################################################################
# Function prints into standard output the expected version of nodejs.
# We use it during installation and to check installed "set environment" project.
function get_expected_nodejs_version {
  echo 'v16.13.0'
}
export -f get_expected_nodejs_version

###############################################################################
#
# Function installs docker. It takes 1 argement "minimum version", if not provided,
# then by default version 19 will be used.
#
# Supports Ubuntu 16.04, 18.04, 20.04
function install_docker {

    set_state "${FUNCNAME[0]}" 'started'

    # Check required environment variables are set
    # Check required environment variables
    if [ -z "${BEST_USER_TO_RUN_AS}" ]; then
        set_state "${FUNCNAME[0]}" "error_environment_not_set_best_user_to_run_as"
        return 1
    fi

    # Take MINIMUM_VERSION argument, if empty, then set default value
    MINIMUM_VERSION="${1}"
    if [ -z "${MINIMUM_VERSION}" ]; then
        MINIMUM_VERSION=19
    fi

    # Check if docker is installed and has version >= minimally required
    ACTUAL_VERSION="$( get_installed_docker_version )"
    if [ ! -z "${ACTUAL_VERSION}" ] && [ "${ACTUAL_VERSION}" -ge "${MINIMUM_VERSION}" ]; then
        set_state "${FUNCNAME[0]}" "no_action_already_installed"
        return 0
    fi

    # OK We install since we don't have the minimum version, or docker is not installed

    # Get ID, RELEASE and DISTRO and verify the values are actually set
    ID=$( get_lsb_id ) || { set_state "${FUNCNAME[0]}" "failed_to_get_lsb_id"; return 1; } # Ubuntu
    [ "${LSB_ID}" == "" ] && { set_state "${FUNCNAME[0]}" "failed_to_get_lsb_id"; return 1; } # Ubuntu

    RELEASE=$( get_lsb_release ) || { set_state "${FUNCNAME[0]}" "failed_to_get_lsb_release"; return 1; }  # 18.04, 20.04, ...
    [ "${RELEASE}" == "" ] && { set_state "${FUNCNAME[0]}" "failed_to_get_lsb_release"; return 1; }

    DISTRO=$( get_lsb_codename ) || { set_state "${FUNCNAME[0]}" "failed_to_get_lsb_codename"; return 1; }  # bionic, focal, ...
    [ "${DISTRO}" == "" ] && { set_state "${FUNCNAME[0]}" "failed_to_get_lsb_codename"; return 1; } 

    ARCHITECTURE=$( get_hardware_architecture ) || { set_state "${FUNCNAME[0]}" "error_getting_hardware_architecture"; return 1; }

    # Only Ubuntu for now
    if [ "${LSB_ID}" != "Ubuntu" ]; then
        set_state "${FUNCNAME[0]}" "error_docker_install_unsupported_operating_system"
        return 1
    fi

    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
    [ "${?}" != "0" ] && { set_state "${FUNCNAME[0]}" "failed_to_add_gpg_key"; return 1; }

    sudo add-apt-repository "deb [arch=${ARCHITECTURE}] https://download.docker.com/linux/ubuntu ${DISTRO} stable"
    [ "${?}" != "0" ] && { set_state "${FUNCNAME[0]}" "failed_to_add_repository"; return 1; }

    apt_update

    apt_install docker-ce || { set_state "${FUNCNAME[0]}" "failed_to_install_docker_ce"; return 1; }
    apt_install docker-compose || { set_state "${FUNCNAME[0]}" "failed_to_install_docker_compose"; return 1; }
    # containerd is available as a daemon for Linux and Windows. It manages the complete container lifecycle of its host system, from image transfer and storage to container execution and supervision to low-level storage to network attachments and beyond.
    apt_install containerd.io || { set_state "${FUNCNAME[0]}" "failed_to_install_containerd_io"; return 1; }

    # Add ourselves as a user to be able to run docker
    # XXX - todo, the docker group might not actually exist and should be checked.
    # We might not have sudo, so we should request command to be run.
    GROUP="docker"
    # Check if user is in this group. If not, add them
    if [ ! is_user_in_group "${BEST_USER_TO_RUN_AS}" "${GROUP}" ]; then
      # Not in group
      sudo usermod -aG "${GROUP}" "${BEST_USER_TO_RUN_AS}"
      if [ "${?}" != "0" ]; then set_state "${FUNCNAME[0]}" "failed_to_modify_docker_user_group"; return 1; fi
      # Now check that we actually are in the group. This will work in current shell because it reads the groups file directly
      [ ! is_user_in_group "${BEST_USER_TO_RUN_AS}" "${GROUP}" ] || { set_state "${FUNCNAME[0]}" "failed_postcondition_user_in_group"; return 1; }
    fi

    # Postcondition checks
    # Verify docker is properly set up
    # Note we are running via sudo, and if we added user to the ${GROUP} then it won't be applied in this shell.
    set_secret docker_release "$( sudo --user=${BEST_USER_TO_RUN_AS} docker --version )" || { set_state "${FUNCNAME[0]}" "failed_to_run_docker_to_get_release"; return 1; }
    set_secret docker_compose_release "$( sudo --user=${BEST_USER_TO_RUN_AS} docker-compose --version )" || { set_state "${FUNCNAME[0]}" "failed_to_run_docker_compose_to_get_release"; return 1; }

    # Check if installed docker version is less than minimally required
    if [ "$( get_installed_docker_version )" -lt "${MINIMUM_VERSION}" ]; then
    	set_state "${FUNCNAME[0]}" "failed_to_install_did_not_pass_version_check"
	    return 1
    fi

    set_state "${FUNCNAME[0]}" 'success'
}
export -f install_docker
