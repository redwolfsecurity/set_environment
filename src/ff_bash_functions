#!/usr/bin/env bash

# This file is a collection of useful bash functions, which we want to source for all
# users and other scripts.
#
#
# Note: we "export -f" all the functions
# Or alternatively we could:
# declare -x -f log
# See this discussion for these and other ways to solve bash functions visibility (note also ~/.bashrc and ~/.profile way to inject f-ns for all users)
# https://stackoverflow.com/questions/1885871/exporting-a-function-in-shell
# https://unix.stackexchange.com/questions/22796/can-i-export-functions-in-bash

# Table of contents generated by function help_toc():
#
## BEGIN USAGE/HELP FUNCTION
#    - ask_for_value 
#    - ask_for_yn 
#    - command_exists 
#    - file_toc 
#    - help 
#    - help_toc 
## END USAGE/HELP FUNCTION
## BEGIN APT WRAPPER FUNCTIONS
#    - apt_dist_upgrade 
#    - apt_install 
#    - apt_list 
#    - apt_reinstall 
#    - apt_remove 
#    - apt_update 
#    - apt_upgrade 
## END APT WRAPPER FUNCTIONS
## BEGIN UTILITY FUNCTIONS: STRINGS
#    - in_array 
#    - index_of 
#    - parse_github_repository_url 
#    - trim_slash 
## END UTILITY FUNCTIONS: STRINGS
## BEGIN UTILITY FUNCTIONS: FILE
#    - assert_cd 
#    - assert_makedir 
#    - does_file_have_eol_at_the_end 
#    - f 
#    - file_contains_pattern 
#    - find_file_owner_in_all_packages 
#    - find_file_owner_in_installed_packages 
#    - get_by_url 
#    - glob_matches 
#    - inject_into_file 
#    - is_writable 
#    - path_to_absolute_path
#    - remove_all_lines_by_regexp 
#    - replace_all_lines_by_regexp 
#    - s 
#    - truncate_file 
## END UTILITY FUNCTIONS: FILE
## BEGIN UTILITY FUNCTIONS: LOGGING / PROCESS CONTROl
#    - abort 
#    - assert_clean_exit 
#    - banner 
#    - error 
#    - log 
#    - step 
#    - successful_exit 
#    - warning 
## END UTILITY FUNCTIONS: LOGGING / PROCESS CONTROl
## BEGIN UTILITY FUNCTIONS: TERMINAL / SHELL
#    - set_bash_echo_on 
#    - set_bash_echo_off 
#    - get_bash_echo_setting 
#    - set_bash_echo_setting 
#    - ensure_variable_defined 
#    - ensure_variable_not_empty 
#    - is_shell_attribute_set 
#    - is_shell_option_set 
#    - terminal_initialize 
#    - terminal_is_interactive 
#    - terminal_is_tty 
#    - terminal_reset 
## END UTILITY FUNCTIONS: TERMINAL / SHELL
## BEGIN UTILITY FUNCTIONS: PROCESS
#    - is_process_running_as_me 
## END UTILITY FUNCTIONS: PROCESS
## BEGIN UTILITY FUNCTIONS: CONTAINERS
#    - container_name_exists 
#    - docker_cleanup
#    - docker_volumes_to_containers_list
#    - get_installed_docker_version 
#    - is_container_healthy 
#    - is_container_running 
#    - restart_containers 
#    - stop_and_remove_container_by_name 
## END UTILITY FUNCTIONS: DOCKERS
## BEGIN UTILITY FUNCTIONS: STATE/SECRETS
#    - generate_strong_password 
#    - get_secret 
#    - get_state 
#    - set_secret 
#    - set_state 
## END UTILITY FUNCTIONS: STATE/SECRETS
## BEGIN UTILITY FUNCTIONS: USER / GROUPS
#    - can_sudo 
#    - check_group_exists 
#    - create_user 
#    - effectively_root 
#    - get_home_directory_for_user 
#    - get_ppid_cmd 
#    - is_user_in_group 
#    - user_exists 
## END UTILITY FUNCTIONS: USER / GROUPS
## BEGIN DISCOVER FUNTIONS
#    - ff_uuid 
#    - get_best_ff_agent_uri 
#    - get_best_ff_content_url 
#    - get_best_ff_host 
#    - get_best_ff_port 
#    - get_best_namespace 
#    - get_best_organization 
#    - discover_environment 
#    - discover_optional_environment_variable 
#    - discover_os 
#    - discover_required_environment_variable 
#    - get_epoch_ms 
#    - get_hardware_architecture 
#    - get_lsb_codename 
#    - get_lsb_id 
#    - get_lsb_id_downcase 
#    - get_lsb_release 
## END DISCOVER FUNCTIONS
## BEGIN SET ENVIRONMENT FUNCTIONS
#    - check_environment_variables_are_set 
#    - check_ff_agent_bin_is_in_the_path 
#    - check_nodejs_installation 
#    - check_set_get_secret 
#    - check_set_get_state 
#    - get_current_user 
#    - choose_ff_agent_home 
#    - ensure_ff_agent_home_exists 
#    - ff_api_get 
#    - get_expected_nodejs_version 
#    - get_ff_agent_username 
#    - is_framework_api_defined 
#    - is_set_environment_working 
#    - publish_message 
## END SET ENVIRONMENT FUNCTIONS


### BEGIN USAGE/HELP FUNCTION

###############################################################################
# Ask for value and store it in variable
# @param ${1} reference Variable
# @param ${2} string Question
# @param ${3} string Prompt tooltip
# @param ${4} string Default value
# @return  Success (0) if user enter Y, Failure (1)
# Usage:
# SOME_VAR=""
# ask_for_value SOME_VAR "Set value for SOME_VAR" "SOME_VAR="
# ask_for_value SOME_VAR "Update value for SOME_VAR" "SOME_VAR=" "${SOME_VALUE}"
#
function ask_for_value {
    local VALUE=""

    local  __RESULTVAR=${1}
    local QUESTION=${2}
    local TOOLTIP=${3}
    local DEFAULT=${4}

    while [[ -z ${VALUE} ]]
    do
        log "${QUESTION}"
        if [[ -z ${DEFAULT} ]]
        then
            read -p "${TOOLTIP}" VALUE
        else
            read -e -p "${TOOLTIP}" -i "${DEFAULT}" VALUE
        fi
    done

    if [[ "${__RESULTVAR}" ]]; then
        eval ${__RESULTVAR}="'${VALUE}'"
    else
        echo "${VALUE}"
    fi
}
export -f ask_for_value

###############################################################################
# Ask for question and read user input Y/n
# @param ${1} string Question
# @return  Success (0) if user enter Y, Failure (1) on n
# Usage: ask_for_yn "Does vim rox the house?"
#
function ask_for_yn {
    local QUESTION=${1}
    local ANSWER=""

    while [[ ${ANSWER,,} != "y" ]] && [[ ${ANSWER,,} != "n" ]]
    do
        log "${QUESTION}"
        read -p "Answer [Y/n]: " ANSWER
        if [[ -n ${ANSWER} ]] && [[ ${ANSWER,,} == "y" ]]
        then
            return 0
        fi
    done
    return 1
}
export -f ask_for_yn

###############################################################################
# Check if a command exists. A command could be a function, something in path, a direct path to a command
# This will return in stdout the path to the command, and will return 0 if the command exists, otherwise 1
# This is better option than "which" command since it also understands:
#    - aliases
#    - bash functions
#
# Usage examples:
#   Simple if-then check
#      if command_exists tput >/dev/null; then echo "yes, command exists"; fi
#
#   Use with other commands "chained" by &&
#      command_exists tty && tty -s && return 0 || return 1
#
#   Check if return not empty string
#     PM2=$( command_exists pm2 )
#     if [ -z "${PM2}" ]; then  echo "yes, command exists"; fi
#
function command_exists {
  local COMMAND=${1}

  # Force bash to un-hash any previously memorized commands. This will require bash to look it up again.
  # This is for cases where it has 'memoried' a command that has actually been deleted.
  hash -d ${COMMAND} >/dev/null 2>/dev/null
  hash -d $(command -v "${COMMAND}" ) >/dev/null 2>/dev/null

  local COMMAND_RESOLVED=$(command -v "${COMMAND}" )
  local STATUS=${?}

  # Command will return non-zero if command not found
  if [ "${STATUS}" != "0" ]; then
    return 1
  fi

  if [ "${COMMAND_RESOLVED}" == "" ]; then
    return 1
  fi

  # Case: Is this an alias?
  if [[ "${COMMAND_RESOLVED}" =~ ^alias ]]; then
     # If it starts with alias ...= ( e.g. grep is often aliased to something else with options )
     # Then we assume it exists and we let you run the alias
     echo "${COMMAND}"
  else
    # Otherwise we return what we resolved, which might be a bash function, or the path to a command
    echo "${COMMAND_RESOLVED}"
  fi

  return 0

}
export -f command_exists

###############################################################################
# Auxilary function to make bash file "Table of contents" (TOC).
# Usage example:
#    file_toc /path/to/some/bashfile.sh
#
function file_toc {

  # Define path to ff_bash_functions file
  TARGET_FILE="${1}"
  [ ! -f "${TARGET_FILE}" ] && {
    error "error_ff_bash_functions_file_missing"
    return 1
  }

  # Parse ff_bash_functions and generate table of contents
  cat "${TARGET_FILE}" | grep '^### BEGIN\|^### END\|^function' | sed 's/^function /\#    - /g' | sed 's/{//g' | sed 's/###/##/g'
}
export -f file_toc

###############################################################################
# Utility help function
# This will list all the defined bash functions *build in" and our "custom" ones.
function help {
    echo "Builtin functions:"
    typeset -F | cut -d' ' -f3
}
export -f help

###############################################################################
# Utility help function: table of content.
# See also: file_toc()
#
function help_toc {
  set_state "${FUNCNAME[0]}" 'started'

  # Check FF_AGENT_HOME is set
  ensure_variable_not_empty 'FF_AGENT_HOME' || {
    set_state "${FUNCNAME[0]}" 'error_ensure_variable_not_empty_ff_agent_home'
    return 1
  }

  # Define path to ff_bash_functions file
  TARGET_FILE="${FF_AGENT_HOME}/git/redwolfsecurity/set_environment/src/ff_bash_functions"
  [ ! -f "${TARGET_FILE}" ] && {
    set_state "${FUNCNAME[0]}" "error_ff_bash_functions_file_missing"
    return 1
  }

  # Parse ff_bash_functions and generate table of contents
  cat "${TARGET_FILE}" | grep '^### BEGIN\|^### END\|^function' | sed 's/^function /\#    - /g' | sed 's/{//g' | sed 's/###/##/g'

  set_state "${FUNCNAME[0]}" 'success'
}
export -f help_toc


### END USAGE/HELP FUNCTION

### BEGIN APT WRAPPER FUNCTIONS

###############################################################################
# Utility wrapper around apt dist-upgrade for safer headless operation
function apt_dist_upgrade {
  set_state "${FUNCNAME[0]}" 'started'
  local APT_COMMAND=dist-upgrade

  #        --force-yes is deprecetaed now.
  #       Force yes; this is a dangerous option that will cause apt to continue without prompting if it is doing something potentially harmful. It should not be used
  #       except in very special situations. Using force-yes can potentially destroy your system! Configuration Item: APT::Get::force-yes. This is deprecated and
  #       replaced by --allow-unauthenticated , --allow-downgrades , --allow-remove-essential , --allow-change-held-packages in 1.1.
  local FORCE_YES="--allow-unauthenticated --allow-downgrades --allow-remove-essential --allow-change-held-packages"

  apt_update  || { set_state "${FUNCNAME[0]}" "failed_to_apt_update"; return 1; }
  apt_upgrade || { set_state "${FUNCNAME[0]}" "failed_to_apt_upgrade"; return 1; }
  sudo DEBIAN_FRONTEND=noninteractive \
    apt-get \
      -yq \
      -o Dpkg::Options::="--force-confdef" \
      -o Dpkg::Options::="--force-confold" \
      ${FORCE_YES} ${APT_COMMAND} || { set_state "${FUNCNAME[0]}" "failed_to_apt_dist_upgrade"; return 1; }

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f apt_dist_upgrade

###############################################################################
# Utility wrapper around apt install for safer headless operation
function apt_install {
  set_state "${FUNCNAME[0]}" 'started'
  PACKAGES=${@}
  APT_COMMAND=install

  for PACKAGE in "${PACKAGES}"
  do
      # Note: we suppress stdout noise (only stderr will still be "visible", but TODO: think of better way to collect evidences insted of just 1 large pile)
      sudo DEBIAN_FRONTEND=noninteractive \
      apt-get \
        -o Dpkg::Options::="--force-confold" \
        -yq \
        --no-install-recommends \
        --no-install-suggests \
        -o Acquire::ForceIPv4=true \
        ${APT_COMMAND} ${PACKAGE} > /dev/null || { set_state "${FUNCNAME[0]}" "failed_to_apt_install"; return 1; }
  done

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f apt_install

###############################################################################
# Utility wrapper to list all the files by given package name (even if package not installed).
# As for reverse checking files from packages apt-file would be the best bet.
#
# Discussion: https://serverfault.com/a/1059513/413686
#
# Usage:
#    apt_list <package name>
#
# Example:
#    apt_list libjansson-dev
#
function apt_list {
  set_state "${FUNCNAME[0]}" 'started'

  # Check inputs:
  local PACKAGE_NAME="${1}"
  if [ "${PACKAGE_NAME}" == "" ]; then
    set_state "${FUNCNAME[0]}" "bad_arguments_missing_package_name"
    return 1
  fi

  # Get package URIs by apt-get download --print-uris
  # Official doc: https://help.ubuntu.com/community/AptGet/Offline/PrintUris
  # apt-get --print-uris
  #  --print-uris : instead of fetching the files to install, their URIs (links to download them) are printed.
  PACKAGE_URI=$( apt-get download \
    -o Dir::Cache::archives="./" \
    --print-uris "${PACKAGE_NAME}"
  )

  # Check errors
  if [ ${?} -ne 0 ]; then
    set_state "${FUNCNAME[0]}" "failed_to_find_package_uris"
    return 1
  fi

  # Try to list files by given package name
  PACKAGE_FILES=$( apt-get download \
    -o Dir::Cache::archives="./" \
    --print-uris "${PACKAGE_NAME}" | awk -F\' '{print $2}' | xargs -I '{}' curl -skL '{}' | dpkg-deb -c /dev/stdin
  )

  # Check we got files list
  if [ "${PACKAGE_FILES}" == "" ]; then
    set_state "${FUNCNAME[0]}" "failed_to_list_package_files"
    return 1
  fi

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f apt_list

###############################################################################
# Utility wrapper around apt reinstall for safer headless operation
function apt_reinstall {
    PACKAGES=${@}
    APT_COMMAND=reinstall

    for PACKAGE in "${PACKAGES}"
    do
        sudo DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${APT_COMMAND} ${PACKAGE}
        if [ ${?} -ne 0 ]; then
            error "Error reinstalling packages: ${PACKAGE}"
            return 1
        fi
    done
    return 0
}
export -f apt_reinstall

###############################################################################
# Utility wrapper around apt_remove for safer headless operation
function apt_remove {
    PACKAGES=${@}
    APT_COMMAND=remove

    for PACKAGE in "${PACKAGES}"
    do
        sudo DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${APT_COMMAND} "${PACKAGE}"
        if [ ${?} -ne 0 ]; then
            error "Error removing packages: ${PACKAGE}"
            return 1
        fi
    done
}
export -f apt_remove

###############################################################################
# Utility wrapper around apt_update for safer headless operation
function apt_update {
    local APT_COMMAND=update

    #        --force-yes is deprecetaed now.
    #       Force yes; this is a dangerous option that will cause apt to continue without prompting if it is doing something potentially harmful. It should not be used
    #       except in very special situations. Using force-yes can potentially destroy your system! Configuration Item: APT::Get::force-yes. This is deprecated and
    #       replaced by --allow-unauthenticated , --allow-downgrades , --allow-remove-essential , --allow-change-held-packages in 1.1.
    local FORCE_YES="--allow-unauthenticated --allow-downgrades --allow-remove-essential --allow-change-held-packages"

    sudo DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${FORCE_YES} ${APT_COMMAND}
    if [ ${?} -ne 0 ]; then
       error "updating packages"
       return 1
    fi
    return 0
}
export -f apt_update

###############################################################################
# Utility wrapper around apt_update for safer headless operation
function apt_upgrade {
    local APT_COMMAND=upgrade

    #        --force-yes is deprecetaed now.
    #       Force yes; this is a dangerous option that will cause apt to continue without prompting if it is doing something potentially harmful. It should not be used
    #       except in very special situations. Using force-yes can potentially destroy your system! Configuration Item: APT::Get::force-yes. This is deprecated and
    #       replaced by --allow-unauthenticated , --allow-downgrades , --allow-remove-essential , --allow-change-held-packages in 1.1.
    local FORCE_YES="--allow-unauthenticated --allow-downgrades --allow-remove-essential --allow-change-held-packages"

    sudo DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confold" -yq -o Acquire::ForceIPv4=true ${FORCE_YES} ${APT_COMMAND}
    if [ ${?} -ne 0 ]; then
       error "Error upgrading packages"
       return 1
    fi
    return 0
}
export -f apt_upgrade

### END APT WRAPPER FUNCTIONS

### BEGIN UTILITY FUNCTIONS: STRINGS

###############################################################################
# Check if a value exists in an array
# @param ${1} mixed  Needle
# @param ${2} array  Haystack
# @return  Success (0) if value exists, Failure (1) otherwise
# Usage: in_array "${needle}" "${haystack[@]}"
# See: http://fvue.nl/wiki/Bash:_Check_if_array_element_exists
#
function in_array {
    local hay needle=${1}
    shift
    for hay; do
        [[ ${hay} == ${needle} ]] && return 0
    done
    return 1
}
export -f in_array

###############################################################################
# Return index or needle in haystack, otherwise 255
# Bash range for return value from fn is (0-255) this is why when I return -1 it's 255
# @param ${1} mixed  Needle
# @param ${2} array  Haystack
# @return  Success (index) if value exists, Failure (255) otherwise
# Usage: index_of "$needle" "${haystack[@]}"
function index_of {
    local NEEDLE=${1}
    declare -a HAYSTACK=("${!2}")
    for i in "${!HAYSTACK[@]}"; do
        if [[ "${HAYSTACK[$i]}" == "${NEEDLE}" ]]; then
            return ${i};
        fi
    done
    return -1;
}
export -f index_of

###############################################################################
#
# Function parses github repository url and allows to extract one of the following parts of it:
#    - protocol
#    - host
#    - owner
#    - project name
#
# Function prints into standard output one of the parsed url components and return code 0 on success
# or code 1 on error (e.g. failed to parse given url or missing arguments).
#
# Usage examples:
#   URL="git://github.com/some-user/my-repo.git"
#   OWNER=$( parse_github_repository_url "${URL}" "OWNER" )
#   if [ ${?} -eq 0 ]; then
#      echo "The ownder of the url '${URL}' is '${OWNER}'."
#   else
#      echo "Error: failed to parse url: '${URL}'." >&2
#   fi
#
#  Expected output:
#    The ownder of the url 'git://github.com/some-user/my-repo.git' is 'some-user'.
#
# Other example:
# URLS=(
#  "git://github.com/some-user/my-repo.git"
#  "https://github.com/some-user/my-repo.git"
#  "git@github.com:some-user/my-repo.git"
#  "git://github.com/some-user/my-repo"
#  "https://github.com/some-user/my-repo"
#  "git@github.com:some-user/my-repo"
# )
#
# for URL in "${URLS[@]}"; do
#     echo "${URL}"
#     parse_github_repository_url "${URL}" "OWNER"
# done
#
function parse_github_repository_url {
  local URL="${1}"
  local KEY="${2}"

  # Check inputs aren't empty
  [ ! -z "${URL}" ] || { return 1; }
  [ ! -z "${KEY}" ] || { return 1; }

  # Define regexp to parse github repository url
  re="^(https|git)(:\/\/|@)([^\/:]+)[\/:]([^\/:]+)\/(.+)(.git)*$"

  # Parse github repository url
  if [[ ${URL} =~ ${re} ]]; then
    PROTOCOL=${BASH_REMATCH[1]}
    # SEPARATOR=${BASH_REMATCH[2]}
    HOST=${BASH_REMATCH[3]}
    OWNER=${BASH_REMATCH[4]}
    PROJECT_NAME=${BASH_REMATCH[5]%.git}
    case "${KEY}" in
      PROTOCOL)
        echo "${PROTOCOL}"
        return 0
        ;;
      HOST)
        echo "${HOST}"
        return 0
        ;;
      OWNER)
        echo "${OWNER}"
        return 0
        ;;
      PROJECT_NAME)
        echo "${PROJECT_NAME}"
        return 0
        ;;
      *)
        # Error: unknown key
        return 1
    esac
  else
    # Failed to find a match.
    return 1
  fi
}
export -f parse_github_repository_url

###############################################################################
# Utility function trim_slash():
#   - Replaces all repeated slashes //[...] with a single slash /
#   - Removes trailing slash unless it is also the leading slash (i.e., the root filepath /)
#
# Function is useful to remove trailing slashes from URL string for example "http://acme.com///" -> "http://acme.com"
#
# More details in this StackOverflow discussion: https://stackoverflow.com/a/69485442/7022062
#
# Some test cases:
#
#   trim_slash "http://acme.com/a/b/c/" "http://acme.com///" "http://acme.com/" "/" "///" "a/" "b/b/" "c/c////"
#
# Expected output:
#       http://acme.com/a/b/c
#       http://acme.com
#       http://acme.com
#       /
#       /
#       a
#       b/b
#       c/c
#
function trim_slash {
  for s; do
    sed -E 's:(^/)?/*$:\1:' <<< "${s}"
  done
}
export -f trim_slash

### END UTILITY FUNCTIONS: STRINGS

### BEGIN UTILITY FUNCTIONS: FILE

###############################################################################
# Usage: assert_cd directory
# Ensures command must exit cleanly (0) else will abort the entire system
function assert_cd {

  # Check first if it is a directory.
  if [ ! -d "${1}" ]; then
     log "ERROR: Can not enter directory \"${1}\" -- it is not a directory."
     abort
  fi

  # Directory exists, now enter it. May fail due to permissions.
  if [ -d "${1}" ]; then
     assert_clean_exit cd "${1}"
  else
     log "ERROR: Can not enter directory \"${1}\""
     log "SUGGEST: check user ID and directory permissions."
     abort
  fi

  return 0
}
export -f assert_cd

###############################################################################
# Usage: assert_makedir directory
# Make directory if it does not exist
function assert_makedir {
  if [ -d "${1}" ]; then
     log "INFO: Directory \"${1}\" exists, skipping creation."
  else
     assert_clean_exit mkdir "${1}"
  fi
  return 0
}
export -f assert_makedir

###############################################################################
# Category: file
# Utility function - checks if given file has "EOL" at the end of the file. It gets the path to the file as the only argument and:
#   - returns value 0 if file has EOL at the end (or file is empty)
#   - returns nonzero value in case file doesn't have EOL at the end
#
# Note: function does not check if file exist and does not return errors (return binary outcome: code 0 = yes, EOL is present or empty file, code 1 = EOL is missing in last line)
#
# Function is used to avoid concatination of more than one name/vale pairs into configuration files (be it yaml or .env files).
#
function does_file_have_eol_at_the_end {
    FILENAME="${1}"

    # Check if file is empty
    if [ ! -s "${FILENAME}" ]; then
        # Note: For our needs (to avoid concatination of name/value lines) we consider empty file as having EOL (i.e. safe to append more name/values)
        # The file is empty.
        # Note: function does_file_have_eol_at_the_end() got empty file.
        # For our needs (to avoid concatination of name/value lines)
        # we consider empty file as having EOL (i.e. safe to append more name/values)
        return 0
    # -z - true if the length of string is zero
    # -n - true if the length of string is nonzero
    elif [ -z "$(tail -c 1 <"${FILENAME}")" ]; then
        # The file ends with a newline or with a null byte,
        return 0
    else
        # The file does not end with a newline nor with a null byte.
        return 1
    fi
}
export -f does_file_have_eol_at_the_end

###############################################################################
# Utility function f
# Search recursively from current location for files or directories starting with a prefix prefix, case insensitive
# @param ${1} string package name
# @param ${2} array  package list to append
# @return  Success if value exists, Failure otherwise
# Usage: f prefix
# Example: f index  # Will show all files or directories starting with 'index'
function f {
    FILE_PREFIX="${1}"
    if [ "${FILE_PREFIX}" != "" ]; then
        find . -iname "${FILE_PREFIX}*"
        return ${?}
    else
        echo "Find files with prefix, starting from current working directory down recursively." 1>&2
        echo "Usage: f index" 1>&2
        return 1
    fi
}
export -f f

###############################################################################
# Category: file
# Utility function - Easy way to check if a file contains a pattern
function file_contains_pattern {
    FILE="${1}"
    PATTERN="${2}"

    if [ ! -e "${FILE}" ]; then
        return 1
    fi
    if [  -z "${PATTERN}" ]; then
        return 1
    fi
    grep --quiet --text "${PATTERN}" "${FILE}"
}
export -f file_contains_pattern

###############################################################################
# Category: file
# Utility function - finds out which package owns a file and print result into standard output in form:
#    [package_name_1]:  [/path_1/to/the/file/after/package/installed]
#    [package_name_2]:  [/path_2/to/the/file/after/package/installed]
#
# Dependency:
#   apt-file - The "apt-file" package must be installed. We will run "sudo apt-file update" on each function call.
#
# Usage example:
#    find_file_owner_in_all_packages realpath
#
# Example output (can produce more than one line):
#    bash-builtins: /usr/lib/bash/realpath
#    bash-builtins: /usr/share/doc/bash/examples/loadables/realpath.c
#    code: /usr/share/code/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/LICENSE
#    code: /usr/share/code/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/README.md
#    code: /usr/share/code/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/index.js
#    code: /usr/share/code/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/old.js
#    code: /usr/share/code/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/package.json
#    code-exploration: /usr/share/code-exploration/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/LICENSE
#    code-exploration: /usr/share/code-exploration/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/README.md
#    code-exploration: /usr/share/code-exploration/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/index.js
#    code-exploration: /usr/share/code-exploration/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/old.js
#    code-exploration: /usr/share/code-exploration/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/package.json
#    code-insiders: /usr/share/code-insiders/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/LICENSE
#    code-insiders: /usr/share/code-insiders/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/README.md
#    code-insiders: /usr/share/code-insiders/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/index.js
#    code-insiders: /usr/share/code-insiders/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/old.js
#    code-insiders: /usr/share/code-insiders/resources/app/extensions/ms-vscode.node-debug2/node_modules/fs.realpath/package.json
#    coreutils: /usr/bin/realpath
#    coreutils: /usr/share/man/man1/realpath.1.gz
#    epic4-help: /usr/share/epic4/help/6_Functions/realpath
#    fish-common: /usr/share/doc/fish/_sources/cmds/realpath.rst.txt
#    fish-common: /usr/share/doc/fish/cmds/realpath.html
#    fish-common: /usr/share/fish/completions/realpath.fish
#    fish-common: /usr/share/fish/functions/realpath.fish
#    gnulib: /usr/share/gnulib/doc/posix-functions/realpath.texi
#    libexplain-dev: /usr/include/libexplain/realpath.h
#    libexplain-dev: /usr/share/man/man3/explain_realpath.3.gz
#    libexplain-dev: /usr/share/man/man3/explain_realpath_or_die.3.gz
#    librnd-dev: /usr/include/librnd/core/compat_lrealpath.h
#    libssh2-1-dev: /usr/share/man/man3/libssh2_sftp_realpath.3.gz
#    manpages-de: /usr/share/man/de/man1/realpath.1.gz
#    manpages-de-dev: /usr/share/man/de/man3/realpath.3.gz
#    manpages-dev: /usr/share/man/man3/realpath.3.gz
#    manpages-fr-dev: /usr/share/man/fr/man3/realpath.3.gz
#
function find_file_owner_in_all_packages {
    # Take filename argument
    FILE="${1}"

    # Make sure arguemnt is not empty
    if [ -z "${FILE}" ]; then
        error "Function find_file_owner_in_all_packages() require one argument: filename."
        return 1
    fi

    # Check if "apt-file" is installed
    if ! command_exists apt-file; then
      error "apt-file is not installed. Please install it first (e.g. sudo install apt-file) and try again."
      return 1
    fi

    # Update packages universe database
    sudo apt-file update

    # Try to search given file
    apt-file search "${FILE}"
}
export -f find_file_owner_in_all_packages

###############################################################################
# Category: file
# Utility function - finds out which package owns a file and print result into standard output in form:
#    [package_name_1]:  [/path_1/to/the/file/after/package/installed]
#    [package_name_2]:  [/path_2/to/the/file/after/package/installed]
#
# The "find_file_owner_package" tries to find the package which owns the file.
# It can only find owning package if mentioned file/package installed
# (unlike function find_file_owner_in_all_packages() based on "apt-file
# search realpath", which searches through all "potential universe", but require "apt-file to be installed and updated")
#
# Usage example:
#    find_file_owner_in_installed_packages realpath
#
# Example output (can produce more than one line):
#    coreutils: /usr/bin/realpath
#    coreutils: /usr/share/man/man1/realpath.1.gz
#    manpages-dev: /usr/share/man/man3/realpath.3.gz
#
function find_file_owner_in_installed_packages {
    # Take filename argument
    FILE="${1}"

    # Make sure arguemnt is not empty
    if [ -z "${FILE}" ]; then
        error "Function find_file_owner_in_installed_packages() require one argument: filename."
        return 1
    fi

    # Try to find the file in the installed packages
    dpkg -S "${FILE}"
}
export -f find_file_owner_in_installed_packages

###############################################################################
# Category: file
# Utility function - Read remote file served by web server by given URL.
#
# If remote server response had HTTP_CODE 200, then function produce result into standard output and return code 0.
# In any other case function return code is 1 and no output produced.
#
function get_by_url {
  local URL="${1}"

  [ ! -z "${URL}" ] || { return 1; }
  local OUTPUT=$( curl \
      --silent    \
      --retry 5    \
      --location    \
      --max-time 55  \
      --retry-delay 1 \
      --retry-max-time 60 \
      --connect-timeout 12 \
      -w "\n%{http_code}" \
      "${URL}" ) || { return 1; }

  # Extract HTTP_CODE (last injected line)
  HTTP_CODE=$( echo "${OUTPUT}" | tail -1 )
  
  # Check HTTP_CODE is 200
  [ "${HTTP_CODE}" -eq 200 ] || { return 1; }
    
  # Print everything except last line, which we injected http_code
  # Note: we use:
  #    | head -n -1    - to get all the lines except the last one
  #    | head -c -1    - to get rid of last byte of the last line, which was "new line" injected by us before http_code
  echo -n "${OUTPUT}" | head -n -1 | head -c -1 
}
export -f get_by_url

###############################################################################
# Category: file
# Utility function - Easy way to check if a glob matches.
# This is a bash builtin wrapper. e.g. glob_matches '/tmp/abc*' will return 0 or 1
function glob_matches {
	compgen -G ${@} >/dev/null
	return ${?}
}
export -f glob_matches

###############################################################################
# Category: file
# Utility function - injects text into the end of existing file.
#
# Function serch regular expression PATTERN in the existing file by the given TARGET_FILE and if missing, then
# the INJECT_CONTENT got injected at the end of the TARGET_FILE.
# Return:
#  code 0 - succesful injection (or PATTERN already present in the TARGET_FILE)
#  code 1 - failed to inject (not enough permissions, target file does not exist etc.)
#           In case of error: the error will be reported by error() function (to standard output and into logger)
#
# Note: if existing file have missing EOL in last line, extra EOL will be injected before injectint the content.
#
# Pattern is the POSIX regular expression:
#    https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
# but with platform-specific extensions (which vary in extent and can be incompatible).
# On Linux platforms (GNU userland), see man grep; on macOS/BSD platforms, see man re_format.
#
# Usage example:
#
#   TARGET_FILE="/tmp/some_file.txt"
#   echo "creating example target file" > "${TARGET_FILE}"
#   PATTERN="source \"${FF_AGENT_PROFILE_FILE}\""
#
#   INJECT_CONTENT=$(
#       cat <<EOT
# # Sourcing custom ff_agent/.bashrc file (injected by set_environment -> ff_bash_functions -> ${FUNCNAME[0]} on $(date --utc))
# source "${FF_AGENT_PROFILE_FILE}"
# injected line #3
# injected line #4
#
# EOT
#     )
#
#   inject_into_file "${TARGET_FILE}" "${PATTERN}" "${INJECT_CONTENT}"
#   if [ ${?} -ne 0 ]; then
#     echo "Error: failed to inject into the file: '${TARGET_FILE}'"
#   else
#     echo "Successfully injected text into the file: '${TARGET_FILE}'"
#   fi
#
function inject_into_file {
  TARGET_FILE="${1}"
  PATTERN="${2}"
  INJECT_CONTENT="${3}"

  # Check inputs aren't empty
  [ -z "${TARGET_FILE}" ] && { error "${FUNCNAME[0]}" "error_target_file_is_blank"; return 1; }
  [ -z "${PATTERN}" ] && { error "${FUNCNAME[0]}" "error_pattern_is_blank"; return 1; }
  [ -z "${INJECT_CONTENT}" ] && { error "${FUNCNAME[0]}" "error_inject_content_is_blank"; return 1; }

  # Check the target file exists
  if [ ! -f "${TARGET_FILE}" ]; then
    error "${FUNCNAME[0]}" "error_target_file_does_not_exist: '${TARGET_FILE}'"
    return 1
  fi

  # Check if file TARGET_FILE contains the PATTERN
  if ! file_contains_pattern "${TARGET_FILE}" "${PATTERN}"; then
    # Expected pattern is missing. Inject text.

    # Inject extra EOL if last line of the file missing EOL and file is not empty
    if ! does_file_have_eol_at_the_end "${TARGET_FILE}"; then
      echo "" >> "${TARGET_FILE}" || {
        error "${FUNCNAME[0]}" 'error_injecting_sourcing_custom_bashrc_to_home_bashrc'
        return 1
      }
    fi

    # Append INJECT_CONTENT to the end of the TARGET_FILE
    echo "${INJECT_CONTENT}" >> "${TARGET_FILE}" || {
      error "${FUNCNAME[0]}" 'error_injecting_sourcing_custom_bashrc_to_home_bashrc'
      return 1
    }

    # Post condition: verify that the expected pattern can be found after injection.
    if ! file_contains_pattern "${TARGET_FILE}" "${PATTERN}"; then
      # Expected pattern is still missing. Report an error.
      error "${FUNCNAME[0]}" 'failed_postcondition_check_expected_pattern_is_missing_after_injection'
      return 1
    fi
  fi

  return 0
}
export -f inject_into_file

###############################################################################
# Category: file
# Utility function - Convenience methoud wrapping "realpath" call (realpath is a part of coreutils apt package, which we install as a baseline)
# Takes a path argument and returns it as an absolute path. 
#
function path_to_absolute_path {
  local TARGET="$1"
  realpath --canonicalize-missing "${TARGET}"
}
export -f path_to_absolute_path

###############################################################################
# Category: file
# Utility function - checks if given file or directory is writable by the current user.
#
# Function return code:
#  0 - if file/directory writable
#  1 - otherwise
#
function is_writable {
  # Get argument
  local TARGET="${1}"

  # Check argument is not blank
  [ ! -z "${TARGET}" ] || { return 1; }
  
  # If file/directory is writable, then return 0
  [ -w "${TARGET}" ] && { return 0; }

  # The target is not writable. Return 1
  return 1
}
export -f is_writable

###############################################################################
# Category: file
# Utility function -  parses given file and removes all lines containing a match by the given regular expression.
#
# Usage example:
#   remove_all_lines_by_regexp "Some line matcher regexp \(.*\)"  /some/path/to/the/file.txt
#
# Return codes:
#   0 - successfully removed lines
#   1 - missing regular expression
#   2 - missing target filename
#   3 - target file does not exist
#   4 - not enough permissions to read the target file
#   5 - not enough permissions to writ the target file
#   6 - the pattern was not found (in some cases this might be 'success' because some lines were already removed successfully before)
#   7 - failed to search by given pattern (most probably bad regex pattern)
#   8 - editor return an error (most probably bad regex pattern
#   9 - zero lines removed (despite the pattern was found and editor didn't error out and we have all the permissions)
#
function remove_all_lines_by_regexp {

  # Get regexp argument
  REGEX="${1}"

  # Check is is not empty string
  if [ "${REGEX}" == "" ]; then
    # Error: missing regular expression
    return 1
  fi

  # Get filename argument
  TARGET_FILE="${2}"

  # Check filename is not blank
  if [ "${TARGET_FILE}" == "" ]; then
    # Error: missing target filename
    return 2
  fi

  # Check file exists
  if [ ! -f "${TARGET_FILE}" ]; then
    # Error: file does not exist
    return 3
  fi

  # Check if target file is readable
  if [ ! -r "${TARGET_FILE}" ]; then
    # Error: not enough permissions to read target file
    return 4
  fi

  # Check if target file is writable
  if [ ! -w "${TARGET_FILE}" ]; then
    # Error: not enough permissions to write target file
    return 5
  fi

  # Try to find by given regexp
  # Note: we collect grep output even though "-q" is used: to cover all the error cases and
  # not spill output to stderr/stdout. We might enrich return error with more details later
  # (examaple: bad syntax in the used regex).
  GREP_OUTPUT=$( grep -q "${REGEX}" "${TARGET_FILE}" 2>&1 )
  GREP_CODE=${?}

  # Check if the pattern is found
  if [ ${GREP_CODE} -eq 1 ]; then
    # The pattern was not found
    return 6
  fi
  if [ ${GREP_CODE} -gt 1 ]; then
    # Error: 7 - failed to search by given pattern.
    return 7
  fi

  # Take a note on the current number of lines
  LINE_COUNT_BEFORE_CHANGE="$( cat "${TARGET_FILE}" | wc -l )"

  # Found line in the target file. Edit file:
  EDITOR_OUTPUT=$( sed -i "/${REGEX}/d" "${TARGET_FILE}" 2>&1 )

  # Check if stream editor error out.
  # Example: bad pattern would return code=1 and error message: sed: -e expression #1, char 8: unterminated address regex
  EDITOR_CODE=${?}
  if [ ${EDITOR_CODE} -ne 0 ]; then
    # Error: editor return an error (most probably bad regex pattern)
    return 8
  fi

  # Count the number of deleted lines
  # Note: sed always return 0, so it won't let us know how many changes were done
  LINE_COUNT_AFTER_CHANGE="$( cat "${TARGET_FILE}" | wc -l )"
  DELETED_LINES_COUNT=$(( LINE_COUNT_BEFORE_CHANGE - LINE_COUNT_AFTER_CHANGE ))

  # Check the number of deleted lines
  if [ ${DELETED_LINES_COUNT} -gt 0 ]; then
    # Success
    return 0
  else
    # Somehow the number of lines did't change even though we found the pattern (obviously an error).
    return 9
  fi
}
export -f remove_all_lines_by_regexp

###############################################################################
# Category: file
# Utility function - parses given file and replaces all lines containing a match by the given regular expression to other string.
# replace_all_lines_by_regexp "find pattern" "replacement string" "/path/to/file"
#
# Usage example:
#   replace_all_lines_by_regexp "Some line matcher regexp \(.*\)" "New content"  /some/path/to/the/file.txt
#
# Return codes:
#   0 - successfully replaced lines
#   1 - missing inputs: regular expression or replacement string is empty
#   2 - missing target filename
#   3 - target file does not exist
#   4 - not enough permissions to read the target file
#   5 - not enough permissions to writ the target file
#   6 - the pattern was not found (in some cases this might be 'success' because some line was already replaced successfully before)
#   7 - failed to search by given pattern (most probably bad regex pattern)
#   8 - editor return an error (most probably bad regex pattern
#   9 - zero lines replaced (despite the pattern was found and editor didn't error out and we have all the permissions)
#  10 - Failed to create temporary file
#  11 - Failed to copy target file to temporary file
#
function replace_all_lines_by_regexp {

  # Get regexp argument
  REGEX="${1}"
  REPLACE="${2}"

  # Check if regex is not empty
  if [ "${REGEX}" == "" ]; then
    # Error: missing regular expression
    return 1
  fi

  # REPLACEMENT STRING CAN BE EMPTY. DISABLING THIS CHECK.
  # # Check if replacement string is not empty
  # if [ "${REPLACE}" == "" ]; then
  #   # Error: missing replacement string
  #   return 1
  # fi

  # Get filename argument
  TARGET_FILE="${3}"

  # Check filename is not blank
  if [ "${TARGET_FILE}" == "" ]; then
    # Error: missing target filename
    return 2
  fi

  # Check file exists
  if [ ! -f "${TARGET_FILE}" ]; then
    # Error: file does not exist
    return 3
  fi

  # Check if target file is readable
  if [ ! -r "${TARGET_FILE}" ]; then
    # Error: not enough permissions to read target file
    return 4
  fi

  # Check if target file is writable
  if [ ! -w "${TARGET_FILE}" ]; then
    # Error: not enough permissions to write target file
    return 5
  fi

  # Try to find by given regexp
  GREP_OUTPUT=$( grep -q "${REGEX}" "${TARGET_FILE}" 2>&1 )
  GREP_CODE=${?}

  # Check if the pattern is found
  if [ ${GREP_CODE} -eq 1 ]; then
    # The pattern was not found
    return 6
  fi
  if [ ${GREP_CODE} -gt 1 ]; then
    # Error: 7 - failed to search by given pattern.
    # Pass grep output through stdout.
    return 7
  fi

  # Make a temporary copy of the edited file (the only reason: we need to count number of modified lines by the editor)
  ORIGINAL_FILE_COPY="$( mktemp 2>&1 )"
  if [ ${?} -ne 0 ] || [ ! -f "${ORIGINAL_FILE_COPY}" ]; then
    # "failed to create temporary file. Details: ${ORIGINAL_FILE_COPY}"
    return 10
  fi

  # Create a temporary copy of the target file before editing it
  cp "${TARGET_FILE}" "${ORIGINAL_FILE_COPY}"
  if [ ${?} -ne 0 ]; then
    # "failed to copy file ${TARGET_FILE} to temporary file ${ORIGINAL_FILE_COPY}"
    return 11
  fi

  # We found line(s) in the target file. Edit file:
  EDITOR_OUTPUT=$( sudo sed -i "s/${REGEX}/${REPLACE}/" "${TARGET_FILE}" 2>&1 )

  # Check if stream editor error out.
  # Example: bad pattern would return code=1 and error message: sed: -e expression #1, char 8: unterminated address regex
  EDITOR_CODE=${?}
  if [ ${EDITOR_CODE} -ne 0 ]; then
    # Error: editor return an error (most probably bad regex pattern)
    # Pass editor output (error details) to stdout.
    rm "${ORIGINAL_FILE_COPY}"
    return 8
  fi

  # Count the number of modified lines
  # Note: sed always return 0, so it won't let us know how many changes were done unless we count "before" and "after"
  MODIFIED_LINES_COUNT=$( diff "${TARGET_FILE}" "${ORIGINAL_FILE_COPY}" | grep '^<' | wc -l )
  rm "${ORIGINAL_FILE_COPY}"

  # Check the number of modified lines is > 0
  if [ ${MODIFIED_LINES_COUNT} -gt 0 ]; then
    # Success. Pass the number of deleted lines through stdout.
    return 0
  else
    # Somehow the number of lines did't change even though we found the pattern (obviously an error).
    # Pass editor output (error details) to stdout.
    return 9
  fi
}
export -f replace_all_lines_by_regexp

###############################################################################
# Utility function s
# Search from current directory for files containing keyword (case insensitive)
# Ignores node_modules directory
# @param ${1} pattern
# @return  Success if keyword exists, Failure otherwise
# Usage: s pattern
function s {
#!/bin/bash -
    GREP_OPTIONS="--color=always"
    PATTERN="${1}"
    if [ "${PATTERN}" != "" ]; then
        find . -name "*" -type f -not -path "*node_modules*" -exec grep -i --text --line-number -H "${PATTERN}" {} \;
        return ${?}
    else
        echo "Search files in a subtree for a regex. Case insensitive." 1>&2
        echo "Usage: s pattern" 1>&2
        return 1
    fi
}
export -f s

###############################################################################
# Category: file
# Utility function - truncates file to zero
#
# Return codes
#   0 - success
#   2 - missing target filename
#   3 - target file does not exist
#   4 - not enough permissions to read the target file
#   5 - not enough permissions to writ the target file
#   6 - failed to truncate the target file (expected size didn't drop to zero)
#
# Usage example:
#   truncate_file /some/path/to/the/file.txt
#
# Note: if you truncating the log file, which is actively used by running process(es) there might be the case
# when right after you truncated the file it was written to before we checked the size, so error code 6 might
# be not an error in these cases.
#
function truncate_file {
  # Get filename argument
  TARGET_FILE="${1}"

  # Check filename is not blank
  if [ "${TARGET_FILE}" == "" ]; then
    # Error: missing target filename
    return 2
  fi

  # Check file exists
  if [ ! -f "${TARGET_FILE}" ]; then
    # Error: file does not exist
    return 3
  fi

  # Check if target file is readable
  if [ ! -r "${TARGET_FILE}" ]; then
    # Error: not enough permissions to read target file
    return 4
  fi

  # Check if target file is writable
  if [ ! -w "${TARGET_FILE}" ]; then
    # Error: not enough permissions to write target file
    return 5
  fi

  # Check if file is not empty, then truncate it to zero
  if [ -s "${TARGET_FILE}" ]; then
    # File is not empty.
    # Warning: don't "sudo" here, for files with permissions like "-rw-rw-r--" truncate won't have access by root user
    truncate --size=0 "${TARGET_FILE}" || { set_state "${FUNCNAME[0]}" 'error_trancating_file'; return 1; }
  else
    # File is already empty
    return 0
  fi

  # Final check: file must have zero size now
  if [ -s file ]; then
    # Error: File is not empty after truncation
    return 6
  fi

  return 0
}
export -f truncate_file

### END UTILITY FUNCTIONS: FILE






### BEGIN UTILITY FUNCTIONS: LOGGING / PROCESS CONTROl

###############################################################################
# Utility abort / exit function - called when terminal conditions
function abort {
    error "abort called - aborting ${@}"
    if [ ! -z "${SERVICE}" ]; then
        set_state ${SERVICE} abort
    fi
    exit 1
}
export -f abort

###############################################################################
#
# Ensures command must exit cleanly (with exit code 0) else abort the entire
# process by calling abort(), which will log error and exit(1).
#
# Usage example:
#    assert_clean_exit apt_update
#
function assert_clean_exit {
  #echo "TRY: ${@}"
  "${@}"
  local STATUS=${?}
  if [ ${STATUS} -ne 0 ]; then
     log "ERROR: Command \"${@}\" did not exit cleanly."
     abort
  # else
  # 	log "SUCCESS: ${@}"
  fi
}
export -f assert_clean_exit

###############################################################################
# Auxilary function to produce human-readable output in standard output describing
# the current process (start time, ownership, hostname, os, etc.)
function banner {
cat <<EOT
    ================================================================================
    BUILD SCRIPT: ${@}
         STARTED: $( date )
              AS: $( id )
             PWD: $( pwd )
            HOST: $( hostname )
              OS: $( uname -a )
    ================================================================================

EOT
}
export -f banner

###############################################################################
# Utility error logging function. For now simply forwar it to log, which reports
# given string to both:
#    - standard error stream
#    - logger
#
function error {
    echo -n "${FONT_STYLE_RED}"
    log error: "${@}"
    echo -n "${FONT_STYLE_NORMAL}"
}
export -f error

###############################################################################
# Utility loging function to report given string to both:
#    - standard error stream
#    - logger
#
# Require optional ${SERVICE} to be defined. Proudce all the output into both: standard error stream and send it to logger.
#
# Usage example:
#   log "Some event happened."
#
# Example output:
#   Tue 07 Sep 2021 07:29:02 PM UTC: SomeService: Some event happened.
#
function log {

  # Check if optional environment SERVICE is defined, then use it as a tag for logger
  if [ "${SERVICE}" != "" ]; then
    local LOGGER_TAG="--tag '${SERVICE}'"
    local SERVICE_PREFIX="${SERVICE}: "
  else
    local SERVICE_PREFIX=''
  fi

  echo "${SERVICE_PREFIX}${@}" | tee >(logger ${LOGGER_TAG} ) >&2
}
export -f log

###############################################################################
# Auxilary function to produce human-readable output in standard output describing
# currently executed "step". Function takes arbitrary number of arguments.
# 
function step {
cat <<EOT

  --------------------------------------------------------------------------------
  STEP: ${@}
  --------------------------------------------------------------------------------

EOT
}
export -f step

###############################################################################
#
function successful_exit {

  # Check if SERVICE is defined
  if [ "${SERVICE}" != "" ]; then
    local SERVICE_SUFFIX="${SERVICE}_"
    set_state "${SERVICE_SUFFIX}last_run_state" success
  fi

  exit 0
}
export -f successful_exit

###############################################################################
# Utility error logging function
function warning {

    # Check input: not empty
    if [ -z "${@}" ]; then
      return
    fi

    log warning "${@}"
}
export -f warning

### END UTILITY FUNCTIONS: LOGGING / PROCESS CONTROl


### BEGIN UTILITY FUNCTIONS: TERMINAL / SHELL

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Function enables verbose bash echo (all executed lines got printed before execution).
# This is convenient way to debug bash scritps.
#
# Note: we don't use "set_state()" in set_bash_echo_xxx() functions since it can laed to recurrsion.
#
function set_bash_echo_on {
  set -x
}
export -f set_bash_echo_on

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Function disables verbose bash echo (all executed lines got printed before execution).
function set_bash_echo_off {
  set +x
}
export -f set_bash_echo_off

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Function get_bash_echo_setting() allows to preserve current bash echo settings, so
# one can restore it later using set_bash_echo_setting().
#
# Usage Example:
#
# # Preserve current bash echo settings and enable bash echo setting
# BASH_ECHO_SETTINGS=$( get_bash_echo_setting ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_bash_echo_settings'; return 1; }
# set_bash_echo_on
#
# # ...do some work...
#
# # Restore bash echo settings
# set_bash_echo_setting "${BASH_ECHO_SETTINGS}"
#
function get_bash_echo_setting {
  # Preserve current xtrace state
  if is_shell_attribute_set x; then
    echo -n " XTRACE_ENABLED "
  fi
}
export -f get_bash_echo_setting

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Functions set_bash_echo_setting() allows to restore/set bash echo settings according to
# the provided argument -- settings string. The settings string can be obtained using get_bash_echo_setting().
#
# See function get_bash_echo_setting() description for details.
#
function set_bash_echo_setting {
  # Get all provided arguments (it supports multiple arguments)
  local BASH_ECHO_SETTINGS="${@}"

  # Check if arguments have XTRACE_ENABLED
  if [[ "${BASH_ECHO_SETTINGS}" =~ XTRACE_ENABLED ]]; then
    # Enable bash tracing
    set_bash_echo_on
  else
    # Disable bash tracing
    set_bash_echo_off
  fi
}
export -f set_bash_echo_setting


###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Function checks if variable given by name is defined.
# Function takes the only argument: variable name.
# Return:
#    on "success" (variable is defined) - return 0
#    on "error" (variable not devined) - return non zero code and callse error(error_details)
#
function ensure_variable_defined {
  
  # Dependency check: 'tr' is installed
  if ! command_exists tr >/dev/null; then
    error "${FUNCNAME[0]}" 'error_dependency_not_met_tr'
    return 1
  fi

  local NAME="${1}"
  [[ -z "${NAME}" ]] && { error "error_ensure_variable_defined_no_arguments"; return 1; }  # Check: NAME is not blank
  [[ -v "${NAME}" ]] && { return 0; }  # Check: variable by NAME is defined

  # Create meaningful error code, which include lowcase variable name
  local ERROR_CODE="$( echo "error_expected_variable_not_set_${NAME}" | tr '[:upper:]' '[:lower:]' )"

  # Report an error and return nonzero code.
  error "${ERROR_CODE}"
  return 1
}
export -f ensure_variable_defined

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Function ensure_variable_not_empty checks if the variable by given is defined and has non-empty value.
# Function takes the only argument: variable name.
# Return:
#    on "success" (variable is defined and non-empty) - return 0
#    on "error" (variable not defined or has empty value) - return nonzero code and calls error(error_details)
#
# Usage example:
#     ensure_variable_not_empty 'FF_CONTENT_URL' || {
#       set_state "${FUNCNAME[0]}" "error_ensure_variable_not_empty_ff_content_url"
#       return 1
#     }
#
function ensure_variable_not_empty {
  local NAME="${1}"
  [[ -z "${NAME}" ]] && { error "error_ensure_variable_not_empty_no_arguments"; return 1; }  # Check: NAME itself is not blank
  [[ -v "${NAME}" ]] && [[ ! -z "${!NAME}" ]] && { return 0; }  # Check: variable by NAME is defined and isn't empty

  # Create meaningful error code, which include lowcase variable name
  local ERROR_CODE=$( echo "error_ensure_variable_not_empty_${NAME}" | tr '[:upper:]' '[:lower:]' )

  # Report an error and return nonzero code.
  error "${ERROR_CODE}"
  return 1
}
export -f ensure_variable_not_empty

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Utility is_shell_attribute_set function
# See discussion: https://stackoverflow.com/a/34709224/7022062
# Usage example:
#     set -x
#     if is_shell_attribute_set x; then echo "xtrace enabled" ; else echo "xtrace disabled"; fi # xtrace enabled
#
#     set -e
#     if is_shell_attribute_set e; then echo "yes"; else echo "no"; fi # yes
#
#     set +e
#     if is_shell_attribute_set e; then echo "yes"; else echo "no"; fi # no
#
function is_shell_attribute_set {
  case "$-" in
    *"${1}"*)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}
export -f is_shell_attribute_set

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Utility is_shell_attribute_set function
# See discussion: https://stackoverflow.com/a/34709224/7022062
# Usage example:
#     set -o pipefail
#     if is_shell_option_set pipefail; then echo "yes"; else echo "no"; fi # yes
#
#     set +o pipefail
#     if is_shell_option_set pipefail; then echo "yes"; else echo "no"; fi # no
#
function is_shell_option_set {
  case "$(set -o | grep "${1}")" in
    *on) return 0 ;;
    *)   return 1 ;;
  esac
}
export -f is_shell_option_set

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Initialize the terminal
# Ensures that TERM is set
# Ensures we set up colours only if TERM is set, else empty strings
# Works even if we don't have tput command, which we might not
function terminal_initialize {

  # If we do not have a terminal type, set up dumb
  if [ -z "${TERM}" ]; then
    export TERM=dumb
  fi

  export FONT_STYLE_BOLD=""
  export FONT_STYLE_GREEN=""
  export FONT_STYLE_RED=""
  export FONT_STYLE_NORMAL=""

  if terminal_is_tty ; then

    if command_exists tput ; then
        # If this is a TTY, These set of "FONT_STYLE_*" variables allows us to decorate the output with some style (colour, boldness)
        FONT_STYLE_BOLD="$(tput bold)"
        FONT_STYLE_GREEN="$(tput setaf 2)"
        FONT_STYLE_RED="$(tput setaf 1)"
        FONT_STYLE_NORMAL="$(tput sgr0)"
    fi
  fi

  return 0

}
export -f terminal_initialize

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Check if terminal is interactive
# This is useful in cases where we might wish to ask a question
# If you run this script from ssh, it will return 255 (e.g. ssh hostname "terminal_is_interactive" )
function terminal_is_interactive {
  command_exists tty && tty -s && return 0 || return 1
  return 1 # Default, it isn't.
}
export -f terminal_is_interactive

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Check if this terminal is a TTY
function terminal_is_tty {
    [ -t 0 ] && return 0 || return 1
}
export -f terminal_is_tty

###############################################################################
# Category: UTILITY FUNCTIONS: TERMINAL / SHELL
# Reset terminal state - sometimes useful if a command messes up terminal state
function terminal_reset {
  terminal_is_tty && command_exists tput && tput reset && tput sane
}
export -f terminal_reset

### END UTILITY FUNCTIONS: TERMINAL / SHELL


### BEGIN UTILITY FUNCTIONS: PROCESS

###############################################################################
# Category: UTILITY FUNCTIONS: PROCESS
# checks if a process is running as current user or effectively as current user.
# Note we are checking for the pattern at the beginning of the command by default
function is_process_running_as_me {
    set_state "${FUNCNAME[0]}" 'started'
    local COMMAND_PATTERN="${1}"
    [ ! -z "${COMMAND_PATTERN}" ] || { set_state "${FUNCNAME[0]}" 'error_require_pattern_to_search_for'; return 1; }

    # We require PS and GREP commands
    local PS=$(command_exists ps) || { set_state "${FUNCNAME[0]}" 'error_dependency_not_met_ps_command'; return 1; }
    local GREP=$( command_exists grep ) || { set_state "${FUNCNAME[0]}" 'error_dependency_not_met_grep_command'; return 1; }

    # Get current user. Note: the ${USER} environment is NOT set when running as 'root' in docker, we must use f-n get_current_user() instead.
    CURRENT_USER="$(get_current_user)" || { error "Can not get current user"; return 1; }

    ${PS} -u "${CURRENT_USER}" -U "${CURRENT_USER}" o command | ${GREP} --silent -e "^${COMMAND_PATTERN}"
    STATUS=${?}
    set_state "${FUNCNAME[0]}" 'success'
    return ${STATUS}
}
export -f is_process_running_as_me

### END UTILITY FUNCTIONS: PROCESS


### BEGIN UTILITY FUNCTIONS: CONTAINERS

###############################################################################
# Category: container
# Utility function - Check if container exists
#
# Usage example:
#    if container_name_exists "some_container_name"; then
#       # Yes, container by given name does exist.
#    else
#       # No such container found
#    fi
#
function container_name_exists {
    CONTAINER_NAME="${1}"
    # -z - true if the length of string is zero
    # -n - true if the length of string is nonzero
    if [ -z "${CONTAINER_NAME}" ]; then
        error "error_no_container_name_specified"
        return 2
    fi
    CONTAINER_ID=$(docker inspect --format="{{.Id}}" ${CONTAINER_NAME} 2> /dev/null)
    if [[ "${CONTAINER_ID}" ]]; then
        return 0
    else
        return 1
    fi
}
export -f container_name_exists

###############################################################################
# Category: container
# Utility function - Remove all unused containers, networks, images (both dangling and unreferenced)
#
# Function return code 0 on success, 1 on error (example: not enough permissions)
#
# Note: function also prints result to the standard output. 
# Example: 
#    Total reclaimed space: 0B
#
# TODO: And in that new function please add an error check. It is possible the docker system prune --al --force won't always work.
# On some systems we might need to be root to run that command, so we will need to build out more robust docker functions that
# might try one way vs. another and properly track what's going on.
#
function docker_cleanup {
  set_state "${FUNCNAME[0]}" 'started'

  # Cleanup some space
  # docker system prune: Remove all unused containers, networks, images (both dangling and unreferenced), and optionally, volumes if --volumes used.
  # Note: adding --volumes might be risky since it will erase DATA from stopped containers.
  # More details: https://docs.docker.com/engine/reference/commandline/system_prune/
  docker system prune --all --force || { set_state "${FUNCNAME[0]}" 'failed_to_docker_cleanup'; return 1; }

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f docker_cleanup

###############################################################################
# Category: container
# Utility function - Get list of volumes and print list of containers, which use them.
#
# TODO: improve it to also show the size of each volume by combining output from "docker system df --verbose"
#
function docker_volumes_to_containers_list {
  volumes=$(docker volume ls  --format '{{.Name}}')

  for volume in $volumes
  do
    echo $volume
    docker ps -a --filter volume="$volume"  --format '{{.Names}}' | sed 's/^/  /'
  done
}
export -f docker_volumes_to_containers_list

###############################################################################
# Category: container
# Utility function - Get Docker Version
function get_installed_docker_version {
    DOCKER_PATH=$( command -v docker )
    if [ -z "${DOCKER_PATH}" ]; then
        return 1
    else
        DOCKER_VERSION=$( ${DOCKER_PATH} -v | cut -d" " -f 3 | cut -d"." -f 1 )
        echo "${DOCKER_VERSION}"
    fi
}
export -f get_installed_docker_version

###############################################################################
# Category: container
# Utility function - Check if docker container healthy or not. This checks if the container is actually in the state 'running' vs. restarting
function is_container_healthy {
    CONTAINER_NAME="${1}"

    # -z - true if the length of string is zero
    # -n - true if the length of string is nonzero
    if [ -z "${CONTAINER_NAME}" ]; then
        error "error_no_container_name_specified"
        return 2
    fi
    if [ "$( docker container inspect -f '{{.State.Status}}' ${CONTAINER_NAME} )" == "running" ]; then
        return 0
    else
        return 1
    fi
}
export -f is_container_healthy

###############################################################################
# Category: container
# Utility function - Check if docker container running by given container name.
# This checks if it is running, but it could be in a 'restart' loop.
#
# Return code:
#   0 - container is running
#   1 - container is not running
#   2 - error: missing argument
#
function is_container_running {

    # Take argument, check it is not empty
    CONTAINER_NAME="${1}"
    [ ! -z "${CONTAINER_NAME}" ] || { error "error_no_container_name_specified"; return 2; }

    # Inspect given container, make sure it is in ranning state
    if [ "$( docker container inspect -f '{{.State.Running}}' ${CONTAINER_NAME} )" == "true" ]; then
        return 0
    else
        return 1
    fi
}
export -f is_container_running

###############################################################################
# Category: container
# Utility function - Restart docker containers
function restart_containers {

    # if [ -z "${@}" ]; then
    #     error "error_no_container_names_specified"
    #     return 2
    # fi
    CONTAINERS=(${@})
    CONTAINERS_TO_RESTART=()
    for CONTAINER in "${CONTAINERS[@]}"
    do
        # We only restart a container if it is defined
        if container_name_exists "${CONTAINER}"
        then
            CONTAINERS_TO_RESTART+=( ${CONTAINER} )
        fi
    done

    if (( ${#CONTAINERS_TO_RESTART[@]} )); then
        docker restart ${CONTAINERS_TO_RESTART[@]}
        return ${?}
    fi

    return 1
}
export -f restart_containers

###############################################################################
# Category: container
# Utility function - Restart docker containers
# Function gets container name (case sensitive) (can be partial) as the only input argument and
# tries to find all matching containers (even if they're in stopped state). Then for every found
# container it will "docker stop" and "docker remove" them.
# Function return code 0 on success
#
function stop_and_remove_container_by_name {
  set_state "${FUNCNAME[0]}" 'started'

  CONTAINER_NAME="${1}"

  # Check the container name isn't blank
  [ "${CONTAINER_NAME}" != "" ] || { set_state "${FUNCNAME[0]}" 'error_bad_arguments'; return 1; }

  # Count existing container(s) by given docker name
  FOUND_CONTAINERS_COUNT=$( docker ps -a | grep "${CONTAINER_NAME}" | wc -l )

  # Check if we found >1
  if [ ${FOUND_CONTAINERS_COUNT} -gt 1 ]; then
    # Yes, we found >1 containers to stop/remove
    for DOCKER_ID in $(docker ps -a | grep "${CONTAINER_NAME}" | awk '{print $1}'); do
      # Make sure DOCKER_ID is not a blank string
      if [ "${DOCKER_ID}" == "" ]; then
        set_state "${FUNCNAME[0]}" 'failed_to_get_docker_id'
        return 1
      fi

      # Try to stop and remove the container
      docker stop "${DOCKER_ID}"
      docker rm "${DOCKER_ID}"

      # Sometimes container can be in the broken state, in this case even after stopping and removing it
      # the DOCKER_ID is still visible in the "docker ps" list. In this cas we need to kill -9 corresponding
      # process on the host level:
      STILL_PRESENT_DOCKER_ID=$( docker ps -a | grep "${DOCKER_ID}" | wc -l )
      if [ "${STILL_PRESENT_DOCKER_ID}" != "" ]; then
        # Yes, we have found "unstoppable" docker. Kill -9 the corresponding process now
        PID_TO_KILL_COUNT=$( sudo ps aux | grep "${DOCKER_ID}" | wc -l )
        PID_TO_KILL=$( sudo ps aux | grep "${DOCKER_ID}" )
        if [ ${PID_TO_KILL_COUNT} -ne 1 ]; then
          # Something went wrong, we supposed to find exactly ONE pid to terminate.
          set_state "${FUNCNAME[0]}" 'failed_to_get_docker_pid'
          return 1
        fi

        # Send "kill -9" signal to the found process
        sudo kill -9 "${PID_TO_KILL}" || { set_state "${FUNCNAME[0]}" 'error_killing_process'; return 1; }

        # The "unstoppable" docker terminated, now we can safely remove the container
        docker rm "${DOCKER_ID}" || { set_state "${FUNCNAME[0]}" 'error_removing_docker'; return 1; }
      fi
    done

  fi

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f stop_and_remove_container_by_name

### END UTILITY FUNCTIONS: DOCKERS


### BEGIN UTILITY FUNCTIONS: STATE/SECRETS

###############################################################################
# Utility function
function generate_strong_password {
    # Works on Linux and Mac
    # Makes password 16 characters long
    dd if=/dev/urandom count=1 2> /dev/null | uuencode -m - | sed -ne 2p | cut -c-16
}
export -f generate_strong_password

###############################################################################
# Utility function, getting secret value by given secret key name.
# Note: get_secret() require the FF_AGENT_HOME to be set.
function get_secret {
  
  # Dependency check: 'tr' is installed
  if ! command_exists tr >/dev/null; then
    set_state "${FUNCNAME[0]}" 'error_dependency_not_met_tr'
    return 1
  fi

  # Preserve current bash echo settings and enable bash echo setting
  BASH_ECHO_SETTINGS=$( get_bash_echo_setting ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_bash_echo_settings'; return 1; }

  set_state "${FUNCNAME[0]}" 'started'

  set_bash_echo_off || { set_state "${FUNCNAME[0]}" 'failed_to_set_bash_echo_off'; return 1; } # Disable xtrace to avoid priting secrets

  local KEY="${1}"

  # Check KEY is not blank
  [ ! -z "${KEY}" ] || { error "get_secret(): blank KEY argument"; return 1; }

  # Check if KEY contains any prohibited symbols, then error out.
  [[ ! "${STATE_NAME}" =~ ([^a-z0-9_]+) ]] || { 
    set_state "${FUNCNAME[0]}" 'error_bad_argument_illigal_charaacters_in_key'
    return 1
  }

  # Check if FF_AGENT_HOME is not empty
  if [ "${FF_AGENT_HOME}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    set_state "${FUNCNAME[0]}" 'error_ff_agent_home_not_set'
    return 1
  fi

  # Check if key is not empty
  if [ "${KEY}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    set_state "${FUNCNAME[0]}" 'error_empty_key'
    return 1
  fi

  # Due to the previous runs we sometimes end up with secret files having 'null' as a value (4-byte).
  # Let's run cleanup only once (upon 1st call) and set the flag to avoid any futher cleaning ups during this run.
  # Note: -z - true if the length of string is zero
  #       -n - true if the length of string is nonzero
  if [ -z "${GET_SECRET_WIPE_NULLS_RUN_ONCE_FLAG}" ]; then
      grep -l null "${FF_AGENT_HOME}/secrets/*" 2>/dev/null | xargs rm 2>/dev/null
      GET_SECRET_WIPE_NULLS_RUN_ONCE_FLAG="any non empty string can be 'a flag'"
  fi

  # Case: requested key already exists in ff_agent "secrets/" folder
  if [ -e "${FF_AGENT_HOME}/secrets/${KEY}" ]; then
      cat "${FF_AGENT_HOME}/secrets/${KEY}"
      set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
      set_state "${FUNCNAME[0]}" 'success'
      return
  fi

  # Case: cloud user-data JSON exists: search value by given KEY in it under "agent/configuration"
  if [ -e /var/lib/cloud/instance ]; then

      # Generic case: get value by given KEY from root level of agent/configuration JSON
      VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq '.[] | select(.mime_type=="agent/configuration")' | jq -r ".${KEY}" | grep -v -e '^null$' )
      # Note: -z - true if the length of string is zero
      #       -n - true if the length of string is nonzero
      if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
          echo ${VALUE}
          set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
          set_state "${FUNCNAME[0]}" 'success'
          return
      fi

      # Special case for "ff_api_username" and "ff_api_password" - these 2 values
      # are nexted few levels deep in "agent/configuration"
      if [ "${KEY}" == "ff_api_username" ] || [ "${KEY}" == "FF_API_USERNAME" ]; then
        # TODO: here we rely on provisioning JSON on agent to have "control_api_user", which is incorrectly named and must be redesigned completely.
        VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq -r '.[] | select(.mime_type == "agent/configuration") | .roles[] | select(.role_name == "AgentRole") | .services[] | select(.service_name == "ActionManager") | .control_api_user' )
        if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
            echo ${VALUE}
            set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
            set_state "${FUNCNAME[0]}" 'success'
            return
        fi
      fi
      if [ "${KEY}" == "ff_api_password" ] || [ "${KEY}" == "FF_API_PASSWORD" ]; then
        # TODO: here we rely on provisioning JSON on agent to have "control_api_password", which is incorrectly named and must be redesigned completely.
        VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq -r '.[] | select(.mime_type == "agent/configuration") | .roles[] | select(.role_name == "AgentRole") | .services[] | select(.service_name == "ActionManager") | .control_api_password' )
        if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
            echo ${VALUE}
            set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
            set_state "${FUNCNAME[0]}" 'success'
            return
        fi
      fi
  fi

  # Case: search in "provisioning/instance"
  if [ -e /var/lib/cloud/instance ]; then
      VALUE=$( sudo cat /var/lib/cloud/instance/user-data.txt | jq '.[] | select(.mime_type=="provisioning/instance")' | jq -r ".${KEY}" | grep -v -e '^null$' )
      # Note: -z - true if the length of string is zero
      #       -n - true if the length of string is nonzero
      if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
          echo ${VALUE}
          set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
          set_state "${FUNCNAME[0]}" 'success'
          return
      fi
  fi

  # Case: We are on a local VM agent - let's check user_data.editor_answers.json
  USER_DATA="/etc/ff/configuration/user_data.editor_answers.json"
  if [ -e "${USER_DATA}" ]; then
    VALUE=$( cat "${USER_DATA}" | jq ".${KEY}" | cut -d'"' -f2 )
      if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
          set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
          echo ${VALUE}
          set_state "${FUNCNAME[0]}" 'success'
          return
      fi
  fi

  # Case: We are on a new build (blank cloud box with user_data.json injected as: /etc/ff/configuration/user_data.json )
  if [ -f /etc/ff/configuration/user_data.json ]; then
      VALUE=$( sudo cat /etc/ff/configuration/user_data.json | jq '.[] | select(.mime_type=="agent/configuration")' | jq -r ".${KEY}" | grep -v -e '^null$' )
      if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
          set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
          echo ${VALUE}
          set_state "${FUNCNAME[0]}" 'success'
          return
      fi
  fi

  # Case: We're looking for KEY=="FF_AGENT_URI" and we are on a traffic_generator.
  # In this case FF_AGENT_URI was already generated and stored to /etc/ff/configuration/agent_uri
  # Let's retreive it from there and re-store it by set_secret()
  if [ "${KEY}" == "ff_agent_uri" ] && [ -f /etc/ff/configuration/agent_uri ]; then
    FF_AGENT_URI="$( cat /etc/ff/configuration/agent_uri )"
    # Store "agent" to proper unified place for secrets, so we don't have to look for it in random places again next time.
    if [ ! -z "${FF_AGENT_URI}" ]; then
      set_secret ff_agent_uri "${FF_AGENT_URI}"
      set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
      echo "${FF_AGENT_URI}"
      set_state "${FUNCNAME[0]}" 'success'
      return
    fi
  fi

  # Case: We are on a legacy portal server in Amazon
  for environment in production staging development
  do
      ENVPATH="${HOME}/.control/environment/${environment}"
      if [ -e "${ENVPATH}" ]; then
          VALUE=$( grep -i "^${KEY}=" ${ENVPATH}/* | cut -d= -f2 | head -1 )
          if [ ! -z "${VALUE}" ] && [ "${VALUE}" != "null" ]; then
              echo ${VALUE}
              set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
              set_state "${FUNCNAME[0]}" 'success'
              return
          fi
      fi
  done

  set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
  set_state "${FUNCNAME[0]}" 'failed_to_find_secret_value'
  return 1
}
export -f get_secret

###############################################################################
# Function get_state() allows to get state set (by string name).
# Return value:
#   - if state found by given state name, print its value to standard output and return code 0
#   - if state not found, print nothing into standard output and return code 1
#
function get_state {

  # Preserve current bash echo settings and enable bash echo setting
  BASH_ECHO_SETTINGS=$( get_bash_echo_setting ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_bash_echo_settings'; return 1; }

  set_bash_echo_off || { set_state "${FUNCNAME[0]}" 'failed_to_set_bash_echo_off'; return 1; } # Disable xtrace to avoid priting secrets

  # Get 1 argument: state name
  STATE_NAME="${1}"

  # Check state name isn't
  [ ! -z "${STATE_NAME}" ] || { error "get_state(): blank state name argument"; return 1; }

  # Check if state name contains any prohibited symbols, then error out.
  [[ ! "${STATE_NAME}" =~ ([^a-z0-9_]+) ]] || { error "get_state(): illigal characters in the state name argument: '${BASH_REMATCH[1]}'"; return 1; }

  # Make sure "${FF_AGENT_HOME}" is not empty
  if [ -z "${FF_AGENT_HOME}" ]; then
      error "Can not set state. FF_AGENT_HOME variable not defined. State would have been set to ${STATE_NAME}=${VALUE}"
      set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
      return 1
  fi

  # Construct path to the state file
  STATE_DIR="${FF_AGENT_HOME}/state"
  STATE_FILE="${STATE_DIR}/${STATE_NAME}"

  # Check if state file exists
  if [ -f "${STATE_FILE}" ]; then
    # State file found, try to print it's content and preserve result code
    VALUE="$( cat "${STATE_FILE}" )"
    EXIT_CODE=${?}
    # Print value to standard output
    echo -n "${VALUE}"
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    return ${EXIT_CODE}
  else
    # Error: state file not found. Restore xtrace and eturn code 1
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    return 1
  fi
}
export -f get_state

###############################################################################
# Utility function
function set_secret {

  # Preserve current bash echo settings and enable bash echo setting
  BASH_ECHO_SETTINGS=$( get_bash_echo_setting ) || { set_state "${FUNCNAME[0]}" 'failed_to_get_bash_echo_settings'; return 1; }

  set_state "${FUNCNAME[0]}" 'started'

  set_bash_echo_off || { set_state "${FUNCNAME[0]}" 'failed_to_set_bash_echo_off'; return 1; } # Disable xtrace to avoid priting secrets

  # Get arguments
  local URI="${1}"
  local SECRET="${2}"

  # Check FF_AGENT_HOME is set
  [ ! -z "${FF_AGENT_HOME}" ] || {
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    set_state "${FUNCNAME[0]}" 'error_envirnment_not_set_ff_agent_home'
    return 1
  }

  # Check URI is not blank
  [ ! -z "${URI}" ] || {
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    set_state "${FUNCNAME[0]}" 'error_blank_uri_argument'
    return 1
  }

  # Check if URI contains any prohibited symbols, then error out.
  [[ ! "${URI}" =~ ([^a-z0-9_]+) ]] || {
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    set_state "${FUNCNAME[0]}" 'error_illigal_characters_in_uri_argument'
    return 1
  }

  # Check SECRET is not empty
  if [ -z "${SECRET}" ]; then
      set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
      set_state "${FUNCNAME[0]}" 'error_bad_argument_secret'
      return 1
  fi

  # Create secrets directory
  local SECRET_DIRECTORY="${FF_AGENT_HOME}/secrets"
  mkdir -p "${SECRET_DIRECTORY}" || {
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    set_state "${FUNCNAME[0]}" 'failed_to_create_secrets_directory'
    return 1
  }

  # Store secret
  echo "${SECRET}" >"${SECRET_DIRECTORY}/${URI}" || { 
    set_state "${FUNCNAME[0]}" 'failed_to_write_secret'
    return 1
  }

  set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f set_secret

###############################################################################
# Utility function
#
# The set_state() function require "${FF_AGENT_HOME}" to be set to non-empty string.
#
# Note: each call to "set_state()" will also generate a JSON wich will be published
# by calling "publish_message()".
#
function set_state {

  # Get 2 arguments: state and value
  local STATE_NAME="${1}"
  local STATE_VALUE="${2}"

  # Check state name / value aren't blank
  [ ! -z "${STATE_NAME}" ] || { error "set_state(): blank state name argument"; return 1; }
  [ ! -z "${STATE_VALUE}" ] || { error "set_state(): blank state value argument"; return 1; }

  # Check if state name / vaue contains any prohibited symbols, then error out.
  [[ ! "${STATE_NAME}" =~ ([^a-z0-9_]+) ]] || { error "set_state(): illigal characters in the state name argument: '${BASH_REMATCH[1]}'"; return 1; }
  [[ ! "${STATE_VALUE}" =~ ([^a-z0-9_]+) ]] || { error "set_state(): illigal characters in the state value argument: '${BASH_REMATCH[1]}'"; return 1; }
  
  # Make sure "${FF_AGENT_HOME}" is not empty
  if [ -z "${FF_AGENT_HOME}" ]; then
      error "Can not set state. FF_AGENT_HOME variable not set. State would have been set to ${STATE_NAME}=${STATE_VALUE}"
      return 1
  fi

  local STATE_DIR="${FF_AGENT_HOME}/state"

  # Make state directory
  if [ ! -d "${STATE_DIR}" ]; then
    
    mkdir -p "${STATE_DIR}" || {
      error "Can not set state. State directory ${STATE_DIR} can not be created. State would have been set to ${STATE_NAME}=${STATE_VALUE}"
      return 1; 
    }
  fi

  # Define state filename
  local STATE_FILE="${STATE_DIR}/${STATE_NAME}"

  # Write value into the file
  echo "${STATE_VALUE}" >"${STATE_FILE}" || { error "${FUNCNAME[0]}: failed_to_write_state. State would have been set to ${STATE_NAME}=${STATE_VALUE}"; return 1; }

  # ------------------ Build JSON object "state/change" and send to FF_HOST

  # Check if framework API is defined
  if [ "$( is_framework_api_defined )" != "true" ]; then
    # No, the framework API is not defined. Simply return, we're done.
    # Return with success code 0
    return 0
  fi

  # Get current epoch time
  local TIMESTAMP_EPOCH_MS="$( get_epoch_ms )"
  
  # Check if we actually got non-empty string?
  [ ! -z "${TIMESTAMP_EPOCH_MS}" ] || { error "${FUNCNAME[0]}: failed_to_get_epoch_ms"; return 1; }
  
  # If state value contains: success|running, then: "is_success": true
  # else
  #   if state value contains: error|fail|'', then "is_error": true
  # else
  #   don't include neither "is_success" nor "is_error".
  local IS_SUCCESS_OR_IS_ERROR_JSON=''
  local IS_ERROR=false
  if [[ "${STATE_VALUE}" =~ success|running ]]; then
    IS_SUCCESS_OR_IS_ERROR_JSON='"is_success": true,'
  else
    if [[ "${STATE_VALUE}" == '' || "${STATE_VALUE}" =~ error|fail ]]; then
      IS_SUCCESS_OR_IS_ERROR_JSON='"is_error": true,'
      IS_ERROR=true
    fi
  fi

  # Get previous "old" state value
  local PREVIOUS_STATE_JSON=""
  local PREVIOUS_STATE_VALUE="$( cat ${STATE_FILE} )"
  # Only include "old_state" property if it is not-empty string
  if [ "${PREVIOUS_STATE_VALUE}" != "" ]; then
    PREVIOUS_STATE_JSON="\"previous_state\": \"${PREVIOUS_STATE_VALUE}\","
  fi

  # Compose "state/chate" JSON and pipe it to publish_message()
  # Note: we POST "state/change" JSON to ff_host. (from portal to self, from 'traffic generator' to portal, from 'inside docker' to (agent?)).
  local UUID="$( ff_uuid )" || { error "${FUNCNAME[0]}" 'failed_generate_uuid'; return 1; }

  # Check: all the environment variables used in JSON are actually set.
  local ALL_EXPECTED_ENVRIONMENT_VARIABLES=(
    FF_AGENT_URI
    FF_AGENT_USERNAME
    FF_HOST
    HOSTNAME
    IS_SUCCESS_OR_IS_ERROR_JSON
    MIME_TYPE
    NAMESPACE
    ORGANIZATION
    STATE_NAME
    STATE_VALUE
    TIMESTAMP_EPOCH_MS
    UUID
  )
  for VARIABLE_NAME in "${ALL_EXPECTED_ENVRIONMENT_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      local ERROR_CODE=$( echo "error_check_environment_variables_are_set_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )
      error "${FUNCNAME[0]}: ${ERROR_CODE}"
      return 1
    }
  done

  # Define mime_type
  MIME_TYPE="state/change"

  # Commpose JSON and publish it
  (
    cat <<- EOF
{
  "mime_type": "${MIME_TYPE}",
  "uri_template": "/set_environment/[mime_type]/id/[id]/[uuid]",
  "uri": "${NAMESPACE}::/set_environment/${MIME_TYPE}/id/${STATE_NAME}/${UUID}",
  "uuid": "${UUID}",
  "id": "${STATE_NAME}",
  "state": "${STATE_VALUE}",
  ${PREVIOUS_STATE_JSON}
  ${IS_SUCCESS_OR_IS_ERROR_JSON}
  "timestamp_epoch_ms": ${TIMESTAMP_EPOCH_MS},
  "ff_agent_uri": "${FF_AGENT_URI}",

  "is_event": true,
  "event_type": "set_environment",
  "source": "set_environment",
  "hostname": "${HOSTNAME}",
  "ff_host": "${FF_HOST}",

  "namespace": "${NAMESPACE}",
  "organization": "${ORGANIZATION}",
  "created_by": {
    "mime_type": "identity/statement",
    "user_id": $( id -u ${FF_AGENT_USERNAME} ),
    "username": "${FF_AGENT_USERNAME}"
  },
  "security_object_policy": {
    "mime_type": "security/object_policy",
    "schema_version": "ff20170505",
    "policy_language": "ff",
    "scope": {
      "can_read": "organization",
      "can_write": "system",
      "can_delete": "system"
    }
  }
}
EOF
) | publish_message

  # If we have ff_metric command handy try to sent the metric
  if command_exists ff_metric > /dev/null; then
    # Report metric: start:1    tags: service:ipsec_tunnel  (+public_ip, organization)
    ff_metric --metric-name="${STATE_NAME}" --metric-value=1 --tag=state:"${STATE_VALUE}" --tag=is_error:"${IS_ERROR}"
  fi

  # Return with success code 0
  return 0
}
export -f set_state

### END UTILITY FUNCTIONS: STATE/SECRETS



### BEGIN UTILITY FUNCTIONS: USER / GROUPS

###############################################################################
# Category: authorization
# Utility function - Can I sudo?
# @param1 user_to_check
function can_sudo {
    local USER_TO_CHECK="${1}"

    local USER_CAN_SUDO=1  # Assume they can't. 1 is an error code meaning we can't.

    # SUDOers can be defined in a few places - /etc/sudoers and /etc/sudoers.d/*
    # Note: /etc/sudoers is old and bad
    if sudo --non-interactive --list --other-user="${USER_TO_CHECK}" &>/dev/null true
    then
        USER_CAN_SUDO=0
    else
        if groups "${USER_TO_CHECK}" 2>/dev/null | grep --text "\<sudo\>" &> /dev/null; then
            USER_CAN_SUDO=0 # I can sudo
        else
            USER_CAN_SUDO=1 # I can't sudo
        fi
    fi

    # TODO: If user can sudo, have that user check if they are in old /etc/sudoers or new form
    # and emit error otherwise.

    return ${USER_CAN_SUDO}
}
export -f can_sudo

###############################################################################
# Utility function check_group_exists takes one argument (group name) and return 0 if such group exists.
# Return:
#  0 - group exists
#  1 - group does not exist or no arguments given
#
# Usage example:
#   if ! check_group_exists 'docker'; then error "Group docker does not exist"; fi
#
function check_group_exists {
  # Take argument
  local GROUP="${1}"

  # Check argument is not empty
  if [ -z "${GROUP}" ]; then
    error "check_group_exists() called with no arguments"
    return 1
  fi

  # Check if the group exist by given groupname
  getent group "${GROUP}" >/dev/null
}
export -f check_group_exists

###############################################################################
# Category: identity
# Utility function - Create User, with a disabled password
function create_user {
  local USERNAME="${1}"
	if [ ! -z "${USERNAME}" ]; then
		if can_sudo "${USERNAME}"; then
        	# TODO: Make this multiplatform. Check what happens if we do this in a docker.
        	sudo adduser --disabled-password --gecos "" "${USERNAME}"
			return ${?}
		fi
	fi
	return 1
}
export -f create_user

###############################################################################
# Category: authorization
# Utility function - Am I root? Return 0 if I am, 1 if not
function effectively_root {
    if  [ "${EUID}" -eq 0 ]; then
        return 0 # I have root powers
    else
        return 1 # Don't have root powers
    fi
}
export -f effectively_root

###############################################################################
# Category: identity
# Utility function - Get home directory for user
function get_home_directory_for_user {
    # TODO: OSX doesn't have getent. Find Equivalent
    HOME_DIR=$( getent passwd "${1}" | cut -d: -f6 )
    if [ -z "${HOME_DIR}" ]; then
        return 1
    else
        echo "${HOME_DIR}"
    fi
}
export -f get_home_directory_for_user

###############################################################################
# Category: process
# Utility function - Get cmdline of parent process ID -- useful to know who is starting us
# E.g. if [ $( get_ppid_cmd | grep --text -c node ) -gt "0" ] -> will let you check if your parent process is nodejs
function get_ppid_cmd {
    local PPID_CMD=$( cat /proc/${PPID}/cmdline )
    echo "${PPID_CMD}"
}
export -f get_ppid_cmd

###############################################################################
# Utility function - check if user is in a group
# Usage: 
# if is_user_in_group "user" "group"; then ...
#
function is_user_in_group {
  local USERNAME="${1}"
  local GROUP="${2}"
  [ -z "${USERNAME}" ] && return 1
  [ -z "${GROUP}" ] && return 1
  if getent group "${GROUP}" | grep -q "\b${USERNAME}\b"; then
      return 0
  else
      return 1
  fi
}
export -f is_user_in_group

###############################################################################
# Category: identity
# Utility function - Check if User Exists
function user_exists {
    # TODO: OSX doesn't have getent. Find Equivalent
    if [ -z "$(getent passwd ${1})" ]; then
        return 1 # User does not exist
    else
        return 0 # Exists
    fi
}
export -f user_exists

### END UTILITY FUNCTIONS: USER / GROUPS



### BEGIN DISCOVER FUNTIONS

###############################################################################
#
# Function ff_uuid() generates UUID and prints it to the standard output.
# Dependency: uuidgen
# Note: function will try to install dependency if missing.
#
# Function return code:
#   0 - success
#   1 - failure
#
# Usage example:
#    NEW_UUID=$( ff_uuid )
#    [ ${?} -eq 0 ] || { set_state "${FUNCNAME[0]}" "failed_to_ff_uuid"; return 1; }
#
function ff_uuid {

  # Check dependency: "uuidgen" we need to make sure it is installed ('uuidgen' is part of 'uuid-runtime' package)
  if ! command_exists uuidgen >/dev/null; then
    # Try to install missing dependency
    assert_clean_exit apt_update >/dev/null
    assert_clean_exit apt_install uuid-runtime >/dev/null  # Note: we mute output of apt-install otherwise it will be mixed into the ff_uuid() function result!

    # Check again
    if ! command_exists uuidgen >/dev/null; then
      # Still failing to find
      return 1
    fi
  fi

  # Generate uuid and return it's exit code as a return code
  uuidgen
}
export -f ff_uuid

###############################################################################
#
# Auxiliary function wraps the logic of choosing the best value for: 'FF_AGENT_URI'
# Note: this function uses get/set secrets and state, thus it can be called only after "choose proper user" step is complete.
#
# Function return:
#   - on success: return code 0 and choosen value printed to standard outout
#   - on failure: return code 1
#
# Usage example:
#    FF_AGENT_URI=$( get_best_ff_agent_uri ) || { set_state "${FUNCNAME[0]}" "failed_to_get_best_ff_agent_uri"; return 1; }
#
function get_best_ff_agent_uri {
  set_state "${FUNCNAME[0]}" 'started'

  # Try to get FF_AGENT_URI from environment or by get_secret()
  discover_optional_environment_variable "FF_AGENT_URI" || { set_state "${FUNCNAME[0]}" "failed_to_discover_optional_environment_variable"; return 1; }

  # Check if variable already set. If not set - generate new uuid
  if [ -z "${FF_AGENT_URI}" ]; then
      # Generate new uuid, check errors, export new value
      local UUID="$( ff_uuid )" || { set_state "${FUNCNAME[0]}" "failed_to_generate_new_uuid"; return 1; }
      FF_AGENT_URI="/agent/agent_guid/${UUID}"
  fi

  # At this point we must have not empty FF_AGENT_URI value.
  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'FF_AGENT_URI' || { set_state "${FUNCNAME[0]}" "error_ensure_variable_not_empty_ff_agent_uri"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${FF_AGENT_URI}"
  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f get_best_ff_agent_uri

###############################################################################
#
# Auxiliary function wraps the logic of choosing the best value for: 'FF_CONTENT_URL'
# Note: this function uses get/set secrets and state, thus it can be called only after "choose proper user" step is complete.
#
# Function return:
#   - on success: return code 0 and choosen value printed to standard outout
#   - on failure: return code 1
#
# Usage example:
#  FF_CONTENT_URL=$( get_best_ff_content_url )
#  [ ${?} -eq 0 ] || { set_state "${FUNCNAME[0]}" "failed_to_get_best_ff_content_url"; return 1; }
#
function get_best_ff_content_url {
  set_state "${FUNCNAME[0]}" 'started'

  # Try to get FF_CONTENT_URL from environment or by get_secret()
  discover_optional_environment_variable "FF_CONTENT_URL" || { set_state "${FUNCNAME[0]}" "failed_to_discover_optional_environment_variable"; return 1; }

  # Remove trailing slash from FF_CONTENT_URL, so it works correctly when we concatenate
  # FF_CONTENT_URL with other path components (e.g.: ${}/subfolder/file.txt)
  # Note: its save to call trim_slash() even if FF_CONTENT_URL is empty at this step.
  FF_CONTENT_URL="$( trim_slash "${FF_CONTENT_URL}" )" || { set_state "${FUNCNAME[0]}" "error_trim_slash_from_ff_content_url"; return 1; }

  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'FF_CONTENT_URL' || { set_state "${FUNCNAME[0]}" "error_ensure_variable_not_empty_ff_content_url"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${FF_CONTENT_URL}"
  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f get_best_ff_content_url

###############################################################################
#
# Auxiliary function wraps the logic of choosing the best value for: 'FF_HOST'
# Note: this function uses get/set secrets and state, thus it can be called only after "choose proper user" step is complete.
#
# Function return:
#   - on success: return code 0 and choosen value printed to standard outout
#   - on failure: return code 1
#
# Usage example:
#  UPLOAD_TO=$( get_best_ff_host )
#  [ ${?} -eq 0 ] || { set_state "${FUNCNAME[0]}" "failed_to_get_best_ff_host"; return 1; }
#
function get_best_ff_host {
  set_state "${FUNCNAME[0]}" 'started'

  # Try to get FF_HOST from environment or by get_secret()
  discover_optional_environment_variable "FF_HOST" || { set_state "${FUNCNAME[0]}" "failed_to_discover_optional_environment_variable_ff_host"; return 1; } # Note: FF_HOST: FF_HOST will be set to legacy portal hostname if this is a portal.

  # Check if variable already set. If not try to get it's value by command 'hostname'
  [ -z "${FF_HOST}" ] && { FF_HOST="$( hostname )"; }

  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'FF_HOST' || { set_state "${FUNCNAME[0]}" "error_ensure_variable_not_empty_ff_host"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${FF_HOST}"
  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f get_best_ff_host

###############################################################################
#
# Auxiliary function wraps the logic of choosing the best value for: 'FF_HOST'
# Note: this function uses get/set secrets and state, thus it can be called only after "choose proper user" step is complete.
#
# Function return:
#   - on success: return code 0 and choosen value printed to standard outout
#   - on failure: return code 1
#
function get_best_ff_port {
  set_state "${FUNCNAME[0]}" 'started'
  FF_PORT_DEFAULT=443

  # Try to get FF_PORT from environment or by get_secret()
  discover_optional_environment_variable "FF_PORT" || { set_state "${FUNCNAME[0]}" "failed_to_discover_optional_environment_variable_ff_port"; return 1; }

  # Check if variable already set. If not then use default
  [ -z "${FF_PORT}" ] && { FF_PORT="${FF_PORT_DEFAULT}"; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${FF_PORT}"
  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f get_best_ff_port

###############################################################################
#
function get_best_namespace {
  set_state "${FUNCNAME[0]}" 'started'

  # Try to get value from environment or by get_secret()
  discover_optional_environment_variable "NAMESPACE" || { set_state "${FUNCNAME[0]}" "failed_to_discover_optional_environment_variable_namespace"; return 1; }

  # Check if variable already set. If not set it to our default "system.local" namespace: '00000000-0000-0000-0000-000000000000'.
  [ -z "${NAMESPACE}" ] && { NAMESPACE='00000000-0000-0000-0000-000000000000'; }

  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'NAMESPACE' || { set_state "${FUNCNAME[0]}" "error_ensure_variable_not_empty_namespace"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${NAMESPACE}"
  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f get_best_namespace

###############################################################################
#
function get_best_organization {
  set_state "${FUNCNAME[0]}" 'started'

  # Try to get value from environment or by get_secret()
  discover_optional_environment_variable "ORGANIZATION" || { set_state "${FUNCNAME[0]}" "failed_to_discover_optional_environment_variable_organization"; return 1; }

  # Check if variable already set. If not set it to our default organization "system.local"
  [ -z "${ORGANIZATION}" ] && { ORGANIZATION='system.local'; }

  # Make sure the variable is now not empty or error out.
  ensure_variable_not_empty 'ORGANIZATION' || { set_state "${FUNCNAME[0]}" "error_ensure_variable_not_empty_organization"; return 1; }

  # Print result to standard output, set state to 'success' and return success code.
  echo "${ORGANIZATION}"
  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f get_best_organization

###############################################################################
#
# Figure out environment - where are we?
#
# First the function is trying to choose right FF_AGENT_HOME, then it
# gets the best values for the following environment variables:
#    - FF_CONTENT_URL
#    - FF_AGENT_URI
#    - FF_HOST
#
# Dependencies:
#    - FF_CONTENT_URL variable must be set either by "set_secrets" or in environment variable
#
# Function return code:
#   0 - on success
#   1 - on failure
#
function discover_environment {

  ######################################################################
  # Choose user, agent home and make sure agent home folder exists
  #
  # Choose proper user to run as create "ff_agent" folder (known as ${FF_AGENT_HOME}).
  # The proper user is not root but user with sudo that can install packages.
  # We need to choose_ff_agent_home before we can set/get secrets.
  # This sets some of environment variables: FF_AGENT_USERNAME, FF_AGENT_HOME.
  # Also creates FF_AGENT_HOME directory.
  # Baseline installer must set the following environment variables:
  #  [x] FF_AGENT_USERNAME  (see choose_ff_agent_home())
  #  [x] FF_AGENT_USER_HOME (see choose_ff_agent_home())
  #  [x] FF_AGENT_HOME      (see choose_ff_agent_home())
  #  [x] FF_AGENT_URI (see get_best_ff_agent_uri())
  #  [x] FF_HOST (see get_best_ff_host())
  #  [x] FF_CONTENT_URL (see get_best_ff_content_url())
  #  [x] NAMESPACE (see get_best_namespace())
  #  [x] N_PREFIX (see install_n())
  #  [x] ORGANIZATION (see get_best_organization())
  #  [x] TERM  (see terminal_initialize())
  #
  # Preserving a set of other discussed environment values to add in future:
  #  FF_PROTOCOL
  #  FF_API_TOKEN
  #  FF_PROXY_HOST
  #  FF_PROXY_PORT
  #  FF_PROXY_PROTOCOL
  #  FF_PROXY_USERNAME
  #  FF_PROXY_PASSWORD
  #
  choose_ff_agent_home || { abort "failed_to_choose_ff_agent_home"; }
  ensure_ff_agent_home_exists || { abort "failed_to_ensure_ff_agent_home_exists"; }

  # Get best values, check errors, export and set_secret().
  FF_CONTENT_URL=$( get_best_ff_content_url ) || { abort "failed_to_get_best_ff_content_url"; }
  set_secret ff_content_url "${FF_CONTENT_URL}"
  export FF_CONTENT_URL

  # Similarly for best NAMESPACE
  NAMESPACE=$( get_best_namespace ) || { abort "failed_to_get_best_namespace"; }
  set_secret namespace "${NAMESPACE}"
  export NAMESPACE

  # Similarly for best ORGANIZATION
  ORGANIZATION=$( get_best_organization ) || { abort "failed_to_get_best_organization"; }
  set_secret organization "${ORGANIZATION}"
  export ORGANIZATION

  # Similarly for FF_AGENT_URI
  FF_AGENT_URI=$( get_best_ff_agent_uri )     || { abort "failed_to_get_best_ff_agent_uri"; }
  set_secret ff_agent_uri "${FF_AGENT_URI}"
  export FF_AGENT_URI

  FF_HOST=$( get_best_ff_host )               || { abort "failed_to_get_best_ff_host"; }
  set_secret ff_host "${FF_HOST}"
  export FF_HOST

  FF_PORT=$( get_best_ff_port )               || { abort "failed_to_get_best_ff_port"; }
  set_secret ff_port "${FF_PORT}"
  export FF_PORT

  # ######################################################################
  # # Discover set of "ff environment" variables
  # discover_ff_environment || { set_state "${FUNCNAME[0]}" "failed_to_discover_ff_environment"; return 1; }

  return 0
}
export -f discover_environment

# ###############################################################################
# #
# function discover_ff_environment {

#     # Define 2 lists of variable names and default values: required and optional.
#     # It creates a local variable (only seen in scope of current f-n)
#     declare -A REQUIRED_VARIABLES
#     # REQUIRED_VARIABLES[FF_HOST]=''
#     # REQUIRED_VARIABLES[FF_PORT]='443'
#     # REQUIRED_VARIABLES[FF_PROTOCOL]='https'

#     declare -A OPTIONAL_VARIABLES
#     OPTIONAL_VARIABLES[FF_HOST]=''
#     OPTIONAL_VARIABLES[FF_PORT]='443'
#     OPTIONAL_VARIABLES[FF_PROTOCOL]='https'
#     OPTIONAL_VARIABLES[FF_API_USERNAME]=''
#     OPTIONAL_VARIABLES[FF_API_PASSWORD]=''
#     OPTIONAL_VARIABLES[FF_API_TOKEN]=''
#     OPTIONAL_VARIABLES[FF_PROXY_HOST]=''
#     OPTIONAL_VARIABLES[FF_PROXY_PORT]=''
#     OPTIONAL_VARIABLES[FF_PROXY_PROTOCOL]=''
#     OPTIONAL_VARIABLES[FF_PROXY_USERNAME]=''
#     OPTIONAL_VARIABLES[FF_PROXY_PASSWORD]=''

#     # Discover required variables
#     for NAME in "${!REQUIRED_VARIABLES[@]}"; do
#         # Check NAME is not empty
#         [ -z "${NAME}" ] && { continue; }
#         # Get default value and call discovery f-n
#         local DEFAULT_VALUE="${REQUIRED_VARIABLES[${NAME}]}"
#         discover_required_environment_variable "${NAME}" "${DEFAULT_VALUE}" || { return 1; }
#     done

#     # Discover optional variables
#     for NAME in "${!OPTIONAL_VARIABLES[@]}"; do
#         # Check NAME is not empty
#         [ -z "${NAME}" ] && { continue; }
#         # Get default value and call discovery f-n
#         local DEFAULT_VALUE="${OPTIONAL_VARIABLES[${NAME}]}"
#         discover_optional_environment_variable "${NAME}" "${DEFAULT_VALUE}" || { return 1; }
#     done
# }
# export -f discover_ff_environment

###############################################################################
#
# F-n takes 2 arguments:
#    - environment variable name (must be not empty)
#    - default value (can be blank if no default value set)
#
# F-n checks:
#    - if such variable already exists function export that variable and exits with no changes to the existing value
#    - if no such variable exists f-n tries to get previously stored value by calling "get_secret ${NAME}" and export this value (if found)
#    - if no value found on previous steps, then f-n exports this variable with ${DEFAULT_VALUE} (only if default value is not blank)
#
# Return code:
#   0 - on success
#   1 - on error
#
# Dependency: tr
#
function discover_optional_environment_variable {
  local NAME="${1}"
  local DEFAULT_VALUE="${2}"

  # Check inputs: NAME can be empty
  [ -z "${NAME}" ] && { return 1; }

  # Check if such environment already defined
  if [[ -v "${NAME}" ]]; then
      # Variable '${NAME}' is already defined (has value: '${!NAME}').
      # Make sure to export it, so if it was just "shell variable"
      # it becomes "environment variable", thus available even for child processes.
      export "${NAME}"="${!NAME}"
      return 0
  fi

  # Dependency check: 'tr' is installed
  if ! command_exists tr >/dev/null; then
    error "${FUNCNAME[0]}" 'error_dependency_not_met_tr'
    return 1
  fi
  
  # Try to get value by "get_secret()"
  local NAME_LOWERCASE="$( echo "${NAME}" | tr '[:upper:]' '[:lower:]' )"
  local RESTORED_VALUE=$( get_secret "${NAME_LOWERCASE}" )
  if [ ! -z "${RESTORED_VALUE}" ]; then
      # Got non-empty value, use it to export variable
      export "${NAME}"="${RESTORED_VALUE}"
      return 0
  fi

  # Variable not yet defined, define it using default value
  if [ ! -z "${DEFAULT_VALUE}" ]; then
      export "${NAME}"="${DEFAULT_VALUE}"
      return 0
  fi

  # Case: can't find variable value neither from "get_secret()" nor from "DEFAULT_VALUE". Not an error.
  return 0
}
export -f discover_optional_environment_variable

###############################################################################
#
# discover_os() tries to identify operating system type/version and return it as a string.
# In case of error it will return string: "unknown"
#
function discover_os {

    local OS_FAMILY="unknown"

    # Detect the platform based on "OSTYPE" variable
    case "${OSTYPE}" in
    darwin*)  OS_FAMILY="macos" ;;
    linux*)   OS_FAMILY="linux" ;;
    linux-gnu*)   OS_FAMILY="linux" ;;
    bsd*)     OS_FAMILY="bsd" ;;
    msys*)    OS_FAMILY="windows" ;;
    cygwin*)  OS_FAMILY="windows" ;;
    *)        OS_FAMILY="unknown" ;;  # Failed to id OS, this is not an error yet, we have 2nd attpempt (see below).
    esac

    # If OS_FAMILY still not set, try to detect the platform based on "uname" output
    if [ "${OS_FAMILY}" == "unknown" ]; then
        OS="`uname`"
        case ${OS} in
        'Linux') OS_FAMILY='linux' ;;
        'FreeBSD') OS_FAMILY='bsd' ;;
        'WindowsNT') OS_FAMILY='windows' ;;
        'Darwin')  OS_FAMILY='macos' ;;
        #'AIX') OS_FAMILY='aix' ;;
        *) ;;
        esac
    fi

    echo "${OS_FAMILY}"
}
export -f discover_os

###############################################################################
#
# F-n discover_required_environment_variable is similar to discover_optional_environment_variable, but after an attempt
# to discover variable it checks if the value was actually found/set and if not, then error out.
#
function discover_required_environment_variable {
  local NAME="${1}"
  local DEFAULT_VALUE="${2}"

  # Check inputs: NAME can be empty
  [ -z "${NAME}" ] && { return 1; }

  # Try to discover
  discover_optional_environment_variable "${NAME}" "${DEFAULT_VALUE}"

  # Check: must be discovered, otherwise error out
  if [[ ! -v "${NAME}" ]]; then
      # Variable '${NAME}' is not defined, but required. Return an error.
      return 1
  fi

  return 0
}
export -f discover_required_environment_variable

###############################################################################
# Category: time
# Utility function to get Unix epoch time in milliseconds
# Usage example:
#   "current epoch_ms value is: $( get_epoch_ms )"
function get_epoch_ms {
    # TODO - Make this compatible with Darwin (MACOS) where date works differently.
    # For details on "date" command on Linux vs Darwin see discussion:
    # https://stackoverflow.com/questions/9804966/date-command-does-not-follow-linux-specifications-mac-os-x-lion
    echo "$( date +%s%N | cut -b1-13 )"  # https://serverfault.com/a/151112/413686>
}
export -f get_epoch_ms

###############################################################################
# Category: environment
# Utility function - Get hardware architecture (e.g. arm64, amd64)
function get_hardware_architecture {
    dpkg --print-architecture
}
export -f get_hardware_architecture

###############################################################################
# Category: environment
# Utility function - Get os name - e.g. linux
function get_os_name {
  local OS_NAME="$( basename $( uname --operating-system ) | tr '[:upper:]' '[:lower:]' )"
  if [ -z "${OS_NAME}" ]; then
    # Error, got empty string
    return 1
  fi

  echo "${OS_NAME}"
  return 0
}
export -f get_os_name

###############################################################################
# Category: environment
# Utility function - Get codename - e.g. breezy, focal, ..
function get_lsb_codename {
    lsb_release --short --codename
}
export -f get_lsb_codename

###############################################################################
# Category: environment
# Utility function - Get LSB ID - e.g. Ubuntu
function get_lsb_id {
    lsb_release --short --id
}
export -f get_lsb_id

###############################################################################
# Category: environment
# Utility function - Get LSB ID - e.g. ubuntu
function get_lsb_id_downcase {
  # Dependency check: 'tr' is installed
  if ! command_exists tr >/dev/null; then
    set_state "${FUNCNAME[0]}" 'error_dependency_not_met_tr'
    return 1
  fi

  lsb_release --short --id | tr '[:upper:]' '[:lower:]'
}
export -f get_lsb_id_downcase

###############################################################################
# Category: environment
# Utility function - Get release - e.g. 16.04, 18.04, 20.04
function get_lsb_release {
    lsb_release --short --release
}
export -f get_lsb_release

### END DISCOVER FUNCTIONS


### BEGIN SET ENVIRONMENT FUNCTIONS

###############################################################################
# Utility function check_environment_variables_are_set() checks if all the expected environment variables are set
#
# On success: reuturn 0
# On failure: return 1
#
function check_environment_variables_are_set {
  set_state "${FUNCNAME[0]}" 'started'

  # Dependency check: 'tr' is installed
  if ! command_exists tr >/dev/null; then
    set_state "${FUNCNAME[0]}" 'error_dependency_not_met_tr'
    return 1
  fi

  # Define list of required environment variables (must be not empty)
  local ALL_EXPECTED_ENVRIONMENT_VARIABLES=(
    FF_AGENT_USERNAME
    FF_AGENT_HOME
    FF_AGENT_URI
    FF_HOST
    FF_CONTENT_URL
    N_PREFIX
    TERM
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${ALL_EXPECTED_ENVRIONMENT_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      local ERROR_CODE=$( echo "error_check_environment_variables_are_set_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f check_environment_variables_are_set

###############################################################################
# Utility function check_ff_agent_bin_is_in_the_path()
# On success: reuturn 0
# On failure: 1
#
function check_ff_agent_bin_is_in_the_path {
  set_state "${FUNCNAME[0]}" 'started'

  local FF_AGENT_BIN="${FF_AGENT_HOME}/bin"
  printenv PATH | grep --quiet "${FF_AGENT_BIN}"
  [ ${?} -ne 0 ] && {
    # Error
    set_state "${FUNCNAME[0]}" 'failed_to_find_expected_path'
    return 1
  }

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f check_ff_agent_bin_is_in_the_path

###############################################################################
# Utility function check_nodejs_installation() checks if nodejs is installed
# under right path and expected version
#
# On success: reuturn 0
# On failure: 1
#
function check_nodejs_installation {
  set_state "${FUNCNAME[0]}" 'started'

  local ERRORS_COUNT=0
  # Check nodejs is installed
  local WHICH_NODE="$( command_exists node )"
  if [ "${WHICH_NODE}" == "" ]; then
    # 'node' does not exist
    ERROR_CODE="error_check_nodejs_installation_nodejs_not_installed"
    set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
    (( ERRORS_COUNT++ ))
  else
    # 'node' exists: run few more node-related checks
    # Check nodejs is not installed under /usr
    [[ "${WHICH_NODE}" =~ ^/usr/ ]] && {
      ERROR_CODE="error_check_nodejs_installation_wrong_installation_dir"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      (( ERRORS_COUNT++ ))
    }

    # Get expected nodejs version
    local EXPECTED_VERSION="$( get_expected_nodejs_version )"
    [ -z "${EXPECTED_VERSION}" ] && {
      ERROR_CODE="failed_to_get_expected_nodejs_version"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      (( ERRORS_COUNT++ ))
    }

    # Get actual nodejs version
    local ACTUAL_VERSION="$( node --version )"
    [ -z "${ACTUAL_VERSION}" ] && {
      ERROR_CODE="failed_to_get_actual_nodejs_version"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      (( ERRORS_COUNT++ ))
    }

    # Compare expected vs actual nodejs versions
    if [ "${EXPECTED_VERSION}" != "${ACTUAL_VERSION}" ]; then
      # Version mismatch
      ERROR_CODE="error_mismatching_nodejs_versions"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      (( ERRORS_COUNT++ ))
    fi
  fi

  # Check npm is installed
  WHICH_NPM=$( command_exists npm )
  [ "${WHICH_NPM}" != "" ] || {
    ERROR_CODE="error_check_npm_installation_nodejs_not_installed"
    set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
    (( ERRORS_COUNT++ ))
  }

  # Check npm is not installed under /usr
  [[ "${WHICH_NPM}" =~ ^/usr/ ]] && {
    ERROR_CODE="error_check_npm_installation_wrong_installation_dir"
    set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
    (( ERRORS_COUNT++ ))
  }

  # List of all the checks done with their statuses
  if [ ${ERRORS_COUNT} -gt 0 ]; then
    # We found errors
    set_state "${FUNCNAME[0]}" 'failed'
    return 1
  fi

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f check_nodejs_installation

###############################################################################
# Utility function check_set_get_secret() checks if set_secret() and get_secret()
# work as expected.
#
# On success: reuturn 0
# On failure: return 1 and prints error to standard error stream
#
function check_set_get_secret {
  set_state "${FUNCNAME[0]}" 'started'
  
  SECRET_NAME="check_set_get_secret"
  SECRET_VALUE=$( ff_uuid ) || { set_state "${FUNCNAME[0]}" 'failed_generate_uuid'; return 1; }

  set_secret "${SECRET_NAME}" "${SECRET_VALUE}" || { set_state "${FUNCNAME[0]}" 'failed_set_secret'; return 1; }

  local RETRIEVED_VALUE=$( get_secret "${SECRET_NAME}" ) || {
    set_state "${FUNCNAME[0]}" 'failed_retrieve_secret'
    return 1
  }

  # Compare retrieved state with expected
  if [ "${RETRIEVED_VALUE}" != "${SECRET_VALUE}" ]; then
    # Mismatch (error)
    set_state "${FUNCNAME[0]}" 'error_retrieved_value_mismatch'
    return 1
  fi

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f check_set_get_secret

###############################################################################
# Utility function check_set_get_state() checks if set_state() and get_state()
# work as expected.
#
# On success: reuturn 0
# On failure: return 1 and prints error to standard error stream
#
# Depend on: uuidgen, tr.
#
function check_set_get_state {
  set_state "${FUNCNAME[0]}" 'started'

  # Check tr is installed
  if ! command_exists tr >/dev/null; then
    set_state "${FUNCNAME[0]}" 'error_dependency_not_met_tr'
    return 1
  fi

  STATE_NAME="check_set_get_state"
  STATE_VALUE=$( ff_uuid | tr -d '-' )

  # Check generated STATE_VALUE is not empty
  [ ! -z "${STATE_VALUE}" ] || { set_state "${FUNCNAME[0]}" 'failed_generate_random_state_value'; return 1; }

  # Set state and try to retrieve value
  set_state "${STATE_NAME}" "${STATE_VALUE}" || { return 1; }
  local RETRIEVED_VALUE=$( get_state "${STATE_NAME}" ) || { set_state "${FUNCNAME[0]}" 'failed_retrieve_state'; return 1; }

  # Compare retrieved and expected values
  if [ "${RETRIEVED_VALUE}" != "${STATE_VALUE}" ]; then
    # Mismatch (error)
    set_state "${FUNCNAME[0]}" 'error_retrieved_value_mismatch'
    return 1
  fi

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f check_set_get_state

###############################################################################
#
# Function get_current_user is a smarter alternative to ${USER} environment variable,
# which might not be set when running inside docker.
#
# Function sets state and return following:
#   On success function prints current user to standard output and return code 0.
#   On error/failure function return code 1.
#
# Usage example:
#     CURRENT_USER="$(get_current_user)" || { error "Can not get current user"; return 1; }
#
# For more details see discussion:
# https://stackoverflow.com/questions/54411218/docker-why-isnt-user-environment-variable-set
#
# Tested in Ubuntu 20.04: docker run -it --rm ubuntu:20.04 bash  => echo "${USER}"  => blank
#
function get_current_user {
  # set_state "${FUNCNAME[0]}" 'started'

  # Check if environment variable USER is set, then use it.
  if [ -z "${USER}" ]; then
    # The USER environment variable is blank.
    # Use command_exists to check if 'whoami' is available
    if ! command_exists whoami >/dev/null; then
      # set_state "${FUNCNAME[0]}" 'error_whoami_not_installed'
      return 1
    fi

    # Try to get current username by 'whoami'
    USER="$( whoami )" || { echo "ERROR whoami command failed"; return 1; }
    [ ! -z "${USER}" ] || { echo "failed_to_get_current_user"; return 1; }
  fi

  # Print username to standard output
  echo "${USER}"

  # Return success
  # set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f get_current_user

###############################################################################
#
# Function choose_ff_agent_home:
#
# Sets the following environment variables:
#   FF_AGENT_USERNAME - example: ubuntu
#   FF_AGENT_HOME          - example: /home/ubuntu/ff_agent
#
# Return:
#  on success - export environment variables and return 0
#  on error - return nonzero code
#
# Baseline installer must choose the "best user" (not root, able to sudo).
#
# Reason why we must avoid using root user: if program started by root user and a security
# flaw is exploited, the attacker has access to all the data and can directly control the system.
# For example, it might install a trojan or key-logger into your kernel. We only escalate user
# privileges when required and allowed/agreed to install dependency packages.
#
# Failure to choose the right user would end up in the terminal installation error:
# "terminal_error_failed_to_discover_environment".
#
function choose_ff_agent_home {

    # These exports are our "return values"
    # Note: we should not get value from subprocess and call 'export' on the same 1-line liek this: "export SOMEVAR=$( some_function_call ) || { error "error details"; return 1; } "
    #       because export would hide actual exit call of the "some_function_call" and thus we'll miss an error!
    FF_AGENT_USERNAME=$( get_ff_agent_username ) || { error "terminal_error_failed_to_choose_user"; return 1; }
    export FF_AGENT_USERNAME

    # Even if this function run by some other/not-chosen" user, the FF_AGENT_USER_HOME would point to the "right/choosen" home. Example: /home/ubuntu
    # Only when we run as ritgh/choosen user the FF_AGENT_USER_HOME and HOME have the same values.
    FF_AGENT_USER_HOME=$( get_home_directory_for_user "${FF_AGENT_USERNAME}" ) || { error "terminal_error_failed_to_get_agent_user_home"; return 1; }
    export FF_AGENT_USER_HOME
          
    local AGENT_DIR_NAME="ff_agent"
    export FF_AGENT_HOME="${FF_AGENT_USER_HOME}/${AGENT_DIR_NAME}"
}
export -f choose_ff_agent_home

###############################################################################
#
# Function makes sure ${FF_AGENT_HOME} folder exist. If not - tries to create it.
#
# Require environment variables set:
#   - FF_AGENT_HOME
#   - FF_AGENT_USERNAME
#
# Return:
#  on success - return 0
#  on error - return nonzero code
#
function ensure_ff_agent_home_exists {
  set_state "${FUNCNAME[0]}" 'started'

  # Dependency check: 'tr' is installed
  if ! command_exists tr >/dev/null; then
    set_state "${FUNCNAME[0]}" 'error_dependency_not_met_tr'
    return 1
  fi

  # Define required variables
  local REQUIRED_VARIABLES=(
    FF_AGENT_HOME
    FF_AGENT_USERNAME
  )

  # Check required environment variables are set
  for VARIABLE_NAME in "${REQUIRED_VARIABLES[@]}"; do
    ensure_variable_not_empty "${VARIABLE_NAME}" || {
      local ERROR_CODE="$( echo "failed_to_ensure_variable_not_empty_${VARIABLE_NAME}" | tr '[:upper:]' '[:lower:]' )"
      set_state "${FUNCNAME[0]}" "${ERROR_CODE}"
      return 1
    }
  done

  # Make sure ${FF_AGENT_HOME} folder exist
  if [ ! -d "${FF_AGENT_HOME}" ]; then
      # ${FF_AGENT_HOME} folder is missing: create new one.
      mkdir -p "${FF_AGENT_HOME}"
      if [ ${?} -ne 0 ]; then
        # Failed to create ${FF_AGENT_HOME} - report error and return code 1
        set_state "${FUNCNAME[0]}" "failed_to_create_ff_agent_home"
        return 1
      fi
  fi

  set_state "${FUNCNAME[0]}" 'success'
  return 0
}
export -f ensure_ff_agent_home_exists

###############################################################################
#
# Function takes the only parameter: REST-API "call" and makes https GET request: https://${FF_HOST}${CALL}
#
# Usage example:  ff_api_get "/admin/organizations"
#
function ff_api_get {
    CALL="${1}"

    [ ! -z "${CALL}" ] || { return 1; }
    [ ! -z "${FF_API_USERNAME}" ] || { return 1; }
    [ ! -z "${FF_API_PASSWORD}" ] || { return 1; }
    [ ! -z "${FF_HOST}" ] || { return 1; }

    # Run command, capture server response as ${RESULT} and curl exit code as ${STATUS}
    RESULT=$( curl -s --retry 5 -u "${FF_API_USERNAME}:${FF_API_PASSWORD}" https://${FF_HOST}${CALL} )
    STATUS=${?}

    if [ "${STATUS}" != "0" ]; then
        return ${STATUS}
    fi

    if [[ ${RESULT} =~ (^Cannot GET) ]]; then
        return 1
    fi

    if [[ ${RESULT} =~ (^.*"mime_type".+"rest/error") ]]; then
        return 1
    fi

    echo ${RESULT}
    return 0
}
export -f ff_api_get

###############################################################################
# Function prints into standard output the expected version of nodejs.
# We use it during installation and to check installed "set environment" project.
function get_expected_nodejs_version {
  echo 'v18.4.0'
}
export -f get_expected_nodejs_version

###############################################################################
#
# Find out the best user to run as.
# Return:
#  on success - return code 0 and print a username to use to standard output.
#  on error   - log error() and return 1
#
# The logic "best user" selection:
# We don't run as root, or root-like account.
# We would like an account that can install packages to set the environment up correctly.
# We check the following user accounts candidates: "ff_agent", "ubuntu" or current user.
# Selected user should have rights to install packages. Ideally locally, but one step at a time.
#
function get_ff_agent_username {

    CURRENT_USER="$(get_current_user)" || { error "Can not get current user"; return 1; }

    POTENTIAL_USERS=( ff_agent ubuntu ${CURRENT_USER} )

    if effectively_root
    then
        # Look for a better user.
        for POTENTIAL_USER in "${POTENTIAL_USERS[@]}"
        do
            if user_exists ${POTENTIAL_USER}
            then
                if can_sudo "${POTENTIAL_USER}"
                then
                    echo "${POTENTIAL_USER}"
                    return 0
                fi
            fi
        done

        error "Current user ${CURRENT_USER} is effectively root and this script can not run as root."
        error "Tried to find other users to run as (${POTENTIAL_USERS}) but was not successful."
        return 1

    else
        # We aren't root. But can we sudo? We need that to currently install certain packages.
        if can_sudo "${CURRENT_USER}"
        then
            echo "${CURRENT_USER}"
            return 0
        else
            error "User ${CURRENT_USER} can not sudo. Currently sudo is required to install packages. Please run from a non-root account with sudo privileges."
            return 1
        fi
    fi
}
export -f get_ff_agent_username

###############################################################################
#
# Function checks if we have framework API defined by checking if all of the following is set:
#    - FF_HOST
#    - ( FF_API_USERNAME and FF_API_PASSWORDS ) OR ( FF_API_TOKEN )
#
# As a result: functions prints "true" or "false" into std output stream.
# Usage example:
#    if [ "$( is_framework_api_defined )" == "true" ]; then
#       : # yes, the framework API is defined
#    fi
#
function is_framework_api_defined {
  # Print 'false' if FF_HOST not set
  [ -z "${FF_HOST}" ] && { echo 'false'; return; }

  # Print 'true' if both FF_API_USERNAME and FF_API_PASSWORDS are set
  [ ! -z "${FF_API_USERNAME}" ] && [ ! -z "${FF_API_PASSWORDS}" ] && { echo 'true'; return; }

  # Print 'true' if FF_API_TOKEN is set
  [ ! -z "${FF_API_TOKEN}" ] && { echo 'true'; return; }

  # Print 'false' in all other cases
  echo 'false'
  return
}
export -f is_framework_api_defined

###############################################################################
# Utility function is_set_environment_working() checks if all the aspects of "set_environment"
# are in place and functioning as expected
#
function is_set_environment_working {
  set_state "${FUNCNAME[0]}" 'started'

  # Check the "command_exists" exists
  command_exists command_exists >/dev/null || { set_state "${FUNCNAME[0]}" 'failed_dependency_command_exists'; return 1; }

  # Loop through array of f-nested f-ns, on error set flag HAS_ERRORS (don't exit)
  local HAS_ERRORS=false
  CHECKS=(
    # Check expected environments are in place
    check_environment_variables_are_set

    # Check nodejs installation
    check_nodejs_installation

    # Check set_state() / get_state() by setting random value to some test state and then retrieving it back
    check_set_get_state

    # Check set_secret() / get_secret() by setting random value to some test secret and then retrieving it back
    check_set_get_secret

    # Check ff_agent/bin is in the path
    check_ff_agent_bin_is_in_the_path
  )

  local COMMAND  # Declare variable local, so it does not polute our scope outside this f-n
  for COMMAND in "${CHECKS[@]}"; do
    if ! command_exists >/dev/null "${COMMAND}"; then
      # Error: command not found
      HAS_ERRORS=true
      set_state "error_command_not_found_${COMMAND}"
    else
      # Command exists, run it and check result
      "${COMMAND}" || { HAS_ERRORS=true; set_state "error_command_failed_${COMMAND}"; }
    fi
  done

  # TODO: check docker is installed with >= minimal version (if install_docker() was required in given environment)

  # TODO: check if list of required basic packages is installed

  # TODO: instead of "cherry-picking" what to check we should have 1:1 "doer/instaler" and corresponding "checker" functions defined, which we'll call here by list.

  # Check if we have any errors
  if [ "${HAS_ERRORS}" == "true" ]; then
    # We have errors
    #set_state "${FUNCNAME[0]}" 'failed'  # commented since set_state was already called by concrete check with better (more precise) error code
    return 1
  else
    set_state "${FUNCNAME[0]}" 'success'
    return 0
  fi
}
export -f is_set_environment_working

###############################################################################
#
# Function publish_message() takes JSON payload, wraps it into the message and posts JSON to the FF_HOST.
#
# Function returns 0 upon successfully sending POST to FF_HOST, any other code otherwise.
#
# Usage example:
#   echo '{"a": 1, "b": true}' | publish_message
#   cat  "/path/to/file.json"  | publish_message
#
function publish_message {

  # Preserve current bash echo settings and enable bash echo setting
  BASH_ECHO_SETTINGS=$( get_bash_echo_setting ) || { return 1; } # Note: can't use set_state here otherwize will fall into recursive loop

  set_bash_echo_off || { return 1; } # Disable xtrace to avoid priting secrets. Note: can't use set_state here otherwize will fall into recursive loop

  # Read piped json
  INPUT_JSON=`cat`

  # Check inputs
  local FF_API_USERNAME=$( get_secret ff_api_username )
  if [ "${FF_API_USERNAME}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    # error: FF_API_USERNAME is missing
    # can't use set_state here otherwize will fall into recursive loop
    return 1
  fi

  local FF_API_PASSWORD=$( get_secret ff_api_password )
  if [ "${FF_API_PASSWORD}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    # error: FF_API_PASSWORD is missing
    # can't use set_state here otherwize will fall into recursive loop
    return 1
  fi

  if [ "${INPUT_JSON}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    # error: INPUT_JSON is missing
    return 1
  fi

  if [ "${FF_HOST}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    # error: FF_HOST is missing
    return 1
  fi

  local UUID="$( ff_uuid )"
  if [ "${UUID}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    # error: failed to generate UUID
    return 1
  fi

  local TRANSACTION_ID="$( ff_uuid )"
  if [ "${TRANSACTION_ID}" == "" ]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    # error: failed to generate TRANSACTION_ID
    return 1
  fi

  if ! command_exists curl >/dev/null; then
    log "WARNING: curl is not yet isntalled. Skppping publishing JSON: ${INPUT_JSON}"
    return 0
  fi

  # Wrap input JSON into the MESSAGE
  local MESSAGE=$(
    # Part 1/3: headers and start of payload
    cat <<- EOF
    {
      "uri": "/organization/${ORGANIZATION}/delivery/message/${UUID}",
      "mime_type": "delivery/message",
      "header": {
        "mime_type": "delivery/request_header",
        "transaction_id": "${TRANSACTION_ID}",

        ${HAS_ERRORS_ELEMENT}

        "from": "/service/set_environment/instance/${UUID}",
        "to":"/service/storage"
      },
      "payload": [
EOF
    # Part 2/3: payload
    echo "${INPUT_JSON}"

    # Part 3/3: footer: closing payload array and message envelop
    cat <<- EOF
      ]
    }
EOF
  )

  # Run command, capture server response as ${RESULT} and curl exit code as ${STATUS}
  local RESULT=$(
    curl \
      --silent   \
      --retry 5    \
      --request POST \
      --header "Content-Type: application/json" \
      --data "${MESSAGE}" \
      --user "${FF_API_USERNAME}:${FF_API_PASSWORD}" \
      https://${FF_HOST}/
  ) || {
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    return 1
  }

  # Even if curl succeed, check some edge cases, when server replied with some JSON error
  if [[ ${RESULT} =~ (^Cannot GET) ]]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    return 1
  fi

  # Check if resut has error mime_type (TODO: improve it to rely on actual response http_code, see implemented in get_by_url())
  if [[ ${RESULT} =~ (^.*"mime_type".+"rest/error") ]]; then
    set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
    return 1
  fi

  # Return success
  set_bash_echo_setting "${BASH_ECHO_SETTINGS}"  # Restore bash echo settings
  return 0
}
export -f publish_message

### END SET ENVIRONMENT FUNCTIONS

terminal_initialize
